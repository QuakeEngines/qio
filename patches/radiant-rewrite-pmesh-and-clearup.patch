Index: q3radiant/Brush.cpp
===================================================================
--- q3radiant/Brush.cpp	(revision 459)
+++ q3radiant/Brush.cpp	(working copy)
@@ -31,21 +31,11 @@
 
 int g_nBrushId = 0;
 
-const char* Brush_Name(brush_t *b)
-{
-  static char cBuff[1024];
-	b->numberId = g_nBrushId++;
-	if (g_qeglobals.m_bBrushPrimitMode)
-  {
-    sprintf(cBuff, "Brush %i", b->numberId);
-    Brush_SetEpair(b, "Name", cBuff);
-  }
-  return cBuff;
-}
 
-brush_t *Brush_Alloc()
+
+brush_s *Brush_Alloc()
 {
-  brush_t *b = (brush_t*)qmalloc(sizeof(brush_t));
+  brush_s *b = (brush_s*)qmalloc(sizeof(brush_s));
   return b;
 }
 
@@ -166,9 +156,9 @@
 Face_Alloc
 ================
 */
-face_t *Face_Alloc( void )
+face_s *Face_Alloc( void )
 {
-	face_t *f = (face_t*)qmalloc( sizeof( *f ) );
+	face_s *f = (face_s*)qmalloc( sizeof( *f ) );
 
 	return f;
 }
@@ -178,7 +168,7 @@
 Face_Free
 ================
 */
-void Face_Free( face_t *f )
+void Face_Free( face_s *f )
 {
 	assert( f != 0 );
 
@@ -200,9 +190,9 @@
 Face_Clone
 ================
 */
-face_t	*Face_Clone (face_t *f)
+face_s	*Face_Clone (face_s *f)
 {
-	face_t	*n;
+	face_s	*n;
 
 	n = Face_Alloc();
 	n->texdef = f->texdef;
@@ -220,9 +210,9 @@
 makes an exact copy of the face
 ================
 */
-face_t	*Face_FullClone (face_t *f)
+face_s	*Face_FullClone (face_s *f)
 {
-	face_t	*n;
+	face_s	*n;
 
 	n = Face_Alloc();
 	n->texdef = f->texdef;
@@ -253,7 +243,7 @@
 Face_MoveTexture
 ================
 */
-void Face_MoveTexture(face_t *f, const edVec3_c &delta)
+void Face_MoveTexture(face_s *f, const edVec3_c &delta)
 {
 	edVec3_c vX, vY;
 /*
@@ -298,7 +288,7 @@
 Face_SetColor
 ================
 */
-void Face_SetColor (brush_t *b, face_t *f, float fCurveColor) 
+void Face_SetColor (brush_s *b, face_s *f, float fCurveColor) 
 {
 	float	shade;
 	qtexture_t *q;
@@ -329,7 +319,7 @@
 TTimo: NOTE: this is never to get called while in brush primitives mode
 ================
 */
-void Face_TextureVectors (face_t *f, float STfromXYZ[2][4])
+void Face_TextureVectors (face_s *f, float STfromXYZ[2][4])
 {
 	edVec3_c		pvecs[2];
 	int			sv, tv;
@@ -416,7 +406,7 @@
 Face_MakePlane
 ================
 */
-void Face_MakePlane (face_t *f)
+void Face_MakePlane (face_s *f)
 {
 	int		j;
 	edVec3_c	t1, t2, t3;
@@ -441,7 +431,7 @@
 EmitTextureCoordinates
 ================
 */
-void EmitTextureCoordinates (texturedVertex_c &out, qtexture_t *q, face_t *f)
+void EmitTextureCoordinates (texturedVertex_c &out, qtexture_t *q, face_s *f)
 {
 	float	STfromXYZ[2][4];
 
@@ -458,9 +448,9 @@
 Brush_MakeFacePlanes
 ================
 */
-void Brush_MakeFacePlanes (brush_t *b)
+void Brush_MakeFacePlanes (brush_s *b)
 {
-	face_t	*f;
+	face_s	*f;
 
 	for (f=b->brush_faces ; f ; f=f->next)
 	{
@@ -473,7 +463,7 @@
 DrawBrushEntityName
 ================
 */
-void DrawBrushEntityName (brush_t *b)
+void DrawBrushEntityName (brush_s *b)
 {
 	char	*name;
 	//float	a, s, c;
@@ -549,10 +539,10 @@
 returns the visible polygon on a face
 =================
 */
-winding_t *Brush_MakeFaceWinding (brush_t *b, face_t *face)
+winding_t *Brush_MakeFaceWinding (brush_s *b, face_s *face)
 {
 	winding_t	*w;
-	face_t		*clip;
+	face_s		*clip;
 	edPlane_c			plane;
 	bool		past;
 
@@ -605,10 +595,10 @@
 Brush_SnapPlanepts
 =================
 */
-void Brush_SnapPlanepts (brush_t *b)
+void Brush_SnapPlanepts (brush_s *b)
 {
 	int		i, j;
-	face_t	*f;
+	face_s	*f;
 
   if (g_PrefsDlg.m_bNoClamp)
     return;
@@ -628,7 +618,7 @@
 // added a bConvert flag to convert between old and new brush texture formats
 // TTimo
 // brush grouping: update the group treeview if necessary
-void Brush_Build( brush_t *b, bool bSnap, bool bMarkMap, bool bConvert )
+void Brush_Build( brush_s *b, bool bSnap, bool bMarkMap, bool bConvert )
 {
 	bool		bLocalConvert;
 
@@ -657,9 +647,6 @@
 	if (g_qeglobals.d_select_mode == sel_vertex || g_qeglobals.d_select_mode == sel_edge)
 		SetupVertexSelection ();
 
-    if (b->itemOwner == NULL)
-      Group_AddToProperGroup(b);
-
 	if (bMarkMap)
 	{
 		Sys_MarkMapModified();
@@ -684,10 +671,10 @@
 The incoming face is NOT left referenced.
 ==============
 */
-void Brush_SplitBrushByFace (brush_t *in, face_t *f, brush_t **front, brush_t **back)
+void Brush_SplitBrushByFace (brush_s *in, face_s *f, brush_s **front, brush_s **back)
 {
-	brush_t	*b;
-	face_t	*nf;
+	brush_s	*b;
+	face_s	*nf;
 //	vec3_t	temp;
 
 	b = Brush_Clone (in);
@@ -741,9 +728,9 @@
 return NULL if the brush is convex
 =================
 */
-face_t *Brush_BestSplitFace(brush_t *b)
+face_s *Brush_BestSplitFace(brush_s *b)
 {
-	face_t *face, *f, *bestface;
+	face_s *face, *f, *bestface;
 	winding_t *front, *back;
 	int splits, tinywindings, value, bestvalue;
 
@@ -799,10 +786,10 @@
 NOTE: the input brush should have windings for the faces.
 =================
 */
-brush_t *Brush_MakeConvexBrushes(brush_t *b)
+brush_s *Brush_MakeConvexBrushes(brush_s *b)
 {
-	brush_t *front, *back, *end;
-	face_t *face;
+	brush_s *front, *back, *end;
+	face_s *face;
 
 	b->next = NULL;
 	face = Brush_BestSplitFace(b);
@@ -827,9 +814,9 @@
 Brush_Convex
 =================
 */
-int Brush_Convex(brush_t *b)
+int Brush_Convex(brush_s *b)
 {
-	face_t *face1, *face2;
+	face_s *face1, *face2;
 
 	for (face1 = b->brush_faces; face1; face1 = face1->next)
 	{
@@ -870,10 +857,10 @@
 #define INTERSECT_EPSILON	0.1
 #define POINT_EPSILON		0.3
 //
-//int Brush_MoveVertex_old1(brush_t *b, vec3_t vertex, vec3_t delta, vec3_t end, bool bSnap)
+//int Brush_MoveVertex_old1(brush_s *b, vec3_t vertex, vec3_t delta, vec3_t end, bool bSnap)
 //{
-//	face_t *f, *face, *newface, *lastface, *nextface;
-//	face_t *movefaces[MAX_MOVE_FACES];
+//	face_s *f, *face, *newface, *lastface, *nextface;
+//	face_s *movefaces[MAX_MOVE_FACES];
 //	int movefacepoints[MAX_MOVE_FACES];
 //	winding_t *w, tmpw;
 //	int i, j, k, nummovefaces, result;
@@ -1118,10 +1105,10 @@
 #define INTERSECT_EPSILON	0.1
 #define POINT_EPSILON		0.3
 
-//int Brush_MoveVertex_old2(brush_t *b, vec3_t vertex, vec3_t delta, vec3_t end, bool bSnap)
+//int Brush_MoveVertex_old2(brush_s *b, vec3_t vertex, vec3_t delta, vec3_t end, bool bSnap)
 //{
-//	face_t *f, *face, *newface, *lastface, *nextface;
-//	face_t *movefaces[MAX_MOVE_FACES];
+//	face_s *f, *face, *newface, *lastface, *nextface;
+//	face_s *movefaces[MAX_MOVE_FACES];
 //	int movefacepoints[MAX_MOVE_FACES];
 //	winding_t *w, tmpw;
 //	int i, j, k, nummovefaces, result;
@@ -1310,10 +1297,10 @@
 
 #define MAX_MOVE_FACES		64
 
-int Brush_MoveVertex(brush_t *b, const edVec3_c &vertex, const edVec3_c &delta, edVec3_c &end, bool bSnap)
+int Brush_MoveVertex(brush_s *b, const edVec3_c &vertex, const edVec3_c &delta, edVec3_c &end, bool bSnap)
 {
-	face_t *f, *face, *newface, *lastface, *nextface;
-	face_t *movefaces[MAX_MOVE_FACES];
+	face_s *f, *face, *newface, *lastface, *nextface;
+	face_s *movefaces[MAX_MOVE_FACES];
 	int movefacepoints[MAX_MOVE_FACES];
 	winding_t *w, tmpw;
 	edVec3_c start, mid;
@@ -1588,9 +1575,9 @@
 Brush_InsertVertexBetween
 =================
 */
-int Brush_InsertVertexBetween(brush_t *b, const edVec3_c &p1, const edVec3_c &p2)
+int Brush_InsertVertexBetween(brush_s *b, const edVec3_c &p1, const edVec3_c &p2)
 {
-	face_t *face;
+	face_s *face;
 	winding_t *w, *neww;
 	edVec3_c point;
 	int i, insert;
@@ -1637,11 +1624,11 @@
 Brush_ResetFaceOriginals
 =================
 */
-void Brush_ResetFaceOriginals(brush_t *b)
+void Brush_ResetFaceOriginals(brush_s *b)
 {
 	if(b == 0)
 		return;
-	face_t *face;
+	face_s *face;
 
 	for (face = b->brush_faces; face; face = face->next)
 	{
@@ -1658,10 +1645,10 @@
 */
 //++timo FIXME: when using old brush primitives, the test loop for "Brush" and "patchDef2" "patchDef3" is ran
 // before each face parsing. It works, but it's a performance hit
-brush_t *Brush_Parse (void)
+brush_s *Brush_Parse (void)
 {
-	brush_t		*b;
-	face_t		*f;
+	brush_s		*b;
+	face_s		*f;
 	int			i,j;
 	
 	g_qeglobals.d_parsed_brushes++;
@@ -1742,7 +1729,7 @@
 			}
 			else
 			{
-				face_t *scan;
+				face_s *scan;
 				for (scan=b->brush_faces ; scan->next ; scan=scan->next)
 					;
 				scan->next = f;
@@ -1817,56 +1804,9 @@
 	return b;
 }
 
-/*
-==============
-Brush_SetEpair
-sets an epair for the given brush
-==============
-*/
-void Brush_SetEpair(brush_t *b, const char *pKey, const char *pValue)
-{
-	if (g_qeglobals.m_bBrushPrimitMode)
-	{
-		if (b->patchBrush)
-		{
-		  Patch_SetEpair(b->pPatch, pKey, pValue);
-		}
-		else
-		{
-			  SetKeyValue(b->epairs, pKey, pValue);
-		}
-	}
-	else
-	{
-		Sys_Printf("Can only set key/values in Brush primitive mode\n");
-	}
-}
 
-/* 
-=================
-Brush_GetKeyValue
-=================
-*/
-const char* Brush_GetKeyValue(brush_t *b, const char *pKey)
-{
-	if (g_qeglobals.m_bBrushPrimitMode)
-	{
-    if (b->patchBrush)
-    {
-      return Patch_GetKeyValue(b->pPatch, pKey);
-    }
-    else
-    {
-		  return ValueForKey(b->epairs, pKey);
-    }
-	}
-	else
-	{
-		Sys_Printf("Can only set brush/patch key/values in Brush primitive mode\n");
-	}
-  return "";
-}
 
+
 /*
 =================
 Brush_Write
@@ -1873,10 +1813,9 @@
 save all brushes as Brush primitive format
 =================
 */
-void Brush_Write (brush_t *b, FILE *f)
+void Brush_Write (brush_s *b, FILE *f)
 {
-	epair_t	*ep;
-	face_t	*fa;
+	face_s	*fa;
 	char	*pname;
 	int		i;
 	
@@ -1889,10 +1828,6 @@
 	{
 		// save brush primitive format
 		fprintf (f, "{\nbrushDef\n{\n");
-		// brush epairs
-		if (b->epairs)
-			for (ep = b->epairs ; ep ; ep=ep->next)
-				fprintf (f, "\"%s\" \"%s\"\n", ep->key, ep->value);
 		for (fa=b->brush_faces ; fa ; fa=fa->next)
 		{
 			// save planepts
@@ -2000,10 +1935,9 @@
 save all brushes as Brush primitive format
 =================
 */
-void Brush_Write (brush_t *b, CMemFile *pMemFile)
+void Brush_Write (brush_s *b, CMemFile *pMemFile)
 {
-	epair_t *ep;
-	face_t	*fa;
+	face_s	*fa;
 	char *pname;
 	int		i;
 	
@@ -2017,10 +1951,6 @@
 	{
 		// brush primitive format
 		MemFile_fprintf (pMemFile, "{\nBrushDef\n{\n");
-		// brush epairs
-		if (b->epairs)
-			for( ep = b->epairs ; ep ; ep=ep->next )
-				MemFile_fprintf (pMemFile, "\"%s\" \"%s\"\n", ep->key, ep->value );
 		for (fa=b->brush_faces ; fa ; fa=fa->next)
 		{
 			// save planepts
@@ -2112,12 +2042,12 @@
 The brush is NOT linked to any list
 =============
 */
-brush_t	*Brush_Create (vec3_t mins, vec3_t maxs, texdef_t *texdef)
+brush_s	*Brush_Create (vec3_t mins, vec3_t maxs, texdef_t *texdef)
 {
 	int		i, j;
 	vec3_t	pts[4][2];
-	face_t	*f;
-	brush_t	*b;
+	face_s	*f;
+	brush_s	*b;
 
 	// brush primitive mode : convert texdef to brushprimit_texdef ?
 	// most of the time texdef is empty
@@ -2204,7 +2134,7 @@
 The brush is NOT linked to any list
 =============
 */
-brush_t	*Brush_CreatePyramid (vec3_t mins, vec3_t maxs, texdef_t *texdef)
+brush_s	*Brush_CreatePyramid (vec3_t mins, vec3_t maxs, texdef_t *texdef)
 {
 	int i;
 	//++timo handle new brush primitive ? return here ??
@@ -2214,7 +2144,7 @@
 		if (maxs[i] < mins[i])
 			Error ("Brush_InitSolid: backwards");
 
-	brush_t* b = Brush_Alloc();
+	brush_s* b = Brush_Alloc();
 
 	vec3_t corners[4];
 
@@ -2248,7 +2178,7 @@
 	// sides
 	for (i = 0; i < 4; i++)
 	{
-		face_t* f = Face_Alloc();
+		face_s* f = Face_Alloc();
 		f->texdef = *texdef;
 		f->texdef.flags &= ~SURF_KEEP;
 		f->texdef.contents &= ~CONTENTS_KEEP;
@@ -2289,9 +2219,9 @@
 {
 	int		i, axis;
 	edVec3_c	mins, maxs;
-	brush_t	*b;
+	brush_s	*b;
 	texdef_t	*texdef;
-	face_t	*f;
+	face_s	*f;
 	vec3_t	mid;
 	float	width;
 	float	sv, cv;
@@ -2413,15 +2343,10 @@
 Removes from groups
 =============
 */
-void Brush_Free (brush_t *b, bool bRemoveNode)
+void Brush_Free (brush_s *b, bool bRemoveNode)
 {
-	face_t	*f, *next;
-	epair_t	*ep, *enext;
+	face_s	*f, *next;
 
-	// remove from group
-	if (bRemoveNode)
-		Group_RemoveBrush(b);
-
 	// free the patch if it's there
 	if (b->patchBrush)
 	{
@@ -2435,15 +2360,6 @@
 		Face_Free( f );
 	}
 
-	//Timo : free brush epairs
-	for (ep = b->epairs ; ep ; ep=enext )
-	{
-		enext = ep->next;
-		free (ep->key);
-		free (ep->value);
-		free (ep);
-	}
-
 	// unlink from active/selected list
 	if (b->next)
 		Brush_RemoveFromList (b);
@@ -2460,7 +2376,7 @@
 Face_MemorySize
 =============
 */
-int Face_MemorySize(face_t *f )
+int Face_MemorySize(face_s *f )
 {
 	int size = 0;
 
@@ -2478,10 +2394,9 @@
 Brush_MemorySize
 =============
 */
-int Brush_MemorySize(brush_t *b)
+int Brush_MemorySize(brush_s *b)
 {
-	face_t	*f;
-	epair_t	*ep;
+	face_s	*f;
 	int size = 0;
 
 	//
@@ -2494,13 +2409,6 @@
 	{
 		size += Face_MemorySize(f);
 	}
-	//
-	for (ep = b->epairs; ep; ep = ep->next )
-	{
-		size += _msize(ep->key);
-		size += _msize(ep->value);
-		size += _msize(ep);
-	}
 	size += _msize(b);
 	return size;
 }
@@ -2513,14 +2421,14 @@
 Does NOT add the new brush to any lists
 ============
 */
-brush_t *Brush_Clone (brush_t *b)
+brush_s *Brush_Clone (brush_s *b)
 {
-	brush_t	*n = NULL;
-	face_t	*f, *nf;
+	brush_s	*n = NULL;
+	face_s	*f, *nf;
 
 	if (b->patchBrush)
 	{
-		patchMesh_t *p = Patch_Duplicate(b->pPatch);
+		patchMesh_c *p = Patch_Duplicate(b->pPatch);
 		Brush_RemoveFromList(p->pSymbiot);
 		Entity_UnlinkBrush(p->pSymbiot);
 		n = p->pSymbiot;
@@ -2528,7 +2436,6 @@
 	else
 	{
   	n = Brush_Alloc();
-	  n->numberId = g_nBrushId++;
 		n->owner = b->owner;
 		for (f=b->brush_faces ; f ; f=f->next)
 		{
@@ -2550,15 +2457,15 @@
 Does NOT add the new brush to any lists
 ============
 */
-brush_t *Brush_FullClone(brush_t *b)
+brush_s *Brush_FullClone(brush_s *b)
 {
-	brush_t	*n = NULL;
-	face_t *f, *nf, *f2, *nf2;
+	brush_s	*n = NULL;
+	face_s *f, *nf, *f2, *nf2;
 	int j;
 
 	if (b->patchBrush)
 	{
-		patchMesh_t *p = Patch_Duplicate(b->pPatch);
+		patchMesh_c *p = Patch_Duplicate(b->pPatch);
 		Brush_RemoveFromList(p->pSymbiot);
 		Entity_UnlinkBrush(p->pSymbiot);
 		n = p->pSymbiot;
@@ -2568,7 +2475,6 @@
 	else
 	{
   	n = Brush_Alloc();
-   	n->numberId = g_nBrushId++;
 		n->owner = b->owner;
 		n->bounds = b->bounds;
 		//
@@ -2618,11 +2524,11 @@
 Returns NULL and 0 if not hit at all
 ==============
 */
-face_t *Brush_Ray (const edVec3_c &origin, const edVec3_c &dir, brush_t *b, float *dist)
+face_s *Brush_Ray (const edVec3_c &origin, const edVec3_c &dir, brush_s *b, float *dist)
 {
 	if(b == 0)
 		return 0;
-	face_t	*f, *firstface;
+	face_s	*f, *firstface;
 	edVec3_c	p1, p2;
 	float	frac, d1, d2;
 	int		i;
@@ -2667,9 +2573,9 @@
 }
 
 //PGM
-face_t *Brush_Point (const edVec3_c &origin, brush_t *b)
+face_s *Brush_Point (const edVec3_c &origin, brush_s *b)
 {
-	face_t	*f;
+	face_s	*f;
 	float	d1;
 
 	for (f=b->brush_faces ; f ; f=f->next)
@@ -2686,7 +2592,7 @@
 //PGM
 
 
-void	Brush_AddToList (brush_t *b, brush_t *list)
+void	Brush_AddToList (brush_s *b, brush_s *list)
 {
 	if (b->next || b->prev)
 		Error ("Brush_AddToList: allready linked");
@@ -2704,7 +2610,7 @@
 	b->prev = list;
 }
 
-void	Brush_RemoveFromList (brush_t *b)
+void	Brush_RemoveFromList (brush_s *b)
 {
 	if (!b->next || !b->prev)
 		Error ("Brush_RemoveFromList: not linked");
@@ -2735,10 +2641,10 @@
 		if NULL, ask for a default
 ===============
 */
-void SetFaceTexdef (brush_t *b, face_t *f, texdef_t *texdef, brushprimit_texdef_t *brushprimit_texdef, bool bFitScale, IPluginTexdef* pPlugTexdef) {
+void SetFaceTexdef (brush_s *b, face_s *f, texdef_t *texdef, brushprimit_texdef_s *brushprimit_texdef, bool bFitScale, IPluginTexdef* pPlugTexdef) {
 	int		oldFlags;
 	int		oldContents;
-	face_t	*tf;
+	face_s	*tf;
 
 	oldFlags = f->texdef.flags;
 	oldContents = f->texdef.contents;
@@ -2786,9 +2692,9 @@
 }
 
 
-void Brush_SetTexture (brush_t *b, texdef_t *texdef, brushprimit_texdef_t *brushprimit_texdef, bool bFitScale, IPluginTexdef* pTexdef)
+void Brush_SetTexture (brush_s *b, texdef_t *texdef, brushprimit_texdef_s *brushprimit_texdef, bool bFitScale, IPluginTexdef* pTexdef)
 {
-	for (face_t* f = b->brush_faces ; f ; f = f->next) 
+	for (face_s* f = b->brush_faces ; f ; f = f->next) 
 	{
 		SetFaceTexdef (b, f, texdef, brushprimit_texdef, bFitScale, pTexdef);
 	}
@@ -2802,7 +2708,7 @@
 }
 
 
-bool ClipLineToFace (edVec3_c &p1, edVec3_c &p2, face_t *f)
+bool ClipLineToFace (edVec3_c &p1, edVec3_c &p2, face_s *f)
 {
 	float	d1, d2, fr;
 	int		i;
@@ -2849,13 +2755,13 @@
 rotates and adds the planepts of adjacent face if shear is set
 ==============
 */
-void Brush_SelectFaceForDragging (brush_t *b, face_t *f, bool shear)
+void Brush_SelectFaceForDragging (brush_s *b, face_s *f, bool shear)
 {
 	int		i;
-	face_t	*f2;
+	face_s	*f2;
 	winding_t	*w;
 	float	d;
-	brush_t	*b2;
+	brush_s	*b2;
 	int		c;
 
 	if (b->owner->eclass->fixedsize)
@@ -2956,10 +2862,10 @@
 planes for dragging
 ==============
 */
-void Brush_SideSelect (brush_t *b, vec3_t origin, vec3_t dir
+void Brush_SideSelect (brush_s *b, vec3_t origin, vec3_t dir
 					   , bool shear)
 {
-	face_t	*f, *f2;
+	face_s	*f, *f2;
 	edVec3_c	p1, p2;
 	if(b == 0)
 		return;
@@ -2992,11 +2898,10 @@
 	
 }
 
-void Brush_BuildWindings( brush_t *b, bool bSnap )
+void Brush_BuildWindings( brush_s *b, bool bSnap )
 {
 	winding_t *w;
-	face_t    *face;
-	vec_t      v;
+	face_s    *face;
 
 	if (bSnap)
 		Brush_SnapPlanepts( b );
@@ -3012,7 +2917,7 @@
 
 	for ( ; face ; face=face->next)
 	{
-		int i, j;
+		int i;
 		free(face->face_winding);
 		w = face->face_winding = Brush_MakeFaceWinding (b, face);
 		face->d_texture = Texture_ForName( face->texdef.name );
@@ -3068,9 +2973,9 @@
 Frees any overconstraining faces
 ==================
 */
-void Brush_RemoveEmptyFaces ( brush_t *b )
+void Brush_RemoveEmptyFaces ( brush_s *b )
 {
-	face_t	*f, *next;
+	face_s	*f, *next;
 
 	f = b->brush_faces;
 	b->brush_faces = NULL;
@@ -3088,9 +2993,9 @@
 	}
 }
 
-void Brush_SnapToGrid(brush_t *pb)
+void Brush_SnapToGrid(brush_s *pb)
 {
-	for (face_t *f = pb->brush_faces ; f; f = f->next)
+	for (face_s *f = pb->brush_faces ; f; f = f->next)
 	{
 		for (int i = 0 ;i < 3 ;i++)
 		{
@@ -3103,9 +3008,9 @@
 	Brush_Build(pb);
 }
 
-void Brush_Rotate(brush_t *b, vec3_t vAngle, vec3_t vOrigin, bool bBuild)
+void Brush_Rotate(brush_s *b, vec3_t vAngle, vec3_t vOrigin, bool bBuild)
 {
-	for (face_t* f=b->brush_faces ; f ; f=f->next)
+	for (face_s* f=b->brush_faces ; f ; f=f->next)
 	{
 		for (int i=0 ; i<3 ; i++)
 		{
@@ -3118,7 +3023,7 @@
 	}
 }
 
-void Brush_Center(brush_t *b, const edVec3_c &vNewCenter)
+void Brush_Center(brush_s *b, const edVec3_c &vNewCenter)
 {
 	edVec3_c vMid;
 	// get center of the brush
@@ -3133,12 +3038,12 @@
 }
 
 // only designed for fixed size entity brushes
-void Brush_Resize(brush_t *b, vec3_t vMin, vec3_t vMax)
+void Brush_Resize(brush_s *b, vec3_t vMin, vec3_t vMax)
 {
-	brush_t *b2 = Brush_Create(vMin, vMax, &b->brush_faces->texdef);
+	brush_s *b2 = Brush_Create(vMin, vMax, &b->brush_faces->texdef);
 
-	face_t *next;
-	for (face_t *f=b->brush_faces ; f ; f=next)
+	face_s *next;
+	for (face_s *f=b->brush_faces ; f ; f=next)
 	{
 		next = f->next;
 		Face_Free( f );
@@ -3154,433 +3059,13 @@
 }
 
 
-eclass_t* HasModel(brush_t *b)
+eclass_s* HasModel(brush_s *b)
 {
-	edVec3_c vMin, vMax;
-	vMin[0] = vMin[1] = vMin[2] = 9999;
-	vMax[0] = vMax[1] = vMax[2] = -9999;
-
-	if (b->owner->md3Class != NULL)
-	{
-		return b->owner->md3Class;
-	}
-
-	if (Eclass_hasModel(b->owner->eclass, vMin, vMax))
-	{
-		return b->owner->eclass;
-	}
-
-	eclass_t *e = NULL;
-	// FIXME: entity needs to track whether a cache hit failed and not ask again
-	if (b->owner->eclass->nShowFlags & ECLASS_MISCMODEL)
-	{
-		char *pModel = ValueForKey(b->owner, "model");
-		if (pModel != NULL && strlen(pModel) > 0)
-		{
-			e = GetCachedModel(b->owner, pModel, vMin, vMax);
-			if (e != NULL)
-			{
-				// we need to scale the brush to the proper size based on the model load
-				// recreate brush just like in load/save
-
-				vMin += b->owner->origin;
-				vMax += b->owner->origin;
-
-				Brush_Resize(b, vMin, vMax);
-
-	/*
-	//
-	vec3_t vTemp, vTemp2;
-	VectorSubtract(b->maxs, b->mins, vTemp);
-	VectorSubtract(vMax, vMin, vTemp2);
-	for (int i = 0; i < 3; i++)
-	{
-	if (vTemp[i] != 0)
-	{
-	vTemp2[i] /= vTemp[i];
-	}
-	}
-	vec3_t vMid, vMid2;
-	vMid[0] = vMid[1] = vMid[2] = 0.0;
-	vMid2[0] = vMid2[1] = vMid2[2] = 0.0;
-
-	for (int j = 0; j < 3; j++)
-	{
-	vMid2[j] = b->mins[j] + abs((b->maxs[j] - b->mins[j]) * 0.5);
-	}
-
-	//VectorSubtract(vMid2, vMid, vMid2);
-
-	for (face_t* f=b->brush_faces ; f ; f=f->next)
-	{
-	for (int i=0 ; i<3 ; i++)
-	{
-
-	// scale
-	VectorSubtract(f->planepts[i], vMid2, f->planepts[i]);
-	f->planepts[i][0] *= vTemp2[0];
-	f->planepts[i][1] *= vTemp2[1];
-	f->planepts[i][2] *= vTemp2[2];
-	VectorAdd(f->planepts[i], vMid2, f->planepts[i]);
-	}
-	}
-
-	//Brush_Center(b, b->owner->origin);
-
-	//Brush_SnapToGrid(b);
-	/*
-	float a = FloatForKey (b->owner, "angle");
-	if (a)
-	{
-	vec3_t vAngle;
-	vAngle[0] = vAngle[1] = 0;
-	vAngle[2] = a;
-	Brush_Rotate(b, vAngle, b->owner->origin);
-	}
-	else
-	{
-	Brush_Build(b, true);
-	*/
-	//        }
-
-				b->bModelFailed = false;
-			}
-			else
-			{
-				b->bModelFailed = true;
-			}
-		} 
-	}
-	return e;
+	return 0;
 }
 
-static bool g_bInPaintedModel = false;
-static bool g_bDoIt = false;
-bool PaintedModel(brush_t *b, bool bOkToTexture)
+void FacingVectors (entity_s *e, vec3_t forward, vec3_t right, vec3_t up)
 {
-	if (g_bInPaintedModel)
-	{ 
-		return true;
-	}
-
-	if (g_PrefsDlg.m_nEntityShowState == ENTITY_BOX || b->bModelFailed)
-	{
-		return false;
-	}
-	else if (!IsBrushSelected(b) && (g_PrefsDlg.m_nEntityShowState & ENTITY_SELECTED_ONLY))
-	{
-		return false;
-	}
-
-	g_bInPaintedModel = true;
-	bool bReturn = false;
-
-	eclass_t *pEclass = HasModel(b);
-
-	if (pEclass)
-	{
-	qglPushAttrib(GL_ALL_ATTRIB_BITS);
-	entitymodel *model = pEclass->model;
-
-
-	float a = FloatForKey (b->owner, "angle");
-	while (model != NULL)
-	{
-		if (bOkToTexture == false || g_PrefsDlg.m_nEntityShowState & ENTITY_WIREFRAME || model->nTextureBind == -1)	// skinned
-		{
-			qglDisable( GL_CULL_FACE );
-			qglPolygonMode (GL_FRONT_AND_BACK, GL_LINE);
-			qglDisable(GL_TEXTURE_2D);
-			qglColor3fv(pEclass->color);
-		}
-		else
-		{
-			qglColor3f(1, 1, 1);
-			qglEnable(GL_TEXTURE_2D);
-			qglBindTexture( GL_TEXTURE_2D, model->nTextureBind );
-		}
-		edVec3_c v;
-
-		int i,j;
-#if 0
-		v = (b->maxs + b->mins) * 0.5f;
-#else
-		// who was writing this, that line overwrites the previous one...
-		// this radiant code REALLY needs a clearup!
-		v = b->owner->origin;
-#endif
-
-		//for (i = 0; i < 3; i++)
-		//{
-		//  v[i] -= (pEclass->mins[i] - b->mins[i]);
-		//}
-
-		//if (model->nModelPosition)
-		//{
-		//v[2] = b->mins[2] - (pEclass->mins[2]);
-		//}
-
-		float s, c;
-		//if (a)
-		{
-			s = sin (DEG2RAD(a));
-			c = cos (DEG2RAD(a));
-		}
-
-		edVec3_c vSin(0,0,0);
-		edVec3_c vCos(0,0,0);
-		for ( j = 0; j < 3; j++)
-		{
-			if (b->owner->vRotation[j])
-			{
-				vSin[j] = sin(DEG2RAD(b->owner->vRotation[j]));
-				vCos[j] = cos(DEG2RAD(b->owner->vRotation[j]));
-			}
-		}
-
-
-		qglBegin (GL_TRIANGLES);
-
-		vec5_t vTest[3];
-		for (i = 0; i < model->nTriCount; i++)
-		{
-			for (j = 0; j < 3; j++)
-			{
-				#if 1
-				float x = model->pTriList[i].v[j][0] + v[0];
-				float y = model->pTriList[i].v[j][1] + v[1];
-				if (a)
-				{
-					float x2 = (((x - v[0]) * c) - ((y - v[1]) * s)) + v[0];
-					float y2 = (((x - v[0]) * s) + ((y - v[1]) * c)) + v[1];
-					x = x2;
-					y = y2;
-				}
-				//qglTexCoord2f (pEclass->pTriList[i].st[j][0] / pEclass->nSkinWidth, pEclass->pTriList[i].st[j][1] / pEclass->nSkinHeight);
-				qglTexCoord2f (model->pTriList[i].st[j][0], model->pTriList[i].st[j][1]);
-				qglVertex3f(x, y, model->pTriList[i].v[j][2] + v[2]);
-				#else
-				float x = model->pTriList[i].v[j][0] + v[0];
-				float y = model->pTriList[i].v[j][1] + v[1];
-				float z = model->pTriList[i].v[j][2] + v[2];
-
-				if (b->owner->vRotation[0])
-				{
-					float y2 = (((y - v[1]) * vCos[0]) - ((z - v[2]) * vSin[0])) + v[1];
-					float z2 = (((y - v[1]) * vSin[0]) + ((z - v[2]) * vCos[0])) + v[2];
-					y = y2;
-					z = z2;
-				}
-				if (b->owner->vRotation[1])
-				{
-					float z2 = (((z - v[2]) * vCos[1]) - ((x - v[0]) * vSin[1])) + v[2];
-					float x2 = (((z - v[2]) * vSin[1]) + ((x - v[0]) * vCos[1])) + v[0];
-					x = x2;
-					z = z2;
-				}
-				if (b->owner->vRotation[2])
-				{
-					float x2 = (((x - v[0]) * vCos[2]) - ((y - v[1]) * vSin[2])) + v[0];
-					float y2 = (((x - v[0]) * vSin[2]) + ((y - v[1]) * vCos[2])) + v[1];
-					x = x2;
-					y = y2;
-				}
-				qglTexCoord2f (model->pTriList[i].st[j][0], model->pTriList[i].st[j][1]);
-				qglVertex3f(x, y, z);
-				#endif
-				if (g_bDoIt)
-				{
-					vTest[j][0] = x;
-					vTest[j][1] = y;
-					vTest[j][2] = model->pTriList[i].v[j][2] + v[2];
-					vTest[j][3] = model->pTriList[i].st[j][0];
-					vTest[j][4] = model->pTriList[i].st[j][1];
-				}
-
-				}
-				if (g_bDoIt)
-				{
-					Patch_FromTriangle(vTest[0], vTest[1], vTest[2]);
-				}
-			}
-			qglEnd();
-			if (g_PrefsDlg.m_nEntityShowState & ENTITY_WIREFRAME)	// skinned
-			{
-				qglEnable(GL_CULL_FACE );
-				qglEnable(GL_TEXTURE_2D);
-				qglPolygonMode (GL_FRONT_AND_BACK, GL_FILL);
-			}
-			else
-			{
-				qglDisable(GL_TEXTURE_2D);
-			}
-			model = model->pNext;
-		}
-
-		if (g_bDoIt)
-		{
-			g_bDoIt = false;
-		}
-
-		edVec3_c  vColor = edVec3_c(pEclass->color) * 0.50;
-
-		edVec3_c vCenter, vMin, vMax;
-		vCenter = b->owner->origin;
-
-		qglColor3fv(vColor);
-		qglPointSize(4);
-
-		qglBegin(GL_POINTS);
-		qglVertex3fv(b->owner->origin);
-		qglEnd();
-
-		qglBegin(GL_LINES);
-		vCenter[0] -= 8;
-		qglVertex3fv(vCenter);
-		vCenter[0] += 16;
-		qglVertex3fv(vCenter);
-		vCenter[0] -= 8;
-		vCenter[1] -= 8;
-		qglVertex3fv(vCenter);
-		vCenter[1] += 16;
-		qglVertex3fv(vCenter);
-		vCenter[1] -= 8;
-		vCenter[2] -= 8;
-		qglVertex3fv(vCenter);
-		vCenter[2] += 16;
-		qglVertex3fv(vCenter);
-		vCenter[2] -= 8;
-		qglEnd();
-
-		vMin = vCenter;
-		vMax = vCenter;
-
-		vMin[0] -= 4;
-		vMin[1] -= 4;
-		vMin[2] -= 4;
-		vMax[0] += 4;
-		vMax[1] += 4;
-		vMax[2] += 4;
-
-		qglBegin(GL_LINE_LOOP);
-		qglVertex3f(vMin[0],vMin[1],vMin[2]);
-		qglVertex3f(vMax[0],vMin[1],vMin[2]);
-		qglVertex3f(vMax[0],vMax[1],vMin[2]);
-		qglVertex3f(vMin[0],vMax[1],vMin[2]);
-		qglEnd();
-
-		qglBegin(GL_LINE_LOOP);
-		qglVertex3f(vMin[0],vMin[1],vMax[2]);
-		qglVertex3f(vMax[0],vMin[1],vMax[2]);
-		qglVertex3f(vMax[0],vMax[1],vMax[2]);
-		qglVertex3f(vMin[0],vMax[1],vMax[2]);
-		qglEnd();
-
-		qglBegin(GL_LINES);
-		qglVertex3f(vMin[0],vMin[1],vMin[2]);
-		qglVertex3f(vMin[0],vMin[1],vMax[2]);
-		qglVertex3f(vMin[0],vMax[1],vMax[2]);
-		qglVertex3f(vMin[0],vMax[1],vMin[2]);
-		qglVertex3f(vMax[0],vMin[1],vMin[2]);
-		qglVertex3f(vMax[0],vMin[1],vMax[2]);
-		qglVertex3f(vMax[0],vMax[1],vMax[2]);
-		qglVertex3f(vMax[0],vMax[1],vMin[2]);
-		qglEnd();
-
-
-		if (g_PrefsDlg.m_nEntityShowState & ENTITY_BOXED)
-		{
-			qglColor3fv(pEclass->color);
-
-			edVec3_c mins = b->getMins();
-			edVec3_c maxs = b->getMaxs();
-			/*
-			if (a)
-			{
-			vec3_t vAngle;
-			vAngle[0] = vAngle[1] = 0;
-			vAngle[2] = a;
-			VectorRotate(mins, vAngle, b->owner->origin, mins);
-			VectorRotate(maxs, vAngle, b->owner->origin, maxs);
-			}
-			*/
-			qglBegin(GL_LINE_LOOP);
-			qglVertex3f(mins[0],mins[1],mins[2]);
-			qglVertex3f(maxs[0],mins[1],mins[2]);
-			qglVertex3f(maxs[0],maxs[1],mins[2]);
-			qglVertex3f(mins[0],maxs[1],mins[2]);
-			qglEnd();
-
-			qglBegin(GL_LINE_LOOP);
-			qglVertex3f(mins[0],mins[1],maxs[2]);
-			qglVertex3f(maxs[0],mins[1],maxs[2]);
-			qglVertex3f(maxs[0],maxs[1],maxs[2]);
-			qglVertex3f(mins[0],maxs[1],maxs[2]);
-			qglEnd();
-
-			qglBegin(GL_LINES);
-			qglVertex3f(mins[0],mins[1],mins[2]);
-			qglVertex3f(mins[0],mins[1],maxs[2]);
-			qglVertex3f(mins[0],maxs[1],maxs[2]);
-			qglVertex3f(mins[0],maxs[1],mins[2]);
-			qglVertex3f(maxs[0],mins[1],mins[2]);
-			qglVertex3f(maxs[0],mins[1],maxs[2]);
-			qglVertex3f(maxs[0],maxs[1],maxs[2]);
-			qglVertex3f(maxs[0],maxs[1],mins[2]);
-			qglEnd();
-		}
-		qglPopAttrib();
-		bReturn = true;
-	}
-	else
-	{
-		b->bModelFailed = true;
-	}
-
-	g_bInPaintedModel = false;
-	return bReturn;
-}
-/*
-//++timo moved out to mahlib.h
-//++timo remove
-void AngleVectors (vec3_t angles, vec3_t forward, vec3_t right, vec3_t up)
-{
-	float		angle;
-	static float		sr, sp, sy, cr, cp, cy;
-	// static to help MS compiler fp bugs
-
-	angle = angles[YAW] * Q_PI / 180;
-	sy = sin(angle);
-	cy = cos(angle);
-	angle = angles[PITCH] * Q_PI / 180;
-	sp = sin(angle);
-	cp = cos(angle);
-	angle = angles[ROLL] * Q_PI / 180;
-	sr = sin(angle);
-	cr = cos(angle);
-
-	if (forward)
-	{
-		forward[0] = cp*cy;
-		forward[1] = cp*sy;
-		forward[2] = -sp;
-	}
-	if (right)
-	{
-		right[0] = (-1*sr*sp*cy+-1*cr*-sy);
-		right[1] = (-1*sr*sp*sy+-1*cr*cy);
-		right[2] = -1*sr*cp;
-	}
-	if (up)
-	{
-		up[0] = (cr*sp*cy+-sr*-sy);
-		up[1] = (cr*sp*sy+-sr*cy);
-		up[2] = cr*cp;
-	}
-}
-*/
-void FacingVectors (entity_t *e, vec3_t forward, vec3_t right, vec3_t up)
-{
 	int			angleVal;
 	edVec3_c		angles;
 
@@ -3601,7 +3086,7 @@
 	angles.makeAngleVectors(forward, right, up);
 }
 
-void Brush_DrawFacingAngle (brush_t *b, entity_t *e)
+void Brush_DrawFacingAngle (brush_s *b, entity_s *e)
 {
 	vec3_t	forward, right, up;
 	edVec3_c	endpoint, tip1, tip2;
@@ -3632,7 +3117,7 @@
 	qglLineWidth (1);
 }
 
-void DrawLight(brush_t *b)
+void DrawLight(brush_s *b)
 {
 	edVec3_c vTriColor;
 	bool bTriPaint = false;
@@ -3750,9 +3235,9 @@
 
 }
 
-void Brush_Draw( brush_t *b )
+void Brush_Draw( brush_s *b )
 {
-	face_t			*face;
+	face_s			*face;
 	int				i, order;
 	qtexture_t		*prev = 0;
 	winding_t *w;
@@ -3765,9 +3250,7 @@
 
 	if (b->patchBrush)
 	{
-		//Patch_DrawCam(b->nPatchID);
-		Patch_DrawCam(b->pPatch);
-		//if (!g_bPatchShowBounds)
+		b->pPatch->drawPatchCam();
 		return;
 	}
 	
@@ -3790,13 +3273,13 @@
 			qglDisable (GL_TEXTURE_2D);
 		
 		// if we are wireframing models
-		bool bp = (b->bModelFailed) ? false : PaintedModel(b, true);
+		//bool bp = (b->bModelFailed) ? false : PaintedModel(b, true);
 		
 		if (nDrawMode == cd_texture || nDrawMode == cd_light)
 			qglEnable (GL_TEXTURE_2D);
-		
-		if (bp)
-			return;
+		//
+		//if (bp)
+		//	return;
 	}
 	
 	// guarantee the texture will be set first
@@ -3865,14 +3348,6 @@
 		
 		// draw the polygon
 		
-		//if (nDrawMode == cd_light)
-		//{
-		if (g_PrefsDlg.m_bGLLighting)
-		{
-			qglNormal3fv(face->plane.normal);
-		}
-		//}
-		
 		qglBegin(GL_POLYGON);
 		//if (nDrawMode == cd_light)
 		
@@ -3903,7 +3378,7 @@
 
 
 
-void Face_Draw( face_t *f )
+void Face_Draw( face_s *f )
 {
 	int i;
 
@@ -3915,9 +3390,9 @@
 	qglEnd();
 }
 
-void Brush_DrawXY(brush_t *b, int nViewType)
+void Brush_DrawXY(brush_s *b, int nViewType)
 {
-	face_t *face;
+	face_s *face;
 	int     order;
 	winding_t *w;
 	int        i;
@@ -3929,8 +3404,7 @@
 
 	if (b->patchBrush)
 	{
-		//Patch_DrawXY(b->nPatchID);
-		Patch_DrawXY(b->pPatch);
+		b->pPatch->drawPatchXY();
 		if (!g_bPatchShowBounds)
 			return;
 	}
@@ -3990,8 +3464,8 @@
 		}
 		else if (b->owner->eclass->nShowFlags & ECLASS_MISCMODEL)
 		{
-			if (PaintedModel(b, false))
-			return;
+			//if (PaintedModel(b, false))
+			//return;
 		}
 	}
 
@@ -4043,10 +3517,10 @@
 Brush_Move
 ============
 */
-void Brush_Move (brush_t *b, const vec3_t move, bool bSnap)
+void Brush_Move (brush_s *b, const vec3_t move, bool bSnap)
 {
 	int i;
-	face_t *f;
+	face_s *f;
 	if(b == 0)
 		return;
 
@@ -4065,8 +3539,7 @@
 
 	if (b->patchBrush)
 	{
-		//Patch_Move(b->nPatchID, move);
-		Patch_Move(b->pPatch, move);
+		b->pPatch->movePatch(move);
 	}
 
 	// PGM - keep the origin vector up to date on fixed size entities.
@@ -4080,10 +3553,10 @@
 
 
 
-void Brush_Print(brush_t* b)
+void Brush_Print(brush_s* b)
 {
 	int nFace = 0;
-	for (face_t* f = b->brush_faces ; f ; f=f->next)
+	for (face_s* f = b->brush_faces ; f ; f=f->next)
 	{
 		Sys_Printf("Face %i\n", nFace++);
 		Sys_Printf("%f %f %f\n", f->planepts[0][0], f->planepts[0][1], f->planepts[0][2]);
@@ -4105,9 +3578,9 @@
 {
 	int		i;
 	edVec3_c	mins, maxs;
-	brush_t	*b;
+	brush_s	*b;
 	texdef_t	*texdef;
-	face_t	*f;
+	face_s	*f;
 	vec3_t	mid;
 	float	width;
 	float	sv, cv;
@@ -4199,9 +3672,9 @@
 {
 	int		i,j;
 	edVec3_c	mins, maxs;
-	brush_t	*b;
+	brush_s	*b;
 	texdef_t	*texdef;
-	face_t	*f;
+	face_s	*f;
 	vec3_t	mid;
 
 	if (sides < 4)
@@ -4286,7 +3759,7 @@
 	Sys_UpdateWindows (W_ALL);
 }
 
-void Face_FitTexture( face_t * face, int nHeight, int nWidth )
+void Face_FitTexture( face_s * face, int nHeight, int nWidth )
 {
 	winding_t *w;
 	edAABB_c bounds;
@@ -4396,9 +3869,9 @@
 	td->shift[1] = (int)(temp - td->shift[1])%(face->d_texture->height*nHeight);
 }
 
-void Brush_FitTexture( brush_t *b, int nHeight, int nWidth )
+void Brush_FitTexture( brush_s *b, int nHeight, int nWidth )
 {
-	face_t *face;
+	face_s *face;
 
 	for (face = b->brush_faces ; face ; face=face->next)
 	{
Index: q3radiant/BRUSH.H
===================================================================
--- q3radiant/BRUSH.H	(revision 443)
+++ q3radiant/BRUSH.H	(working copy)
@@ -22,103 +22,49 @@
 
 // brush.h
 
-// all types moved to qertypes.h
-//--typedef struct
-//--{
-//--	int		numpoints;
-//--	int		maxpoints;
-//--	float 	points[8][5];			// variable sized
-//--} winding_t;
-
-
-// the normals on planes point OUT of the brush
-//--#define	MAXPOINTS	16
-//--typedef struct face_s
-//--{
-//--	struct face_s	*next;
-//--	vec3_t		planepts[3];
-//--  texdef_t	texdef;
-//--  plane_t		plane;
-//--
-//--	winding_t  *face_winding;
-//--
-//--	vec3_t		d_color;
-//--	qtexture_t *d_texture;
-//--
-//--} face_t;
-//--
-//--typedef struct {
-//--	vec3_t	xyz;
-//--	float	sideST[2];
-//--	float	capST[2];
-//--} curveVertex_t;
-//--
-//--typedef struct {
-//--	curveVertex_t	v[2];
-//--} sideVertex_t;
-//--
-//--typedef struct brush_s
-//--{
-//--	struct brush_s	*prev, *next;	// links in active/selected
-//--	struct brush_s	*oprev, *onext;	// links in entity
-//--	struct entity_s	*owner;
-//--	vec3_t	mins, maxs;
-//--	face_t     *brush_faces;
-//--
-//--	bool bModelFailed;
-//--	//
-//--	// curve brush extensions
-//--	// all are derived from brush_faces
-//--	bool	curveBrush;
-//--	bool	patchBrush;
-//--    int nPatchID;
-//--} brush_t;
-
-void		Brush_AddToList (brush_t *b, brush_t *list);
-void		Brush_Build(brush_t *b, bool bSnap = true, bool bMarkMap = true, bool bConvert = false);
-void		Brush_BuildWindings( brush_t *b, bool bSnap = true );
-brush_t*	Brush_Clone (brush_t *b);
-brush_t*	Brush_FullClone(brush_t *b);
-brush_t*	Brush_Create (vec3_t mins, vec3_t maxs, texdef_t *texdef);
-void		Brush_Draw( brush_t *b );
-void		Brush_DrawXY(brush_t *b, int nViewType);
+void		Brush_AddToList (brush_s *b, brush_s *list);
+void		Brush_Build(brush_s *b, bool bSnap = true, bool bMarkMap = true, bool bConvert = false);
+void		Brush_BuildWindings( brush_s *b, bool bSnap = true );
+brush_s*	Brush_Clone (brush_s *b);
+brush_s*	Brush_FullClone(brush_s *b);
+brush_s*	Brush_Create (vec3_t mins, vec3_t maxs, texdef_t *texdef);
+void		Brush_Draw( brush_s *b );
+void		Brush_DrawXY(brush_s *b, int nViewType);
 // set bRemoveNode to false to avoid trying to delete the item in group view tree control
-void		Brush_Free (brush_t *b, bool bRemoveNode = true);
-int			Brush_MemorySize(brush_t *b);
+void		Brush_Free (brush_s *b, bool bRemoveNode = true);
+int			Brush_MemorySize(brush_s *b);
 void		Brush_MakeSided (int sides);
 void		Brush_MakeSidedCone (int sides);
-void		Brush_Move (brush_t *b, const vec3_t move, bool bSnap = true);
-int			Brush_MoveVertex(brush_t *b, const edVec3_c &vertex, const edVec3_c &delta, edVec3_c &end, bool bSnap = true);
-void		Brush_ResetFaceOriginals(brush_t *b);
-brush_t*	Brush_Parse (void);
-face_t*		Brush_Ray (const edVec3_c &origin, const edVec3_c &dir, brush_t *b, float *dist);
-void		Brush_RemoveFromList (brush_t *b);
-void		Brush_SplitBrushByFace (brush_t *in, face_t *f, brush_t **front, brush_t **back);
-void		Brush_SelectFaceForDragging (brush_t *b, face_t *f, bool shear);
-void		Brush_SetTexture (brush_t *b, texdef_t *texdef, brushprimit_texdef_t *brushprimit_texdef, bool bFitScale = false, IPluginTexdef* pPlugTexdef=NULL );
-void		Brush_SideSelect (brush_t *b, vec3_t origin, vec3_t dir, bool shear);
-void		Brush_SnapToGrid(brush_t *pb);
-void		Brush_Rotate(brush_t *b, vec3_t vAngle, vec3_t vOrigin, bool bBuild = true);
+void		Brush_Move (brush_s *b, const vec3_t move, bool bSnap = true);
+int			Brush_MoveVertex(brush_s *b, const edVec3_c &vertex, const edVec3_c &delta, edVec3_c &end, bool bSnap = true);
+void		Brush_ResetFaceOriginals(brush_s *b);
+brush_s*	Brush_Parse (void);
+face_s*		Brush_Ray (const edVec3_c &origin, const edVec3_c &dir, brush_s *b, float *dist);
+void		Brush_RemoveFromList (brush_s *b);
+void		Brush_SplitBrushByFace (brush_s *in, face_s *f, brush_s **front, brush_s **back);
+void		Brush_SelectFaceForDragging (brush_s *b, face_s *f, bool shear);
+void		Brush_SetTexture (brush_s *b, texdef_t *texdef, brushprimit_texdef_s *brushprimit_texdef, bool bFitScale = false, IPluginTexdef* pPlugTexdef=NULL );
+void		Brush_SideSelect (brush_s *b, vec3_t origin, vec3_t dir, bool shear);
+void		Brush_SnapToGrid(brush_s *pb);
+void		Brush_Rotate(brush_s *b, vec3_t vAngle, vec3_t vOrigin, bool bBuild = true);
 void		Brush_MakeSidedSphere(int sides);
-void		Brush_Write (brush_t *b, FILE *f);
-void		Brush_Write (brush_t *b, CMemFile* pMemFile);
-void		Brush_RemoveEmptyFaces ( brush_t *b );
-winding_t*	Brush_MakeFaceWinding (brush_t *b, face_t *face);
+void		Brush_Write (brush_s *b, FILE *f);
+void		Brush_Write (brush_s *b, CMemFile* pMemFile);
+void		Brush_RemoveEmptyFaces ( brush_s *b );
+winding_t*	Brush_MakeFaceWinding (brush_s *b, face_s *face);
 
 int			AddPlanept (float *f);
 float		SetShadeForPlane (const class edPlane_c &p);
 
-face_t*		Face_Alloc( void );
-void		Face_Free( face_t *f );
-face_t*		Face_Clone (face_t *f);
-void		Face_MakePlane (face_t *f);
-void		Face_Draw( face_t *face );
-void		Face_TextureVectors (face_t *f, float STfromXYZ[2][4]);
-void		SetFaceTexdef (brush_t *b, face_t *f, texdef_t *texdef, brushprimit_texdef_t *brushprimit_texdef, bool bFitScale = false, IPluginTexdef* pPlugTexdef = NULL );
+face_s*		Face_Alloc( void );
+void		Face_Free( face_s *f );
+face_s*		Face_Clone (face_s *f);
+void		Face_MakePlane (face_s *f);
+void		Face_Draw( face_s *face );
+void		Face_TextureVectors (face_s *f, float STfromXYZ[2][4]);
+void		SetFaceTexdef (brush_s *b, face_s *f, texdef_t *texdef, brushprimit_texdef_s *brushprimit_texdef, bool bFitScale = false, IPluginTexdef* pPlugTexdef = NULL );
 
-void Face_FitTexture( face_t * face, int nHeight, int nWidth );
-void Brush_FitTexture( brush_t *b, int nHeight, int nWidth );
-void Brush_SetEpair(brush_t *b, const char *pKey, const char *pValue);
-const char* Brush_GetKeyValue(brush_t *b, const char *pKey);
-brush_t *Brush_Alloc();
-const char* Brush_Name(brush_t *b);
+void Face_FitTexture( face_s * face, int nHeight, int nWidth );
+void Brush_FitTexture( brush_s *b, int nHeight, int nWidth );
+const char* Brush_GetKeyValue(brush_s *b, const char *pKey);
+brush_s *Brush_Alloc();
\ No newline at end of file
Index: q3radiant/brush_primit.cpp
===================================================================
--- q3radiant/brush_primit.cpp	(revision 443)
+++ q3radiant/brush_primit.cpp	(working copy)
@@ -57,7 +57,7 @@
 	texT[2]=-cos(RotY);
 }
 
-void FaceToBrushPrimitFace(face_t *f)
+void FaceToBrushPrimitFace(face_s *f)
 {
 	edVec3_c texX,texY;
 	edVec3_c proj;
@@ -106,7 +106,7 @@
 }
 
 // compute texture coordinates for the winding points
-void EmitBrushPrimitTextureCoordinates(face_t * f, winding_t * w)
+void EmitBrushPrimitTextureCoordinates(face_s * f, winding_t * w)
 {
 	edVec3_c texX,texY;
 	vec_t x,y;
@@ -146,10 +146,9 @@
 }
 
 // parse a brush in brush primitive format
-void BrushPrimit_Parse(brush_t	*b)
+void BrushPrimit_Parse(brush_s	*b)
 {
-	epair_t		*ep;
-	face_t		*f;
+	face_s		*f;
 	int			i,j;
 	GetToken (true);
 	if (strcmp (token, "{"))
@@ -163,14 +162,14 @@
 			break;
 		if (!strcmp (token, "}") )
 			break;
-		// reading of b->epairs if any
-		if (strcmp (token, "(") )
-		{
-			ep = ParseEpair();
-			ep->next = b->epairs;
-			b->epairs = ep;
-		}
-		else
+		//// reading of b->epairs if any
+		//if (strcmp (token, "(") )
+		//{
+		//	ep = ParseEpair();
+		//	ep->next = b->epairs;
+		//	b->epairs = ep;
+		//}
+		//else
 		// it's a face
 		{
 			f = Face_Alloc();
@@ -179,7 +178,7 @@
 			  	b->brush_faces = f;
 		  	else
 			{
-				face_t *scan;
+				face_s *scan;
 				for (scan=b->brush_faces ; scan->next ; scan=scan->next)
 					;
 				scan->next = f;
@@ -320,7 +319,7 @@
 
 // convert a texture matrix between two qtexture_t
 // if NULL for qtexture_t, basic 2x2 texture is assumed ( straight mapping between s/t coordinates and geometric coordinates )
-void ConvertTexMatWithQTexture( brushprimit_texdef_t *texMat1, qtexture_t *qtex1, brushprimit_texdef_t *texMat2, qtexture_t *qtex2 )
+void ConvertTexMatWithQTexture( brushprimit_texdef_s *texMat1, qtexture_t *qtex1, brushprimit_texdef_s *texMat2, qtexture_t *qtex2 )
 {
 	float s1,s2;
 	s1 = ( qtex1 ? static_cast<float>( qtex1->width ) : 2.0f ) / ( qtex2 ? static_cast<float>( qtex2->width ) : 2.0f );
@@ -334,7 +333,7 @@
 }
 
 // texture locking
-void Face_MoveTexture_BrushPrimit(face_t *f, const edVec3_c &delta)
+void Face_MoveTexture_BrushPrimit(face_s *f, const edVec3_c &delta)
 {
 	edVec3_c texS,texT;
 	vec_t tx,ty;
@@ -367,7 +366,7 @@
 }
 
 // call Face_MoveTexture_BrushPrimit after vec3_t computation
-void Select_ShiftTexture_BrushPrimit( face_t *f, int x, int y )
+void Select_ShiftTexture_BrushPrimit( face_s *f, int x, int y )
 {
 	edVec3_c texS,texT;
 	edVec3_c delta;
@@ -380,7 +379,7 @@
 
 // texture locking
 // called before the points on the face are actually rotated
-void RotateFaceTexture_BrushPrimit(face_t *f, int nAxis, float fDeg, vec3_t vOrigin )
+void RotateFaceTexture_BrushPrimit(face_s *f, int nAxis, float fDeg, vec3_t vOrigin )
 {
 	edVec3_c texS,texT;			// axis base of the initial plane
 	edVec3_c vRotate;				// rotation vector
Index: q3radiant/CamWnd.cpp
===================================================================
--- q3radiant/CamWnd.cpp	(revision 459)
+++ q3radiant/CamWnd.cpp	(working copy)
@@ -148,7 +148,7 @@
 }
 
 
-brush_t* g_pSplitList = NULL;
+brush_s* g_pSplitList = NULL;
 
 void CCamWnd::OnPaint() 
 {
@@ -386,7 +386,7 @@
 
 void CCamWnd::Cam_ChangeFloor (bool up)
 {
-	brush_t	*b;
+	brush_s	*b;
 	float	d, bestd, current;
 	vec3_t	start, dir;
 
@@ -625,7 +625,7 @@
 	}
 }
 
-bool CCamWnd::CullBrush (brush_t *b)
+bool CCamWnd::CullBrush (brush_s *b)
 {
 	int		i;
 	edVec3_c	point;
@@ -671,7 +671,7 @@
 }
 
 #if 0
-void CCamWnd::DrawLightRadius(brush_t* pBrush)
+void CCamWnd::DrawLightRadius(brush_s* pBrush)
 {
   // if lighting
   int nRadius = Brush_LightRadius(pBrush);
@@ -698,8 +698,8 @@
 
 void CCamWnd::Cam_Draw()
 {
-	brush_t	*brush;
-	face_t	*face;
+	brush_s	*brush;
+	face_s	*face;
 	float	screenaspect;
 	float	yfov;
 	double	start, end;
@@ -738,25 +738,8 @@
 	//
 	// set up viewpoint
 	//
-	vec5_t lightPos;
+	qglDisable(GL_LIGHTING);
 	
-	if (g_PrefsDlg.m_bGLLighting)
-	{
-		qglEnable(GL_LIGHTING);
-		//qglEnable(GL_LIGHT0);
-		
-		lightPos[0] = lightPos[1] = lightPos[2] = 3.5;
-		lightPos[3] = 1.0;
-		qglLightModelfv(GL_LIGHT_MODEL_AMBIENT, lightPos);
-		//qglLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE);
-		//lightPos[0] = lightPos[1] = lightPos[2] = 3.5;
-    //qglLightfv(GL_LIGHT0, GL_AMBIENT, lightPos);
-	}
-	else
-	{
-		qglDisable(GL_LIGHTING);
-	}
-	
 	qglMatrixMode(GL_PROJECTION);
 	qglLoadIdentity ();
 	
@@ -772,17 +755,6 @@
 	
 	Cam_BuildMatrix ();
 	
-	
-	//if (m_Camera.draw_mode == cd_light)
-	//{
-//	if (g_PrefsDlg.m_bGLLighting)
-//	{
-//		VectorCopy(m_Camera.origin, lightPos);
-//		lightPos[3] = 1;
-//		qglLightfv(GL_LIGHT0, GL_POSITION, lightPos);
-//	}
-	//}
-	
 	InitCull ();
 	
 	//
@@ -867,15 +839,8 @@
 			//--      else
 			Brush_Draw(brush);
 		}
-		
-		
 	}
-	
-	if (g_PrefsDlg.m_bGLLighting)
-	{
-		qglDisable (GL_LIGHTING);
-	}
-	
+
 	//
 	//qglDepthMask ( 0 ); // Don't write to depth buffer
 	qglEnable ( GL_BLEND );
@@ -891,15 +856,10 @@
 	// now draw selected brushes
 	//
 	
-	if (g_PrefsDlg.m_bGLLighting)
-	{
-		qglEnable (GL_LIGHTING);
-	}
-	
 	qglTranslatef (g_qeglobals.d_select_translate[0], g_qeglobals.d_select_translate[1], g_qeglobals.d_select_translate[2]);
 	qglMatrixMode(GL_TEXTURE);
 	
-	brush_t* pList = (g_bClipMode && g_pSplitList) ? g_pSplitList : &selected_brushes;
+	brush_s* pList = (g_bClipMode && g_pSplitList) ? g_pSplitList : &selected_brushes;
 	// draw normally
 	for (brush = pList->next ; brush != pList ; brush=brush->next)
 	{
@@ -935,7 +895,7 @@
   {
     for (int i = 0; i < nCount; i++)
     {
-      face_t *selFace = reinterpret_cast<face_t*>(g_ptrSelectedFaces.GetAt(i));
+      face_s *selFace = reinterpret_cast<face_s*>(g_ptrSelectedFaces.GetAt(i));
 		  Face_Draw(selFace);
     }
   }
@@ -1098,7 +1058,7 @@
 
 // Timo
 // brush primitive texture shifting, using camera view to select translations :
-void CCamWnd::ShiftTexture_BrushPrimit(face_t *f, int x, int y)
+void CCamWnd::ShiftTexture_BrushPrimit(face_s *f, int x, int y)
 {
 	edVec3_c texS,texT;
 	edVec3_c viewX,viewY;
Index: q3radiant/CamWnd.h
===================================================================
--- q3radiant/CamWnd.h	(revision 442)
+++ q3radiant/CamWnd.h	(working copy)
@@ -53,7 +53,7 @@
 
 // Implementation
 public:
-	void ShiftTexture_BrushPrimit(face_t *f, int x, int y);
+	void ShiftTexture_BrushPrimit(face_s *f, int x, int y);
 	void ReInitGL();
 	void BenchMark();
 	CXYWnd* m_pXYFriend;
@@ -71,11 +71,11 @@
   void Cam_MouseUp (int x, int y, int buttons);
   void Cam_MouseMoved (int x, int y, int buttons);
   void InitCull();
-  bool CullBrush (brush_t *b);
+  bool CullBrush (brush_s *b);
   void Cam_Draw();
 
 
-  brush_t* m_TransBrushes[MAX_MAP_BRUSHES];
+  brush_s* m_TransBrushes[MAX_MAP_BRUSHES];
   int m_nNumTransBrushes;
   camera_t m_Camera;
   int	m_nCambuttonstate;
@@ -82,7 +82,7 @@
   CPoint m_ptButton;
   CPoint m_ptCursor;
   CPoint m_ptLastCursor;
-  face_t* m_pSide_select;
+  face_s* m_pSide_select;
   edVec3_c m_vCull1;
   edVec3_c m_vCull2;
   int m_nCullv1[3];
Index: q3radiant/CSG.CPP
===================================================================
--- q3radiant/CSG.CPP	(revision 458)
+++ q3radiant/CSG.CPP	(working copy)
@@ -31,9 +31,9 @@
 =============
 */
 
-void Brush_Scale(brush_t* b)
+void Brush_Scale(brush_s* b)
 {
-  for (face_t* f = b->brush_faces ; f ; f=f->next)
+  for (face_s* f = b->brush_faces ; f ; f=f->next)
   {
 	  for (int i=0 ; i<3 ; i++)
     {
@@ -44,9 +44,9 @@
 
 void CSG_MakeHollow (void)
 {
-	brush_t		*b, *front, *back, *next;
-	face_t		*f;
-	face_t		split;
+	brush_s		*b, *front, *back, *next;
+	face_s		*f;
+	face_s		split;
 	edVec3_c		move;
 	int			i;
 
@@ -89,11 +89,11 @@
  be the same as well.
 =============
 */
-brush_t *Brush_Merge(brush_t *brush1, brush_t *brush2, int onlyshape)
+brush_s *Brush_Merge(brush_s *brush1, brush_s *brush2, int onlyshape)
 {
 	int i, shared;
-	brush_t *newbrush;
-	face_t *face1, *face2, *newface, *f;
+	brush_s *newbrush;
+	face_s *face1, *face2, *newface, *f;
 
 	// check for bounding box overlapp
 	for (i = 0; i < 3; i++)
@@ -231,11 +231,11 @@
   Input and output should be a single linked list using .next
 =============
 */
-brush_t *Brush_MergeListPairs(brush_t *brushlist, int onlyshape)
+brush_s *Brush_MergeListPairs(brush_s *brushlist, int onlyshape)
 {
 	int nummerges, merged;
-	brush_t *b1, *b2, *tail, *newbrush, *newbrushlist;
-	brush_t *lastb2;
+	brush_s *b1, *b2, *tail, *newbrush, *newbrushlist;
+	brush_s *lastb2;
 
 	if (!brushlist) return NULL;
 
@@ -302,10 +302,10 @@
  be the same as well.
 =============
 */
-brush_t *Brush_MergeList(brush_t *brushlist, int onlyshape)
+brush_s *Brush_MergeList(brush_s *brushlist, int onlyshape)
 {
-	brush_t *brush1, *brush2, *brush3, *newbrush;
-	face_t *face1, *face2, *face3, *newface, *f;
+	brush_s *brush1, *brush2, *brush3, *newbrush;
+	face_s *face1, *face2, *face3, *newface, *f;
 
 	if (!brushlist) return NULL;
 	for (brush1 = brushlist; brush1; brush1 = brush1->next)
@@ -421,12 +421,12 @@
  The originals are undisturbed.
 =============
 */
-brush_t *Brush_Subtract(brush_t *a, brush_t *b)
+brush_s *Brush_Subtract(brush_s *a, brush_s *b)
 {
 	// a - b = out (list)
-	brush_t *front, *back;
-	brush_t *in, *out, *next;
-	face_t *f;
+	brush_s *front, *back;
+	brush_s *in, *out, *next;
+	face_s *f;
 
 	in = a;
 	out = NULL;
@@ -466,8 +466,8 @@
 */
 void CSG_Subtract (void)
 {
-	brush_t		*b, *s, *fragments, *nextfragment, *frag, *next, *snext;
-	brush_t		fragmentlist;
+	brush_s		*b, *s, *fragments, *nextfragment, *frag, *next, *snext;
+	brush_s		fragmentlist;
 	int			i, numfragments, numbrushes;
 
 	Sys_Printf ("Subtracting...\n");
@@ -527,7 +527,7 @@
 			if (s->owner->eclass->fixedsize || s->patchBrush || s->terrainBrush || s->hiddenBrush)
 				continue;
 
-			//face_t *pFace = s->brush_faces;
+			//face_s *pFace = s->brush_faces;
 			if (s->brush_faces->d_texture->bFromShader && (s->brush_faces->d_texture->nShaderFlags & QER_NOCARVE))
 			{
 				continue;
@@ -591,7 +591,7 @@
 */
 void CSG_Merge(void)
 {
-	brush_t *b, *next, *newlist, *newbrush;
+	brush_s *b, *next, *newlist, *newbrush;
 	struct entity_s	*owner;
 
 	Sys_Printf ("Merging...\n");
Index: q3radiant/DRAG.CPP
===================================================================
--- q3radiant/DRAG.CPP	(revision 459)
+++ q3radiant/DRAG.CPP	(working copy)
@@ -39,47 +39,14 @@
 static	edVec3_c vPressStart;
 static	int	buttonx, buttony;
 
-
-//int		num_move_points;
-//float	*move_points[1024];
-
 int		lastx, lasty;
 
 bool	drag_first;
 
 
-void	AxializeVector (edVec3_c& v)
-{
-	vec3_t	a;
-	float	o;
-	int		i;
 
-	if (!v[0] && !v[1])
-		return;
-	if (!v[1] && !v[2])
-		return;
-	if (!v[0] && !v[2])
-		return;
 
-	for (i=0 ; i<3 ; i++)
-		a[i] = fabs(v[i]);
-	if (a[0] > a[1] && a[0] > a[2])
-		i = 0;
-	else if (a[1] > a[0] && a[1] > a[2])
-		i = 1;
-	else
-		i = 2;
 
-	o = v[i];
-	v.clear();
-	if (o<0)
-		v[i] = -1;
-	else
-		v[i] = 1;
-	
-}
-
-
 /*
 ===========
 Drag_Setup
@@ -90,7 +57,7 @@
 		   vec3_t origin, vec3_t dir)
 {
 	trace_t	t;
-	face_t	*f;
+	face_s	*f;
 
 	drag_first = true;
 	
@@ -99,9 +66,9 @@
 	pressy = y;
 
 	drag_xvec = xaxis;
-	AxializeVector (drag_xvec);
+	drag_xvec.axializeVector();
 	drag_yvec = yaxis;
-	AxializeVector (drag_yvec);
+	drag_yvec.axializeVector();
 
 
 
@@ -208,7 +175,7 @@
 		bool bOK = (g_PrefsDlg.m_bALTEdge) ? (static_cast<bool>(::GetAsyncKeyState(VK_MENU))) : true;
 		if (bOK)
 		{
-			for (brush_t* pBrush = selected_brushes.next ; pBrush != &selected_brushes ; pBrush = pBrush->next)
+			for (brush_s* pBrush = selected_brushes.next ; pBrush != &selected_brushes ; pBrush = pBrush->next)
 			{
 				if (buttons & MK_CONTROL)
 					Brush_SideSelect (pBrush, origin, dir, true);
@@ -238,12 +205,12 @@
 	Undo_AddBrushList(&selected_brushes);
 }
 
-entity_t *peLink;
+entity_s *peLink;
 
 void UpdateTarget(vec3_t origin, vec3_t dir)
 {
 	trace_t	t;
-	entity_t *pe;
+	entity_s *pe;
 	int i;
 	char sz[128];
 
@@ -357,7 +324,7 @@
 			g_qeglobals.d_new_brush_bottom_z = t.brush->getMins()[2];
 			g_qeglobals.d_new_brush_top_z = t.brush->getMaxs()[2];
 			// use a local brushprimit_texdef fitted to a default 2x2 texture
-			brushprimit_texdef_t bp_local;
+			brushprimit_texdef_s bp_local;
 			ConvertTexMatWithQTexture( &t.face->brushprimit_texdef, t.face->d_texture, &bp_local, NULL );
 			Texture_SetTexture ( &t.face->texdef, &bp_local, false);
 			UpdateSurfaceDialog();
@@ -476,7 +443,7 @@
 void MoveSelection (vec3_t move)
 {
 	int		i, success;
-	brush_t	*b;
+	brush_s	*b;
 	CString strStatus;
 	edVec3_c vTemp, vTemp2, end;
 
@@ -691,17 +658,16 @@
 	for (i=0 ; i<3 ; i++)
 	{
 		move[i] = drag_xvec[i]*(x - pressx)	+ drag_yvec[i]*(y - pressy);
-    if (!g_PrefsDlg.m_bNoClamp)
-    {
-		  move[i] = floor(move[i]/g_qeglobals.d_gridsize+0.5)*g_qeglobals.d_gridsize;
-    }
+		if (!g_PrefsDlg.m_bNoClamp)
+		{
+			  move[i] = floor(move[i]/g_qeglobals.d_gridsize+0.5)*g_qeglobals.d_gridsize;
+		}
 	}
 
 	delta = move - pressdelta;
 	pressdelta = move;
 
-  MoveSelection (delta);
-
+	MoveSelection (delta);
 }
 
 /*
@@ -715,9 +681,9 @@
 
 	if (g_qeglobals.d_select_mode == sel_area)
 	{
-			Patch_SelectAreaPoints();
-			g_qeglobals.d_select_mode = sel_curvepoint;
-			Sys_UpdateWindows (W_ALL);
+		Patch_SelectAreaPoints();
+		g_qeglobals.d_select_mode = sel_curvepoint;
+		Sys_UpdateWindows (W_ALL);
 	}
 	
 	if (g_qeglobals.d_select_translate[0] || g_qeglobals.d_select_translate[1] || g_qeglobals.d_select_translate[2])
Index: q3radiant/ECLASS.CPP
===================================================================
--- q3radiant/ECLASS.CPP	(revision 443)
+++ q3radiant/ECLASS.CPP	(working copy)
@@ -25,12 +25,12 @@
 #include "pakstuff.h"
 //#include "qertypes.h"
 
-eclass_t	*eclass = NULL;
-eclass_t	*eclass_bad = NULL;
+eclass_s	*eclass = NULL;
+eclass_s	*eclass_bad = NULL;
 char		eclass_directory[1024];
 
 // md3 cache for misc_models
-eclass_t *g_md3Cache = NULL;
+eclass_s *g_md3Cache = NULL;
 
 /*
 
@@ -46,18 +46,11 @@
 
 */
 
-void CleanEntityList(eclass_t *&pList)
+void CleanEntityList(eclass_s *&pList)
 {
   while (pList)
   {
-    eclass_t* pTemp = pList->next;
-
-    entitymodel *model = pList->model;
-    while (model != NULL)
-    {
-      delete []model->pTriList;
-      model = model->pNext;
-    }
+    eclass_s* pTemp = pList->next;
     
     if (pList->modelpath)
       free(pList->modelpath);
@@ -82,7 +75,7 @@
 /*
   while (eclass)
   {
-    eclass_t* pTemp = eclass->next;
+    eclass_s* pTemp = eclass->next;
     delete []eclass->pTriList;
     
     if (eclass->modelpath)
@@ -126,271 +119,8 @@
 }
 
 
-
-// FIXME: this code is a TOTAL clusterfuck
-//
-void LoadModel(const char *pLocation, eclass_t *e, edVec3_c &vMin, edVec3_c &vMax, entitymodel *&pModel, const char *pSkin)
+void setSpecialLoad(eclass_s *e, const char* pWhat, char*& p)
 {
-  // this assumes a path only and uses tris.md2
-  // for the model and skin.pcx for the skin
-  char cPath[1024];
-  char cSkin[1024];
-  char cFullLocation[1024];
-	//struct _finddata_t fileinfo;
-
-  vMin[0] = vMin[1] = vMin[2] = 99999;
-  vMax[0] = vMax[1] = vMax[2] = -99999;
-
-  bool bMD3 = false;
-  bool bASE = false;
-
-  strcpy( cFullLocation, pLocation );
-
-  if (strstr(pLocation, ".md3"))
-  {
-    bMD3 = true;
-  }
-  else if (strstr(pLocation, ".md2") != NULL)
-  {
-	  sprintf( cFullLocation, "%stris.md2", pLocation);
-  }
-  else if (strstr(pLocation, ".ase") != NULL)
-  {
-    bASE = true;
-  }
-
-  sprintf( cPath, "%s/%s", ValueForKey(g_qeglobals.d_project_entity, "basepath"), cFullLocation);
-
-  Sys_Printf("Loading model %s...", cPath);
-  unsigned char* p = NULL;
-  bool bOpen = (LoadFile(cPath, reinterpret_cast<void**>(&p)) > 0);
-  if (!bOpen)
-  {
-    Sys_Printf(" failed. Trying PAK file...");
-//    sprintf (cPath, "%stris.md2", pLocation);
-	  strcpy (cPath, cFullLocation);
-	  bOpen = (PakLoadAnyFile(cPath, reinterpret_cast<void**>(&p)) > 0);
-  }
-
-  if (bOpen)
-  {
-    Sys_Printf(" successful.\n");
-
-    if (bASE)
-    {
-/*
-      free(p);
-      CString strOut;
-      ::GetTempPath(1024, strOut.GetBuffer(1024));
-      strOut.ReleaseBuffer();
-      AddSlash(strOut);
-      strOut += "Temp.ase";
-      CopyFile(cPath, strOut, false);
-      CString strIn = strOut;
-      FindReplace(strOut, ".ase", ".md3");
-      strcpy(cPath, strIn);
-      strcpy(cSkin, strOut);
-      Q3Data_ProduceTempMD3(ValueForKey(g_qeglobals.d_project_entity, "basepath"), cPath, cSkin);
-      CString strModel = cPath;
-      if (LoadFile(strOut.GetBuffer(0), reinterpret_cast<void**>(&p)) == 0)
-      {
-        Sys_Printf(" Conversion from ASE failed.\n");
-        return;
-      }
-      bMD3 = true;
-*/
-    }
-
-    if (bMD3)
-    {
-	    md3Header_t header;
-	    md3Surface_t *pSurface;
-    	header = *(md3Header_t *)p;
-      if (pSkin != NULL)
-      {
-        strcpy(cSkin, pSkin);
-      }
-	    else
-      {
-		    cSkin[0] = '\0';
-      }
-      int n = header.numFrames;
-    	pSurface = (md3Surface_t *) (p + header.ofsSurfaces);
-    	for (int z = 0; z < header.numSurfaces; z++ )
-	    {
-        int nTris = pSurface->numTriangles;
-        
-        //unsigned char* pTris = reinterpret_cast<unsigned char*>(pSurface);
-        //pTris += pSurface->ofsTriangles;
-
-        if (nTris > 0)
-        {
-          int nStart = 0;
-          if (pModel->pTriList == NULL)
-          {
-		        pModel->nModelPosition = 0;
-            pModel->pTriList = new trimodel[nTris];
-            pModel->nTriCount = nTris;
-          }
-          else
-          {
-            // already have one so we need to reallocate
-            int nNewCount = pModel->nTriCount + nTris;
-            trimodel* pNewModels = new trimodel[nNewCount];
-            for (int i = 0; i < pModel->nTriCount; i++)
-            {
-              memcpy(&pNewModels[i], &pModel->pTriList[i], sizeof(trimodel));
-            }
-            nStart = pModel->nTriCount;
-            pModel->nTriCount = nNewCount;
-            //nTris = nNewCount;
-            delete [] pModel->pTriList;
-            pModel->pTriList = pNewModels;
-          }
-          
-          md3Triangle_t *pTris = reinterpret_cast<md3Triangle_t*>((reinterpret_cast<unsigned char*>(pSurface) + pSurface->ofsTriangles));
-          md3XyzNormal_t *pXyz = reinterpret_cast<md3XyzNormal_t*>((reinterpret_cast<unsigned char*>(pSurface) + pSurface->ofsXyzNormals));
-          if (e->nFrame < pSurface->numFrames)
-          {
-            pXyz += (e->nFrame * pSurface->numVerts);
-          }
-
-          md3St_t *pST = reinterpret_cast<md3St_t*>((reinterpret_cast<unsigned char*>(pSurface) + pSurface->ofsSt)); 
-
-          for (int i = 0; i < nTris; i++)
-          {
-            for (int k = 0; k < 3; k ++)
-            {
-              for (int j = 0; j < 3; j++)
-              {
-                //e->pTriList[i].v[k][j] = (f->verts[tri.index_xyz[k]].v[j] * f->scale[j] + f->translate[j]);
-                pModel->pTriList[nStart].v[k][j] = pXyz[pTris[i].indexes[k]].xyz[j] * MD3_XYZ_SCALE;
-              }
-		          pModel->pTriList[nStart].st[k][0] = pST[pTris[i].indexes[k]].st[0];
-		          pModel->pTriList[nStart].st[k][1] = pST[pTris[i].indexes[k]].st[1];
- 		          ExtendBounds (pModel->pTriList[nStart].v[k], vMin, vMax);
-		        }
-            nStart++;
-		      }
-
-        }
-
-        md3Shader_t *pShader = reinterpret_cast<md3Shader_t*>((reinterpret_cast<unsigned char*>(pSurface) + pSurface->ofsShaders)); 
-        sprintf (cPath, "%s/%s", ValueForKey(g_qeglobals.d_project_entity, "basepath"), pShader->name);
-        strlwr(cPath);
- 	      pModel->nTextureBind = Texture_LoadSkin(cPath, &pModel->nSkinWidth, &pModel->nSkinHeight);
-        if (pModel->nTextureBind == -1)
-        {
-          Sys_Printf("Model skin load failed on texture %s\n", cPath);
-        }
-		    pSurface = (md3Surface_t *) ((( char * ) pSurface) + pSurface->ofsEnd);
-        pModel->pNext = reinterpret_cast<entitymodel_t*>(qmalloc(sizeof(entitymodel_t)));
-        pModel = pModel->pNext;
-      }
-    }
-    else
-    {
-
-      dmdl_t model;
-      daliasframe_t *f;
-      unsigned char* pTris = p;
-      dstvert_t *pST = NULL;
-      int nTris = 0;
-
-      // grab model params
-      memcpy(&model, p, sizeof(dmdl_t));
-      f = (daliasframe_t*)(p + model.ofs_frames);
-      pTris += model.ofs_tris;
-      pST = reinterpret_cast<dstvert_t*>(p + model.ofs_st);
-      nTris = model.num_tris;
-
-	    if(pSkin)
-	    {
-		    strcpy (cSkin, pSkin);
-		    if ((cSkin[strlen(cSkin)-1] == '\\') || (cSkin[strlen(cSkin)-1] == '/'))
-			    strcat(cSkin, "skin.pcx\0");
-	    }
-	    else
-      {
-		    strcpy(cSkin, (char *)(p + model.ofs_skins));
-      }
-
-      sprintf (cPath, "%s/%s", ValueForKey(g_qeglobals.d_project_entity, "basepath"), cSkin);
-      strlwr(cPath);
-      pModel->nTextureBind = Texture_LoadSkin(cPath, &pModel->nSkinWidth, &pModel->nSkinHeight);
-      if (pModel->nTextureBind == -1)
-      {
-        Sys_Printf("Model skin load failed on texture %s\n", cPath);
-      }
-      int nStart = 0;
-      if (pModel->pTriList == NULL)
-      {
-		    pModel->nModelPosition = 0;
-        pModel->pTriList = new trimodel[nTris];
-        pModel->nTriCount = nTris;
-      }
-      else
-      {
-        // already have one so we need to reallocate
-        int nNewCount = pModel->nTriCount + nTris;
-        trimodel* pNewModels = new trimodel[nNewCount];
-        for (int i = 0; i < pModel->nTriCount; i++)
-        {
-          memcpy(&pNewModels[i], &pModel->pTriList[i], sizeof(trimodel));
-        }
-        nStart = pModel->nTriCount;
-        pModel->nTriCount = nNewCount;
-        nTris = nNewCount;
-        delete [] pModel->pTriList;
-        pModel->pTriList = pNewModels;
-      }
-      
-      for (int i = nStart; i < nTris; i++)
-      {
-        dtriangle_t tri;
-        memcpy(&tri, pTris, sizeof(dtriangle_t));
-        for (int k = 0; k < 3; k ++)
-        {
-          for (int j = 0; j < 3; j++)
-          {
-            pModel->pTriList[i].v[k][j] = (f->verts[tri.index_xyz[k]].v[j] * f->scale[j] + f->translate[j]);
-          }
-
-          pModel->pTriList[i].st[k][0] = pST[tri.index_st[k]].s / pModel->nSkinWidth;
-          pModel->pTriList[i].st[k][1] = pST[tri.index_st[k]].t / pModel->nSkinHeight;;
-          ExtendBounds (pModel->pTriList[i].v[k], vMin, vMax);
-		    }
-        pTris += sizeof(dtriangle_t);
-		  }
-    }
-    free(p);
-  }
-  else
-  {
-    Sys_Printf(" failed.\n");
-  }
-
-#if 0
-  if (pModel->pTriList != NULL && pModel->nTriCount > 0 && !bMD3)
-  {
-	  if(fabs(vMin[2]) < ((vMax[2]-vMin[2]) / 10.0))	// > 90% above 0 point.
-	    pModel->nModelPosition = 1;
-//	sprintf (cPath, "%s/%sskin.pcx", ValueForKey(g_qeglobals.d_project_entity, "basepath"), pLocation);
-    sprintf (cPath, "%s/%s", ValueForKey(g_qeglobals.d_project_entity, "basepath"), cSkin);
- 	  pModel->nTextureBind = Texture_LoadSkin(cPath, &pModel->nSkinWidth, &pModel->nSkinHeight);
-    if (pModel->nTextureBind == -1)
-    {
-//      sprintf (cPath, "%sskin.pcx", pLocation);
-		  strcpy (cPath, cSkin);
-      pModel->nTextureBind = Texture_LoadSkin(cPath, &pModel->nSkinWidth, &pModel->nSkinHeight);
-    }
-  }
-#endif
-
-}
-
-void setSpecialLoad(eclass_t *e, const char* pWhat, char*& p)
-{
   CString str = e->comments;
   int n = str.Find(pWhat);
   if (n >= 0)
@@ -415,16 +145,16 @@
 
 char	*debugname;
 
-eclass_t *Eclass_InitFromText (const char *text)
+eclass_s *Eclass_InitFromText (const char *text)
 {
 	const char	*t;
 	int		len;
 	int		r, i;
 	char	parms[256], *p;
-	eclass_t	*e;
+	eclass_s	*e;
 	char	color[128];
 
-	e = (eclass_t*)qmalloc(sizeof(*e));
+	e = (eclass_s*)qmalloc(sizeof(*e));
 	memset (e, 0, sizeof(*e));
 	
 	text += strlen("/*QUAKED ");
@@ -550,118 +280,18 @@
 
   return e;
 }
-void Eclass_InsertAlphabetized (eclass_t *e);
+void Eclass_InsertAlphabetized (eclass_s *e);
 void EClass_CreateNewFromText(const char *text) {
-	eclass_t *cl = Eclass_InitFromText(text);
+	eclass_s *cl = Eclass_InitFromText(text);
 	if(cl) {
 		Eclass_InsertAlphabetized(cl);
 	}
 }
-bool Eclass_hasModel(eclass_t *e, edVec3_c &vMin, edVec3_c &vMax)
-{
-	int i;
-  if (e->modelpath != NULL)
-  {
-    if (e->model == NULL)
-    {
-      e->model = reinterpret_cast<entitymodel_t*>(qmalloc(sizeof(entitymodel_t)));
-    }
-    char *pModelBuff = strdup(e->modelpath);
-    char *pSkinBuff = NULL;
-    if (e->skinpath)
-    {
-      pSkinBuff = strdup(e->skinpath);
-    }
 
-    CStringList Models;
-    CStringList Skins;
-    char* pToken = strtok(pModelBuff, ";\0");
-    while (pToken != NULL)
-    {
-      Models.AddTail(pToken);
-      pToken = strtok(NULL, ";\0");
-    }
 
-    if (pSkinBuff != NULL)
-    {
-      pToken = strtok(pSkinBuff, ";\0");
-      while (pToken != NULL)
-      {
-        Skins.AddTail(pToken);
-        pToken = strtok(NULL, ";\0");
-      }
-    }
-
-    entitymodel *model = e->model;
-    for ( i = 0; i < Models.GetCount(); i++)
-    {
-      char *pSkin = NULL;
-      if (i < Skins.GetCount())
-      {
-        pSkin = Skins.GetAt(Skins.FindIndex(i)).GetBuffer(0);
-      }
-      LoadModel(Models.GetAt(Models.FindIndex(i)), e, vMin, vMax, model, pSkin);
-      model->pNext = reinterpret_cast<entitymodel_t*>(qmalloc(sizeof(entitymodel_t)));
-      model = model->pNext;
-    }
-
-    // at this poitn vMin and vMax contain the min max of the model
-    // which needs to be centered at origin 0, 0, 0
-
-    vMin.vectorSnap();
-    vMax.vectorSnap();
-
-    if (vMax[0] - vMin[0] < 2)
-    {
-      vMin[0] -= 1;
-      vMax[0] += 1;
-    }
-
-    if (vMin[1] - vMax[1] < 2)
-    {
-      vMin[1] -= 1;
-      vMax[1] += 1;
-    }
-
-    if (vMax[2] - vMin[2] < 2)
-    {
-      vMax[2] -= 1;
-      vMax[2] += 1;
-    }
-
-    edVec3_c vTemp = (vMin + vMax) * 0.5f;
-    model = e->model;
-    while (model != NULL)
-    {
-      for (i = 0; i < model->nTriCount; i++)
-      {
-        for (int j = 0; j < 3; j++)
-        {
-          ;//VectorSubtract(model->pTriList[i].v[j], vTemp, model->pTriList[i].v[j]);
-        }
-      }
-      model = model->pNext;
-    }
-
-    free(pModelBuff);
-    free(e->modelpath);
-    e->modelpath = NULL;
-	  
-    if(e->skinpath)
-	  {
-		  free(e->skinpath);
-		  e->skinpath = NULL;
-      free(pSkinBuff);
-	  }
-
-  }
-  return (e->model != NULL && e->model->nTriCount > 0);
-}
-
-
-void EClass_InsertSortedList(eclass_t *&pList, eclass_t *e)
+void EClass_InsertSortedList(eclass_s *&pList, eclass_s *e)
 {
-	eclass_t	*s;
+	eclass_s	*s;
 	
 	if (!pList)
 	{
@@ -695,12 +325,12 @@
 Eclass_InsertAlphabetized
 =================
 */
-void Eclass_InsertAlphabetized (eclass_t *e)
+void Eclass_InsertAlphabetized (eclass_s *e)
 {
 #if 1
   EClass_InsertSortedList(eclass, e);
 #else
-	eclass_t	*s;
+	eclass_s	*s;
 	
 	if (!eclass)
 	{
@@ -739,7 +369,7 @@
 
 bool parsing_single = false;
 bool eclass_found;
-eclass_t *eclass_e;
+eclass_s *eclass_e;
 //#ifdef BUILD_LIST
 extern bool g_bBuildList;
 CString strDefFile;
@@ -748,7 +378,7 @@
 {
 	int		size;
 	char	*data;
-	eclass_t	*e;
+	eclass_s	*e;
 	int		i;
 	char    temp[1024];
 	
@@ -849,8 +479,8 @@
 	eclass_bad = Eclass_InitFromText ("/*QUAKED UNKNOWN_CLASS (0 0.5 0) ?");
 }
 
-eclass_t *Eclass_FindExisting (const char *name) {
-	eclass_t	*e;
+eclass_s *Eclass_FindExisting (const char *name) {
+	eclass_s	*e;
 	char		init[1024];
 
 	if (!name)
@@ -862,9 +492,9 @@
 
 	return 0;
 }
-eclass_t *Eclass_ForName (char *name, bool has_brushes)
+eclass_s *Eclass_ForName (char *name, bool has_brushes)
 {
-	eclass_t	*e;
+	eclass_s	*e;
 	char		init[1024];
 
 #ifdef _DEBUG
@@ -897,54 +527,3 @@
 	return e;
 }
 
-
-eclass_t* GetCachedModel(entity_t *pEntity, const char *pName, class edVec3_c &vMin, edVec3_c &vMax)
-{
-
-	eclass_t *e = NULL;
-  if (pName == NULL || strlen(pName) == 0)
-  {
-    return NULL;
-  }
-
-	for (e = g_md3Cache; e ; e = e->next)
-  {
-		if (!strcmp (pName, e->name))
-    {
-      pEntity->md3Class = e;
-      vMin = e->mins;
-      vMax = e->maxs;
-			return e;
-    }
-  }
-
-	e = (eclass_t*)qmalloc(sizeof(*e));
-	memset (e, 0, sizeof(*e));
-  e->name = strdup(pName);
-  e->modelpath = strdup(pName);
-  e->skinpath = strdup(pName);
-  char *p = strstr(e->skinpath, ".md3");
-  if (p != NULL)
-  {
-    p++;
-    strncpy(p, "tga", 3);
-  }
-  else
-  {
-    free(e->skinpath);
-    e->skinpath = NULL;
-  }
-
-  e->color[0] = e->color[2] = 0.85;
-
-  if (Eclass_hasModel(e, vMin, vMax))
-  {
-    EClass_InsertSortedList(g_md3Cache, e);
-    e->mins = vMin;
-    e->maxs = vMax;
-    pEntity->md3Class = e;
-    return e;
-  }
-
-  return NULL;
-}
Index: q3radiant/ENTITY.CPP
===================================================================
--- q3radiant/ENTITY.CPP	(revision 458)
+++ q3radiant/ENTITY.CPP	(working copy)
@@ -25,9 +25,9 @@
 //
 int g_entityId = 1;
 
-char *ValueForKey ( epair_t *&e, const char *key)
+char *ValueForKey ( epair_s *&e, const char *key)
 {
-  epair_t *ep;
+  epair_s *ep;
   for (ep=e ; ep ; ep=ep->next)
   {
 		if (!strcmp (ep->key, key) )
@@ -39,7 +39,7 @@
 }
 
 
-char *ValueForKey (entity_t *ent, const char *key)
+char *ValueForKey (entity_s *ent, const char *key)
 {
 	if(ent == 0)
 		return "";
@@ -46,7 +46,7 @@
   return ValueForKey(ent->epairs, key);
 }
 
-void TrackMD3Angles(entity_t *e, const char *key, const char *value)
+void TrackMD3Angles(entity_s *e, const char *key, const char *value)
 {
   if (strcmpi(key, "angle") != 0)
   {
@@ -69,9 +69,9 @@
   }
 }
 
-void 	SetKeyValue (epair_t *&e, const char *key, const char *value)
+void 	SetKeyValue (epair_s *&e, const char *key, const char *value)
 {
-	epair_t	*ep;
+	epair_s	*ep;
   for (ep=e ; ep ; ep=ep->next)
   {
 		if (!strcmp (ep->key, key) )
@@ -82,7 +82,7 @@
 			return;
 		}
   }
-	ep = (epair_t*)qmalloc (sizeof(*ep));
+	ep = (epair_s*)qmalloc (sizeof(*ep));
 	ep->next = e;
 	e = ep;
 	ep->key = (char*)qmalloc(strlen(key)+1);
@@ -93,7 +93,7 @@
 }
 
 
-void 	SetKeyValue (entity_t *ent, const char *key, const char *value)
+void 	SetKeyValue (entity_s *ent, const char *key, const char *value)
 {
 
 	if (ent == NULL)
@@ -108,9 +108,9 @@
 
 }
 
-void 	DeleteKey (epair_t *&e, const char *key)
+void 	DeleteKey (epair_s *&e, const char *key)
 {
-	epair_t	**ep, *next;
+	epair_s	**ep, *next;
 	
 	ep = &e;
 	while (*ep)
@@ -129,7 +129,7 @@
 }
 
 
-void 	DeleteKey (entity_t *ent, const char *key)
+void 	DeleteKey (entity_s *ent, const char *key)
 {
   DeleteKey(ent->epairs, key);
 }
@@ -137,7 +137,7 @@
 
 
 
-float	FloatForKey (entity_t *ent, const char *key)
+float	FloatForKey (entity_s *ent, const char *key)
 {
 	char	*k;
 	
@@ -145,7 +145,7 @@
 	return atof(k);
 }
 
-int IntForKey (entity_t *ent, const char *key)
+int IntForKey (entity_s *ent, const char *key)
 {
 	char	*k;
 	
@@ -153,7 +153,7 @@
 	return atoi(k);
 }
 
-void 	GetVectorForKey (entity_t *ent, const char *key, vec3_t vec)
+void 	GetVectorForKey (entity_s *ent, const char *key, vec3_t vec)
 {
 	char	*k;
 	
@@ -168,9 +168,9 @@
 Frees the entity epairs.
 ===============
 */
-void Entity_FreeEpairs(entity_t *e)
+void Entity_FreeEpairs(entity_s *e)
 {
-	epair_t	*ep, *next;
+	epair_s	*ep, *next;
 
 	for (ep = e->epairs; ep; ep = next)
 	{
@@ -187,7 +187,7 @@
 Entity_AddToList
 ===========
 */
-void Entity_AddToList(entity_t *e, entity_t *list)
+void Entity_AddToList(entity_s *e, entity_s *list)
 {
 	if (e->next || e->prev)
 		Error ("Entity_AddToList: allready linked");
@@ -202,7 +202,7 @@
 Entity_RemoveFromList
 ===========
 */
-void Entity_RemoveFromList (entity_t *e)
+void Entity_RemoveFromList (entity_s *e)
 {
 	if (!e->next || !e->prev)
 		Error ("Entity_RemoveFromList: not linked");
@@ -221,7 +221,7 @@
 The entity is removed from the global entities list.
 ===============
 */
-void Entity_Free (entity_t *e)
+void Entity_Free (entity_s *e)
 {
 	while (e->brushes.onext != &e->brushes)
 		Brush_Free (e->brushes.onext);
@@ -242,9 +242,9 @@
 Entity_MemorySize
 =================
 */
-int Entity_MemorySize(entity_t *e)
+int Entity_MemorySize(entity_s *e)
 {
-	epair_t	*ep;
+	epair_s	*ep;
 	int size = 0;
 
 	for (ep = e->epairs; ep; ep = ep->next)
@@ -262,11 +262,11 @@
 ParseEpair
 =================
 */
-epair_t *ParseEpair (void)
+epair_s *ParseEpair (void)
 {
-	epair_t	*e;
+	epair_s	*e;
 	
-	e = (epair_t*)qmalloc (sizeof(*e));
+	e = (epair_s*)qmalloc (sizeof(*e));
 	
 	e->key = (char*)qmalloc(strlen(token)+1);
 	strcpy (e->key, token);
@@ -287,13 +287,13 @@
 to the global list.  Used for parsing the project.
 ================
 */
-entity_t	*Entity_Parse (bool onlypairs, brush_t* pList)
+entity_s	*Entity_Parse (bool onlypairs, brush_s* pList)
 {
-	entity_t	*ent;
-	eclass_t	*e;
-	brush_t		*b;
+	entity_s	*ent;
+	eclass_s	*e;
+	brush_s		*b;
 	edVec3_c		mins, maxs;
-	epair_t		*ep;
+	epair_s		*ep;
 	bool	has_brushes;
 	
 	if (!GetToken (true))
@@ -302,7 +302,7 @@
 	if (strcmp (token, "{") )
 		Error ("ParseEntity: { not found");
 	
-	ent = (entity_t*)qmalloc (sizeof(*ent));
+	ent = (entity_s*)qmalloc (sizeof(*ent));
 	ent->entityId = g_entityId++;
 	ent->brushes.onext = ent->brushes.oprev = &ent->brushes;
 
@@ -384,12 +384,12 @@
 			{
 				edVec3_c vMin, vMax;
 				a = FloatForKey (ent, "angle");
-				if (GetCachedModel(ent, p, vMin, vMax))
-				{
-					// create a custom brush
-					mins = ent->md3Class->mins + ent->origin;
-					maxs = ent->md3Class->maxs + ent->origin;
-				}
+				//if (GetCachedModel(ent, p, vMin, vMax))
+				//{
+				//	// create a custom brush
+				//	mins = ent->md3Class->mins + ent->origin;
+				//	maxs = ent->md3Class->maxs + ent->origin;
+				//}
 			}
 		}
 		
@@ -432,22 +432,15 @@
 	return ent;
 }
 
-void VectorMidpoint(vec3_t va, vec3_t vb, vec3_t& out)
-{
-  for (int i = 0; i < 3; i++)
-    out[i] = va[i] + ((vb[i] - va[i]) / 2);
-}
-
-
 /*
 ============
 Entity_Write
 ============
 */
-void Entity_Write (entity_t *e, FILE *f, bool use_region)
+void Entity_Write (entity_s *e, FILE *f, bool use_region)
 {
-	epair_t		*ep;
-	brush_t		*b;
+	epair_s		*ep;
+	brush_s		*b;
 	edVec3_c		origin;
 	char		text[128];
 	int			count;
@@ -487,13 +480,13 @@
 	// brush position
 	else if (e->eclass->fixedsize)
 	{
-		if (e->eclass->nShowFlags & ECLASS_MISCMODEL && e->md3Class != NULL)
+		//if (e->eclass->nShowFlags & ECLASS_MISCMODEL && e->md3Class != NULL)
+		//{
+		//	origin = e->origin;
+		//	//VectorSubtract (e->brushes.onext->mins, e->md3Class->mins, origin);
+		//}
+		//else
 		{
-			origin = e->origin;
-			//VectorSubtract (e->brushes.onext->mins, e->md3Class->mins, origin);
-		}
-		else
-		{
 			origin = e->brushes.onext->getMins() - e->eclass->mins;
 		}
 		sprintf (text, "%i %i %i", (int)origin[0], (int)origin[1], (int)origin[2]);
@@ -522,9 +515,9 @@
 
 
 
-bool IsBrushSelected(brush_t* bSel)
+bool IsBrushSelected(brush_s* bSel)
 {
-	for (brush_t* b = selected_brushes.next ;b != NULL && b != &selected_brushes; b = b->next)
+	for (brush_s* b = selected_brushes.next ;b != NULL && b != &selected_brushes; b = b->next)
   {
     if (b == bSel)
       return true;
@@ -537,10 +530,10 @@
 //Entity_WriteSelected
 //============
 //
-void Entity_WriteSelected(entity_t *e, FILE *f)
+void Entity_WriteSelected(entity_s *e, FILE *f)
 {
-	epair_t		*ep;
-	brush_t		*b;
+	epair_s		*ep;
+	brush_s		*b;
 	edVec3_c		origin;
 	char		text[128];
 	int			count;
@@ -556,13 +549,13 @@
 	// brush position
 	if (e->eclass->fixedsize)
 	{
-    if (e->eclass->nShowFlags & ECLASS_MISCMODEL && e->md3Class != NULL)
+    //if (e->eclass->nShowFlags & ECLASS_MISCMODEL && e->md3Class != NULL)
+    //{
+    //  origin = e->origin;
+		  ////VectorSubtract (e->brushes.onext->mins, e->md3Class->mins, origin);
+    //}
+    //else
     {
-      origin = e->origin;
-		  //VectorSubtract (e->brushes.onext->mins, e->md3Class->mins, origin);
-    }
-    else
-    {
 		  origin = e->brushes.onext->getMins() - e->eclass->mins;
     }
     sprintf (text, "%i %i %i", (int)origin[0], (int)origin[1], (int)origin[2]);
@@ -595,10 +588,10 @@
 //Entity_WriteSelected to a CMemFile
 //============
 //
-void Entity_WriteSelected(entity_t *e, CMemFile* pMemFile)
+void Entity_WriteSelected(entity_s *e, CMemFile* pMemFile)
 {
-	epair_t		*ep;
-	brush_t		*b;
+	epair_s		*ep;
+	brush_s		*b;
 	edVec3_c		origin;
 	char		text[128];
 	int			count;
@@ -614,13 +607,13 @@
 	// brush position
 	if (e->eclass->fixedsize)
 	{
-    if (e->eclass->nShowFlags & ECLASS_MISCMODEL && e->md3Class != NULL)
+    //if (e->eclass->nShowFlags & ECLASS_MISCMODEL && e->md3Class != NULL)
+    //{
+		  ////VectorSubtract (e->brushes.onext->mins, e->md3Class->mins, origin);
+    //  origin = e->origin;
+    //}
+    //else
     {
-		  //VectorSubtract (e->brushes.onext->mins, e->md3Class->mins, origin);
-      origin = e->origin;
-    }
-    else
-    {
 		  origin =  e->brushes.onext->getMins() - e->eclass->mins;
     }
     sprintf (text, "%i %i %i", (int)origin[0], (int)origin[1], (int)origin[2]);
@@ -660,10 +653,10 @@
 their ownership transfered to the new entity.
 ============
 */
-entity_t	*Entity_Create (eclass_t *c)
+entity_s	*Entity_Create (eclass_s *c)
 {
-	entity_t	*e;
-	brush_t		*b;
+	entity_s	*e;
+	brush_s		*b;
 	edVec3_c	mins, maxs;
 	int			i;
 
@@ -681,7 +674,7 @@
 
 	// create it
 
-	e = (entity_t*)qmalloc(sizeof(*e));
+	e = (entity_s*)qmalloc(sizeof(*e));
 	e->entityId = g_entityId++;
 	e->brushes.onext = e->brushes.oprev = &e->brushes;
 	e->eclass = c;
@@ -740,7 +733,7 @@
 Entity_LinkBrush
 ===========
 */
-void Entity_LinkBrush (entity_t *e, brush_t *b)
+void Entity_LinkBrush (entity_s *e, brush_s *b)
 {
 	if (b->oprev || b->onext)
 		Error ("Entity_LinkBrush: Allready linked");
@@ -757,7 +750,7 @@
 Entity_UnlinkBrush
 ===========
 */
-void Entity_UnlinkBrush (brush_t *b)
+void Entity_UnlinkBrush (brush_s *b)
 {
 	//if (!b->owner || !b->onext || !b->oprev)
 	if (!b->onext || !b->oprev)
@@ -774,12 +767,12 @@
 Entity_Clone
 ===========
 */
-entity_t	*Entity_Clone (entity_t *e)
+entity_s	*Entity_Clone (entity_s *e)
 {
-	entity_t	*n;
-	epair_t		*ep, *np;
+	entity_s	*n;
+	epair_s		*ep, *np;
 
-	n = (entity_t*)qmalloc(sizeof(*n));
+	n = (entity_s*)qmalloc(sizeof(*n));
 	n->entityId = g_entityId++;
 	n->brushes.onext = n->brushes.oprev = &n->brushes;
 	n->eclass = e->eclass;
@@ -789,7 +782,7 @@
 
 	for (ep = e->epairs ; ep ; ep=ep->next)
 	{
-		np = (epair_t*)qmalloc(sizeof(*np));
+		np = (epair_s*)qmalloc(sizeof(*np));
 		np->key = copystring(ep->key);
 		np->value = copystring(ep->value);
 		np->next = n->epairs;
@@ -802,7 +795,7 @@
 {
 	int iMin, iMax, i;
 	BOOL fFound;
-	entity_t *pe;
+	entity_s *pe;
 	
 	fFound = FALSE;
 	pe = entities.next;
@@ -827,9 +820,9 @@
 		return iHint;
 }
 
-entity_t *FindEntity(char *pszKey, char *pszValue)
+entity_s *FindEntity(char *pszKey, char *pszValue)
 {
-	entity_t *pe;
+	entity_s *pe;
 	
 	pe = entities.next;
 	
@@ -842,9 +835,9 @@
 	return NULL;
 }
 
-entity_t *FindEntityInt(char *pszKey, int iValue)
+entity_s *FindEntityInt(char *pszKey, int iValue)
 {
-	entity_t *pe;
+	entity_s *pe;
 	
 	pe = entities.next;
 	
Index: q3radiant/ENTITY.H
===================================================================
--- q3radiant/ENTITY.H	(revision 443)
+++ q3radiant/ENTITY.H	(working copy)
@@ -19,59 +19,56 @@
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 ===========================================================================
 */
-    // entity.h
+// entity.h
 
-    void Eclass_InitForSourceDirectory (char *path);
-	// this will create a new eclass_t if one is not present
-    eclass_t *Eclass_ForName (char *name, bool has_brushes);
-	// this will return 0 if class with given name is not present
-	eclass_t *Eclass_FindExisting (const char *name);
-	void EClass_CreateNewFromText(const char *text);
-    
-    
-    typedef struct entity_s
-    {
-    	struct entity_s	*prev, *next;
-    	brush_t		brushes;					// head/tail of list
-     	int			undoId, redoId, entityId;	// used for undo/redo
-    	edVec3_c		origin;
-    	eclass_t	*eclass;
-    	epair_t		*epairs;
-    	eclass_t  *md3Class;
-      vec3_t vRotation;   // valid for misc_models only
-      vec3_t vScale;      // valid for misc_models only
-    } entity_t;
-    
-    char 	*ValueForKey (entity_t *ent, const char *key);
-    void	SetKeyValue (entity_t *ent, const char *key, const char *value);
-    void 	SetKeyValue (epair_t *&e, const char *key, const char *value);
-    void 	DeleteKey (entity_t *ent, const char *key);
-    void 	DeleteKey (epair_t *&e, const char *key);
-    float	FloatForKey (entity_t *ent, const char *key);
-    int		IntForKey (entity_t *ent, const char *key);
-    void 	GetVectorForKey (entity_t *ent, const char *key, vec3_t vec);
-    
-    void		Entity_Free (entity_t *e);
-    void		Entity_FreeEpairs(entity_t *e);
-    int			Entity_MemorySize(entity_t *e);
-    entity_t	*Entity_Parse (bool onlypairs, brush_t* pList = NULL);
-    void		Entity_Write (entity_t *e, FILE *f, bool use_region);
-    void		Entity_WriteSelected(entity_t *e, FILE *f);
-    void		Entity_WriteSelected(entity_t *e, CMemFile*);
-    entity_t	*Entity_Create (eclass_t *c);
-    entity_t	*Entity_Clone (entity_t *e);
-    void		Entity_AddToList(entity_t *e, entity_t *list);
-    void		Entity_RemoveFromList(entity_t *e);
-    
-    void		Entity_LinkBrush (entity_t *e, brush_t *b);
-    void		Entity_UnlinkBrush (brush_t *b);
-    entity_t	*FindEntity(char *pszKey, char *pszValue);
-    entity_t	*FindEntityInt(char *pszKey, int iValue);
-    
-    int GetUniqueTargetId(int iHint);
-    bool Eclass_hasModel(eclass_t *e, class edVec3_c &vMin, edVec3_c &vMax);
-    eclass_t* GetCachedModel(entity_t *pEntity, const char *pName, class edVec3_c &vMin, edVec3_c &vMax);
-    
-    //Timo : used for parsing epairs in brush primitive
-    epair_t* ParseEpair(void);
-    char *ValueForKey ( epair_t *&e, const char *key);
+void Eclass_InitForSourceDirectory (char *path);
+// this will create a new eclass_s if one is not present
+eclass_s *Eclass_ForName (char *name, bool has_brushes);
+// this will return 0 if class with given name is not present
+eclass_s *Eclass_FindExisting (const char *name);
+void EClass_CreateNewFromText(const char *text);
+
+
+struct entity_s
+{
+	struct entity_s	*prev, *next;
+	brush_s		brushes;					// head/tail of list
+	int			undoId, redoId, entityId;	// used for undo/redo
+	edVec3_c		origin;
+	eclass_s	*eclass;
+	epair_s		*epairs;
+	vec3_t vRotation;   // valid for misc_models only
+	vec3_t vScale;      // valid for misc_models only
+};
+
+char 	*ValueForKey (entity_s *ent, const char *key);
+void	SetKeyValue (entity_s *ent, const char *key, const char *value);
+void 	SetKeyValue (epair_s *&e, const char *key, const char *value);
+void 	DeleteKey (entity_s *ent, const char *key);
+void 	DeleteKey (epair_s *&e, const char *key);
+float	FloatForKey (entity_s *ent, const char *key);
+int		IntForKey (entity_s *ent, const char *key);
+void 	GetVectorForKey (entity_s *ent, const char *key, vec3_t vec);
+
+void		Entity_Free (entity_s *e);
+void		Entity_FreeEpairs(entity_s *e);
+int			Entity_MemorySize(entity_s *e);
+entity_s	*Entity_Parse (bool onlypairs, brush_s* pList = NULL);
+void		Entity_Write (entity_s *e, FILE *f, bool use_region);
+void		Entity_WriteSelected(entity_s *e, FILE *f);
+void		Entity_WriteSelected(entity_s *e, CMemFile*);
+entity_s	*Entity_Create (eclass_s *c);
+entity_s	*Entity_Clone (entity_s *e);
+void		Entity_AddToList(entity_s *e, entity_s *list);
+void		Entity_RemoveFromList(entity_s *e);
+
+void		Entity_LinkBrush (entity_s *e, brush_s *b);
+void		Entity_UnlinkBrush (brush_s *b);
+entity_s	*FindEntity(char *pszKey, char *pszValue);
+entity_s	*FindEntityInt(char *pszKey, int iValue);
+
+int GetUniqueTargetId(int iHint);
+
+//Timo : used for parsing epairs in brush primitive
+epair_s* ParseEpair(void);
+char *ValueForKey ( epair_s *&e, const char *key);
Index: q3radiant/EntityListDlg.cpp
===================================================================
--- q3radiant/EntityListDlg.cpp	(revision 436)
+++ q3radiant/EntityListDlg.cpp	(working copy)
@@ -70,7 +70,7 @@
   HTREEITEM hItem = m_treeEntity.GetSelectedItem();
   if (hItem)
   {
-    entity_t* pEntity = reinterpret_cast<entity_t*>(m_treeEntity.GetItemData(hItem));
+    entity_s* pEntity = reinterpret_cast<entity_s*>(m_treeEntity.GetItemData(hItem));
     if (pEntity)
     {
       Select_Deselect();
@@ -90,7 +90,7 @@
   HTREEITEM hChild = m_treeEntity.InsertItem(world_entity->eclass->name, hParent);
   m_treeEntity.SetItemData(hChild, reinterpret_cast<DWORD>(world_entity));
 
-	for (entity_t* pEntity=entities.next ; pEntity != &entities ; pEntity=pEntity->next)
+	for (entity_s* pEntity=entities.next ; pEntity != &entities ; pEntity=pEntity->next)
 	{
     hParent = NULL;
     if (mapEntity.Lookup(pEntity->eclass->name, reinterpret_cast<void*&>(hParent)) == FALSE)
@@ -121,10 +121,10 @@
   if (hItem)
   {
     CString strList;
-    entity_t* pEntity = reinterpret_cast<entity_t*>(m_treeEntity.GetItemData(hItem));
+    entity_s* pEntity = reinterpret_cast<entity_s*>(m_treeEntity.GetItemData(hItem));
     if (pEntity)
     {
-	    for (epair_t* pEpair = pEntity->epairs ; pEpair ; pEpair = pEpair->next)
+	    for (epair_s* pEpair = pEntity->epairs ; pEpair ; pEpair = pEpair->next)
       {
 		    if (strlen(pEpair->key) > 8)
           strList.Format("%s\t%s", pEpair->key, pEpair->value);
Index: q3radiant/IShaders.cpp
===================================================================
--- q3radiant/IShaders.cpp	(revision 436)
+++ q3radiant/IShaders.cpp	(working copy)
@@ -39,9 +39,6 @@
 
 #include "stdafx.h"
 
-//++timo NOTE: this whole part is evolving on a seperate branch on SourceForge
-// will eventually turn into a major rewrite of the shader / texture code
-
 // this is a modified version of Texture_ForName
 qtexture_t* WINAPI QERApp_TryTextureForName(const char* name)
 {
Index: q3radiant/MainFrm.cpp
===================================================================
--- q3radiant/MainFrm.cpp	(revision 459)
+++ q3radiant/MainFrm.cpp	(working copy)
@@ -46,7 +46,6 @@
 #include "DialogThick.h"
 #include "PatchDialog.h"
 #include "Undo.h"
-#include "NameDlg.h"
 #include "libs/pakstuff.h"
 
 #ifdef _DEBUG
@@ -69,8 +68,8 @@
 
 //bool g_bSnapToGrid = true;              // early use, no longer in use, clamping pref will be used
 CString g_strProject;                   // holds the active project filename
+bool g_bClosingRadiant = false;
 
-
 /////////////////////////////////////////////////////////////////////////////
 // CMainFrame
 
@@ -413,7 +412,6 @@
 	ON_COMMAND(ID_TOGGLE_LOCK, OnToggleLock)
 	ON_COMMAND(ID_EDIT_MAPINFO, OnEditMapinfo)
 	ON_COMMAND(ID_EDIT_ENTITYINFO, OnEditEntityinfo)
-	ON_COMMAND(ID_BRUSH_SCRIPTS, OnBrushScripts)
 	ON_COMMAND(ID_VIEW_NEXTVIEW, OnViewNextview)
 	ON_COMMAND(ID_HELP_COMMANDLIST, OnHelpCommandlist)
 	ON_COMMAND(ID_FILE_NEWPROJECT, OnFileNewproject)
@@ -562,7 +560,6 @@
 	ON_UPDATE_COMMAND_UI(ID_TEXTURES_SHOWINUSE, OnUpdateTexturesShowinuse)
 	ON_COMMAND(ID_TEXTURES_SHOWALL, OnTexturesShowall)
 	ON_COMMAND(ID_PATCH_INSPECTOR, OnPatchInspector)
-	ON_COMMAND(ID_VIEW_OPENGLLIGHTING, OnViewOpengllighting)
 	ON_COMMAND(ID_SELECT_ALL, OnSelectAll)
 	ON_COMMAND(ID_VIEW_SHOWCAULK, OnViewShowcaulk)
 	ON_COMMAND(ID_CURVE_FREEZE, OnCurveFreeze)
@@ -579,11 +576,6 @@
 	ON_COMMAND(ID_VIEW_HIDESHOW_SHOWHIDDEN, OnViewHideshowShowhidden)
 	ON_COMMAND(ID_TEXTURES_SHADERS_SHOW, OnTexturesShadersShow)
 	ON_COMMAND(ID_TEXTURES_FLUSH_UNUSED, OnTexturesFlushUnused)
-	ON_COMMAND(ID_VIEW_GROUPS, OnViewGroups)
-	ON_COMMAND(ID_DROP_GROUP_ADDTO_WORLD, OnDropGroupAddtoWorld)
-	ON_COMMAND(ID_DROP_GROUP_NAME, OnDropGroupName)
-	ON_COMMAND(ID_DROP_GROUP_NEWGROUP, OnDropGroupNewgroup)
-	ON_COMMAND(ID_DROP_GROUP_REMOVE, OnDropGroupRemove)
 	//}}AFX_MSG_MAP
   ON_COMMAND_RANGE(CMD_TEXTUREWAD, CMD_TEXTUREWAD_END, OnTextureWad)
   ON_COMMAND_RANGE(CMD_BSPCOMMAND, CMD_BSPCOMMAND_END, OnBspCommand)
@@ -703,7 +695,6 @@
     pMenu->CheckMenuItem(ID_TOGGLE_LOCK, MF_BYCOMMAND | (g_PrefsDlg.m_bTextureLock) ? MF_CHECKED : MF_UNCHECKED);
     pMenu->CheckMenuItem(ID_TOGGLE_ROTATELOCK, MF_BYCOMMAND | (g_PrefsDlg.m_bRotateLock) ? MF_CHECKED : MF_UNCHECKED);
     pMenu->CheckMenuItem(ID_VIEW_CUBICCLIPPING, MF_BYCOMMAND | (g_PrefsDlg.m_bCubicClipping) ? MF_CHECKED : MF_UNCHECKED);
-    pMenu->CheckMenuItem (ID_VIEW_OPENGLLIGHTING, MF_BYCOMMAND | (g_PrefsDlg.m_bGLLighting) ? MF_CHECKED : MF_UNCHECKED );
     pMenu->CheckMenuItem (ID_SNAPTOGRID, MF_BYCOMMAND | (!g_PrefsDlg.m_bNoClamp) ? MF_CHECKED : MF_UNCHECKED );
     if (m_wndToolBar.GetSafeHwnd())
       m_wndToolBar.GetToolBarCtrl().CheckButton(ID_VIEW_CUBICCLIPPING, (g_PrefsDlg.m_bCubicClipping) ? TRUE : FALSE);
@@ -1005,7 +996,7 @@
       vec3_t vMin, vMax;
       vMin[0] = vMin[1] = vMin[2] = 0;
       vMax[0] = vMax[1] = vMax[2] = 8;
-      brush_t* pBrush = Brush_Create(vMin, vMax, &g_qeglobals.d_texturewin.texdef);
+      brush_s* pBrush = Brush_Create(vMin, vMax, &g_qeglobals.d_texturewin.texdef);
 	    Entity_LinkBrush (world_entity, pBrush);
       Brush_Build(pBrush);
 	    Brush_AddToList (pBrush, &active_brushes);
@@ -1418,10 +1409,10 @@
 	while (entities.next != &entities)
 		Entity_Free (entities.next);
 
-	epair_t* pEPair = g_qeglobals.d_project_entity->epairs;
+	epair_s* pEPair = g_qeglobals.d_project_entity->epairs;
   while (pEPair)
   {
-    epair_t* pNextEPair = pEPair->next;
+    epair_s* pNextEPair = pEPair->next;
     free (pEPair->key);
     free (pEPair->value);
     free (pEPair);
@@ -1428,10 +1419,10 @@
     pEPair = pNextEPair;
   }
 
-	entity_t* pEntity = g_qeglobals.d_project_entity->next;
+	entity_s* pEntity = g_qeglobals.d_project_entity->next;
   while (pEntity != NULL && pEntity != g_qeglobals.d_project_entity)
   {
-    entity_t* pNextEntity = pEntity->next;
+    entity_s* pNextEntity = pEntity->next;
     Entity_Free(pEntity);
     pEntity = pNextEntity;
   }
@@ -1460,6 +1451,7 @@
 {
 	if (ConfirmModified())
 	{
+		g_bClosingRadiant = true;
 		CFrameWnd::OnClose();
 	}
 }
@@ -1571,10 +1563,6 @@
   
   CreateEntityWindow(AfxGetInstanceHandle());
 
-  g_pGroupDlg->Create( IDD_DLG_GROUP, this);
-  g_qeglobals.d_hwndGroup = g_pGroupDlg->GetSafeHwnd();
-  ::SetParent(g_qeglobals.d_hwndGroup, g_qeglobals.d_hwndEntity);
-  g_pGroupDlg->ShowWindow(SW_SHOW);
   
   if (!LoadWindowPlacement(GetSafeHwnd(), "Radiant::MainWindowPlace"))
   {
@@ -2476,7 +2464,7 @@
 	Undo_AddBrushList(&selected_brushes);
 
 	Select_FlipAxis (0);
-	for (brush_t *b=selected_brushes.next ; b != &selected_brushes ; b=b->next)
+	for (brush_s *b=selected_brushes.next ; b != &selected_brushes ; b=b->next)
 	{
 		if(b->owner->eclass->fixedsize)
 		{
@@ -2498,7 +2486,7 @@
 	Undo_AddBrushList(&selected_brushes);
 
 	Select_FlipAxis (1);
-	for (brush_t *b=selected_brushes.next ; b != &selected_brushes ; b=b->next)
+	for (brush_s *b=selected_brushes.next ; b != &selected_brushes ; b=b->next)
 	{
 		if(b->owner->eclass->fixedsize)
 		{
@@ -2655,7 +2643,7 @@
 
 void CMainFrame::OnSelectionDelete() 
 {
-	brush_t *brush;
+	brush_s *brush;
 	//if (ActiveXY())
 	//	ActiveXY()->UndoCopy();
 	Undo_Start("delete");
@@ -3050,13 +3038,6 @@
 }
 
 
-
-void CMainFrame::OnBrushScripts() 
-{
-  //CScriptDlg dlg;
- // dlg.DoModal();
-}
-
 void CMainFrame::OnViewNextview() 
 {
   if (m_nCurrentStyle != 2)
@@ -3890,7 +3871,7 @@
 
 void CMainFrame::OnSelectionPrint() 
 {
-  for (brush_t* b=selected_brushes.next ; b != &selected_brushes ; b=b->next)
+  for (brush_s* b=selected_brushes.next ; b != &selected_brushes ; b=b->next)
     Brush_Print(b);
 }
 
@@ -4174,11 +4155,11 @@
 {
 #if 0
   Select_Deselect();
-	for (brush_t* pb = active_brushes.next ; pb != &active_brushes ; pb = pb->next)
+	for (brush_s* pb = active_brushes.next ; pb != &active_brushes ; pb = pb->next)
 	{
     if (pb->curveBrush)
     {
-	    for (face_t* f = pb->brush_faces ; f ; f=f->next) 
+	    for (face_s* f = pb->brush_faces ; f ; f=f->next) 
       {
 		    if (f->texdef.contents & CONTENTS_LADDER)
         {
@@ -4467,8 +4448,8 @@
     // check to see if the selected brush is part of a func group
     // if it is, deselect everything and reselect the next brush 
     // in the group
-	  brush_t *b = selected_brushes.next;
-    entity_t * e;
+	  brush_s *b = selected_brushes.next;
+    entity_s * e;
     if (b != &selected_brushes)
     {
 	    if (strcmpi(b->owner->eclass->name, "worldspawn") != 0)
@@ -4475,7 +4456,7 @@
       {
         e = b->owner;
         Select_Deselect();
-		brush_t * b2;
+		brush_s * b2;
 		    for (b2 = e->brushes.onext ; b2 != &e->brushes ; b2 = b2->onext)
 		    {
           if (b == b2)
@@ -4786,14 +4767,6 @@
   DoPatchInspector();
 }
 
-void CMainFrame::OnViewOpengllighting() 
-{
-  g_PrefsDlg.m_bGLLighting ^= 1;
-  g_PrefsDlg.SavePrefs();
-  CheckMenuItem ( ::GetMenu(g_qeglobals.d_hwndMain), ID_VIEW_OPENGLLIGHTING, MF_BYCOMMAND | (g_PrefsDlg.m_bGLLighting) ? MF_CHECKED : MF_UNCHECKED );
-	Sys_UpdateWindows (W_XY|W_CAMERA);
-}
-
 void CMainFrame::OnSelectAll()
 {
   Select_AllOfType();
@@ -4951,59 +4924,4 @@
 }
 
 
-void CMainFrame::OnViewGroups()
-{
-  if (m_nCurrentStyle == 0 || m_nCurrentStyle == 3)
-  {
-    if (::IsWindowVisible(g_qeglobals.d_hwndEntity) && inspector_mode == W_GROUP)
-      ::ShowWindow(g_qeglobals.d_hwndEntity, SW_HIDE);
-    else
-    {
-      ::ShowWindow(g_qeglobals.d_hwndEntity, SW_NORMAL);
-      SetInspectorMode(W_GROUP);
-    }
-  }
-  else
-  {
-    if (inspector_mode == W_GROUP && m_nCurrentStyle != QR_QE4)
-    {
-      if (::IsWindowVisible(g_qeglobals.d_hwndEntity))
-        ::ShowWindow(g_qeglobals.d_hwndEntity, SW_HIDE);
-      else
-        ::ShowWindow(g_qeglobals.d_hwndEntity, SW_NORMAL);
-    }
-    else
-    {
-      ::ShowWindow(g_qeglobals.d_hwndEntity, SW_NORMAL);
-      SetInspectorMode(W_GROUP);
-    }
-  }
-}
 
-void CMainFrame::OnDropGroupAddtoWorld() 
-{
-  Select_AddToGroup("World");
-  Sys_UpdateWindows (W_ALL);
-}
-
-void CMainFrame::OnDropGroupName() 
-{
-  CNameDlg dlg("Name Selection", this);
-  if (dlg.DoModal() == IDOK)
-  {
-    Select_Name(dlg.m_strName);
-    Sys_UpdateWindows (W_ALL);
-  }
-}
-
-void CMainFrame::OnDropGroupNewgroup() 
-{
-
-}
-
-void CMainFrame::OnDropGroupRemove() 
-{
-  Select_AddToGroup("World");
-  Sys_UpdateWindows (W_ALL);
-}
-
Index: q3radiant/MainFrm.h
===================================================================
--- q3radiant/MainFrm.h	(revision 436)
+++ q3radiant/MainFrm.h	(working copy)
@@ -37,7 +37,6 @@
 #include "CamWnd.h"
 #include "RADEditWnd.h"
 #include "TextureBar.h"
-#include "groupdlg.h"
 
 
 const int RAD_SHIFT =   0x01;
@@ -291,7 +290,6 @@
 	afx_msg void OnToggleLock();
 	afx_msg void OnEditMapinfo();
 	afx_msg void OnEditEntityinfo();
-	afx_msg void OnBrushScripts();
 	afx_msg void OnViewNextview();
 	afx_msg void OnHelpCommandlist();
 	afx_msg void OnFileNewproject();
@@ -442,7 +440,6 @@
 	afx_msg void OnUpdateTexturesShowinuse(CCmdUI* pCmdUI);
 	afx_msg void OnTexturesShowall();
 	afx_msg void OnPatchInspector();
-	afx_msg void OnViewOpengllighting();
 	afx_msg void OnSelectAll();
 	afx_msg void OnViewShowcaulk();
   afx_msg void OnCurveFreeze();
@@ -459,11 +456,6 @@
 	afx_msg void OnViewHideshowShowhidden();
 	afx_msg void OnTexturesShadersShow();
 	afx_msg void OnTexturesFlushUnused();
-	afx_msg void OnViewGroups();
-	afx_msg void OnDropGroupAddtoWorld();
-	afx_msg void OnDropGroupName();
-	afx_msg void OnDropGroupNewgroup();
-	afx_msg void OnDropGroupRemove();
 	//}}AFX_MSG
   afx_msg void OnMru(unsigned int nID);
   afx_msg void OnViewNearest(unsigned int nID);
Index: q3radiant/MAP.CPP
===================================================================
--- q3radiant/MAP.CPP	(revision 459)
+++ q3radiant/MAP.CPP	(working copy)
@@ -31,17 +31,17 @@
 char		currentmap[1024];
 
 
-brush_t	active_brushes;		// brushes currently being displayed
-brush_t	selected_brushes;	// highlighted
+brush_s	active_brushes;		// brushes currently being displayed
+brush_s	selected_brushes;	// highlighted
 
-face_t	*selected_face;
-brush_t	*selected_face_brush;
+face_s	*selected_face;
+brush_s	*selected_face_brush;
 
-brush_t	filtered_brushes;	// brushes that have been filtered or regioned
+brush_s	filtered_brushes;	// brushes that have been filtered or regioned
 
-entity_t	entities;		// head/tail of doubly linked list
+entity_s	entities;		// head/tail of doubly linked list
 
-entity_t	*world_entity = NULL; // "classname" "worldspawn" !
+entity_s	*world_entity = NULL; // "classname" "worldspawn" !
 
 void AddRegionBrushes (void);
 void RemoveRegionBrushes (void);
@@ -62,8 +62,8 @@
 =============================================================
 */
 
-brush_t		between_brushes;
-entity_t	between_entities;
+brush_s		between_brushes;
+entity_s	between_entities;
 
 bool g_bRestoreBetween = false;
 
@@ -79,8 +79,8 @@
 
 #if 0
 
-	brush_t		*b;
-	entity_t	*e, *e2;
+	brush_s		*b;
+	entity_s	*e, *e2;
 
 	between_brushes.next = selected_brushes.next;
 	between_brushes.prev = selected_brushes.prev;
@@ -120,8 +120,8 @@
   return;
 
 #if 0  
-  entity_t	*head, *tail;
-	brush_t		*b;
+  entity_s	*head, *tail;
+	brush_s		*b;
 
 	if (!between_brushes.next)
 		return;
@@ -161,7 +161,7 @@
 
 //============================================================================
 
-bool CheckForTinyBrush(brush_t* b, int n, float fSize)
+bool CheckForTinyBrush(brush_s* b, int n, float fSize)
 {
   bool bTiny = false;
 	for (int i=0 ; i<3 ; i++)
@@ -176,7 +176,7 @@
 
 void Map_BuildBrushData(void)
 {
-	brush_t	*b, *next;
+	brush_s	*b, *next;
 
 	if (active_brushes.next == NULL)
 		return;
@@ -197,9 +197,9 @@
 	Sys_EndWait();
 }
 
-entity_t *Map_FindClass (char *cname)
+entity_s *Map_FindClass (char *cname)
 {
-	entity_t	*ent;
+	entity_s	*ent;
 
 	for (ent = entities.next ; ent != &entities ; ent=ent->next)
 	{
@@ -256,9 +256,9 @@
 	world_entity = NULL;
 }
 
-entity_t *AngledEntity()
+entity_s *AngledEntity()
 {
-  entity_t *ent = Map_FindClass ("info_player_start");
+  entity_s *ent = Map_FindClass ("info_player_start");
 	if (!ent)
   {
 		ent = Map_FindClass ("info_player_deathmatch");
@@ -296,7 +296,7 @@
 void Map_LoadFile (char *filename)
 {
     char		*buf;
-	entity_t	*ent;
+	entity_s	*ent;
 	char         temp[1024];
 
 	Sys_BeginWait ();
@@ -307,8 +307,6 @@
 	Sys_Printf ("Map_LoadFile: %s\n", temp );
 
 	Map_Free ();
-	//++timo FIXME: maybe even easier to have Group_Init called from Map_Free?
-	Group_Init();
 
 	g_qeglobals.d_parsed_brushes = 0;
 	strcpy (currentmap, filename);
@@ -336,13 +334,7 @@
 					Sys_Printf ("WARNING: multiple worldspawn\n");
 				world_entity = ent;
 			}
-			else if (!strcmp(ValueForKey (ent, "classname"), "group_info"))
-      {
-        // it's a group thing!
-        Group_Add(ent);
-        Entity_Free(ent);
-      }
-      else
+			 else
 			{
 				// add the entity to the end of the entity list
 				ent->next = &entities;
@@ -417,7 +409,7 @@
 */
 void Map_SaveFile (char *filename, bool use_region )
 {
-	entity_t	*e, *next;
+	entity_s	*e, *next;
 	FILE		*f;
 	char         temp[1024];
 	int			count;
@@ -481,9 +473,6 @@
     }
 	}
 
-	// save the group info stuff
-	Group_Save(f);
-
 	fclose (f);
 
 	if (use_region)
@@ -543,8 +532,6 @@
 
 	Map_RestoreBetween ();
 
-  Group_Init();
-
 	Sys_UpdateWindows (W_ALL);
 	modified = false;
 }
@@ -561,7 +548,7 @@
 edVec3_c	region_mins(MIN_WORLD_COORD, MIN_WORLD_COORD, MIN_WORLD_COORD);
 edVec3_c	region_maxs(MAX_WORLD_COORD, MAX_WORLD_COORD, MAX_WORLD_COORD);
 
-brush_t	*region_sides[4];
+brush_s	*region_sides[4];
 /*
 ===========
 AddRegionBrushes
@@ -623,7 +610,7 @@
 }
 
 
-bool Map_IsBrushFiltered (brush_t *b)
+bool Map_IsBrushFiltered (brush_s *b)
 {
 	int		i;
 
@@ -646,7 +633,7 @@
 */
 void Map_RegionOff (void)
 {
-	brush_t	*b, *next;
+	brush_s	*b, *next;
 	int			i;
 
 	region_active = false;
@@ -675,7 +662,7 @@
 
 void Map_ApplyRegion (void)
 {
-	brush_t	*b, *next;
+	brush_s	*b, *next;
 
 	region_active = true;
 	for (b=active_brushes.next ; b != &active_brushes ; b=next)
@@ -752,7 +739,7 @@
 */
 void Map_RegionTallBrush (void)
 {
-	brush_t	*b;
+	brush_s	*b;
 
 	if (!QE_SingleBrush ())
 		return;
@@ -777,7 +764,7 @@
 */
 void Map_RegionBrush (void)
 {
-	brush_t	*b;
+	brush_s	*b;
 
 	if (!QE_SingleBrush ())
 		return;
@@ -799,7 +786,7 @@
 {
 	// make a unique target value
 	int maxtarg = 0;
-	for (entity_t* e=entities.next ; e != &entities ; e=e->next)
+	for (entity_s* e=entities.next ; e != &entities ; e=e->next)
 	{
 		char* tn = ValueForKey (e, "targetname");
 		if (tn && tn[0])
@@ -831,8 +818,8 @@
 //
 void Map_ImportBuffer (char* buf)
 {
-	entity_t* ent;
-	brush_t* b = NULL;
+	entity_s* ent;
+	brush_s* b = NULL;
 	CPtrArray ptrs;
 
 	Select_Deselect();
@@ -875,7 +862,7 @@
 				b=ent->brushes.onext;
 				while (b && b != &ent->brushes)
 				{
-					brush_t* bNext = b->onext;
+					brush_s* bNext = b->onext;
 					Entity_UnlinkBrush(b);
 					Entity_LinkBrush(world_entity, b);
 					ptrs.Add(b);
@@ -937,8 +924,8 @@
 	g_bScreenUpdates = false; 
 	for (int i = 0; i < ptrs.GetSize(); i++)
 	{
-		Brush_Build(reinterpret_cast<brush_t*>(ptrs[i]), true, false);
-		Select_Brush(reinterpret_cast<brush_t*>(ptrs[i]), true, false);
+		Brush_Build(reinterpret_cast<brush_s*>(ptrs[i]), true, false);
+		Select_Brush(reinterpret_cast<brush_s*>(ptrs[i]), true, false);
 	}
 	//::LockWindowUpdate(NULL);
 	g_bScreenUpdates = true; 
@@ -965,16 +952,16 @@
 //
 void Map_ImportFile (char *filename)
 {
-  char* buf;
+	char* buf;
 	char temp[1024];
 	Sys_BeginWait ();
 	QE_ConvertDOSToUnixName( temp, filename );
-  if (LoadFile (filename, (void **)&buf) != -1)
-  {
-    Map_ImportBuffer(buf);
-    free(buf);
-    Map_BuildBrushData();
-  }
+	if (LoadFile (filename, (void **)&buf) != -1)
+	{
+		Map_ImportBuffer(buf);
+		free(buf);
+		Map_BuildBrushData();
+	}
 	Sys_UpdateWindows (W_ALL);
 	modified = true;
 	Sys_EndWait();
@@ -989,7 +976,7 @@
 //
 void Map_SaveSelected(char* pFilename)
 {
-	entity_t	*e, *next;
+	entity_s	*e, *next;
 	FILE *f;
 	char temp[1024];
 	int count;
@@ -1028,7 +1015,7 @@
 //
 void Map_SaveSelected(CMemFile* pMemFile, CMemFile* pPatchFile)
 {
-	entity_t	*e, *next;
+	entity_s	*e, *next;
 	int count;
 	CString strTemp;
   
Index: q3radiant/MAP.H
===================================================================
--- q3radiant/MAP.H	(revision 443)
+++ q3radiant/MAP.H	(working copy)
@@ -24,18 +24,18 @@
 extern	char		currentmap[1024];
 
 // head/tail of doubly linked lists
-extern	brush_t	active_brushes;	// brushes currently being displayed
-extern	brush_t	selected_brushes;	// highlighted
+extern	brush_s	active_brushes;	// brushes currently being displayed
+extern	brush_s	selected_brushes;	// highlighted
 
 
 extern CPtrArray& g_ptrSelectedFaces;
 extern CPtrArray& g_ptrSelectedFaceBrushes;
-//extern	face_t	*selected_face;
-//extern	brush_t	*selected_face_brush;
-extern	brush_t	filtered_brushes;	// brushes that have been filtered or regioned
+//extern	face_s	*selected_face;
+//extern	brush_s	*selected_face_brush;
+extern	brush_s	filtered_brushes;	// brushes that have been filtered or regioned
 
-extern	entity_t	entities;
-extern	entity_t	*world_entity;	// the world entity is NOT included in
+extern	entity_s	entities;
+extern	entity_s	*world_entity;	// the world entity is NOT included in
 									// the entities chain
 
 extern	bool	modified;		// for quit confirmations
@@ -53,7 +53,7 @@
 void	Map_RegionTallBrush (void);
 void	Map_RegionBrush (void);
 void	Map_RegionSelectedBrushes (void);
-bool Map_IsBrushFiltered (brush_t *b);
+bool Map_IsBrushFiltered (brush_s *b);
 
 void Map_SaveSelected(CMemFile* pMemFile, CMemFile* pPatchFile = NULL);
 void Map_ImportBuffer (char* buf);
Index: q3radiant/MapInfo.cpp
===================================================================
--- q3radiant/MapInfo.cpp	(revision 436)
+++ q3radiant/MapInfo.cpp	(working copy)
@@ -75,7 +75,7 @@
   m_nTotalBrushes = 0;
   m_nTotalEntities = 0;
   m_nNet = 0;
-	for (brush_t* pBrush=active_brushes.next ; pBrush != &active_brushes ; pBrush=pBrush->next)
+	for (brush_s* pBrush=active_brushes.next ; pBrush != &active_brushes ; pBrush=pBrush->next)
   {
     m_nTotalBrushes++;
     if (pBrush->owner == world_entity)
@@ -86,7 +86,7 @@
   CMapStringToPtr mapEntity;
 
   int nValue = 0;
-	for (entity_t* pEntity=entities.next ; pEntity != &entities ; pEntity=pEntity->next)
+	for (entity_s* pEntity=entities.next ; pEntity != &entities ; pEntity=pEntity->next)
 	{
     m_nTotalEntities++;
     nValue = 0;
Index: q3radiant/MATHLIB.H
===================================================================
--- q3radiant/MATHLIB.H	(revision 458)
+++ q3radiant/MATHLIB.H	(working copy)
@@ -150,7 +150,33 @@
 			up[2] = cr*cp;
 		}
 	}
+	void axializeVector() {
+		if (!_v[0] && !_v[1])
+			return;
+		if (!_v[1] && !_v[2])
+			return;
+		if (!_v[0] && !_v[2])
+			return;
 
+		int i;
+		float a[3];
+		for (i=0 ; i<3 ; i++)
+			a[i] = fabs(_v[i]);
+		if (a[0] > a[1] && a[0] > a[2])
+			i = 0;
+		else if (a[1] > a[0] && a[1] > a[2])
+			i = 1;
+		else
+			i = 2;
+
+		float o = _v[i];
+		this->clear();
+		if (o<0)
+			_v[i] = -1;
+		else
+			_v[i] = 1;
+	}
+
 	void operator *=(float f) {
 		x *= f;
 		y *= f;
Index: q3radiant/PatchDialog.h
===================================================================
--- q3radiant/PatchDialog.h	(revision 436)
+++ q3radiant/PatchDialog.h	(working copy)
@@ -33,7 +33,7 @@
 
 class CPatchDialog : public CDialog
 {
-  patchMesh_t *m_Patch;
+  patchMesh_c *m_Patch;
 // Construction
 public:
 	void UpdateInfo();
Index: q3radiant/PMESH.CPP
===================================================================
--- q3radiant/PMESH.CPP	(revision 458)
+++ q3radiant/PMESH.CPP	(working copy)
@@ -31,7 +31,7 @@
 
 // externs
 extern void MemFile_fprintf(CMemFile* pMemFile, const char* pText, ...);
-extern face_t *Face_Alloc( void );
+extern face_s *Face_Alloc( void );
 void _Write3DMatrix (FILE *f, int y, int x, int z, float *m);
 void _Write3DMatrix (CMemFile *f, int y, int x, int z, float *m);
 
@@ -40,24 +40,14 @@
 #define	CBLOCK_SUBDIVISIONS	6 
 
 
-patchMesh_t* MakeNewPatch()
+patchMesh_c* MakeNewPatch()
 {
-  patchMesh_t *pm = reinterpret_cast<patchMesh_t*>(qmalloc(sizeof(patchMesh_t)));
-  return pm;
+	return new patchMesh_c();
 }
 
-// FIXME: this needs to be dynamic
-//#define	MAX_PATCH_MESHES	4096
-//patchMesh_t		patchMeshes[MAX_PATCH_MESHES];
-//int numPatchMeshes = 0;
-
 // used for a save spot
-patchMesh_t patchSave;
+patchMesh_c patchSave;
 
-// Tracks the selected patch for point manipulation/update. FIXME: Need to revert back to a generalized 
-// brush approach
-//--int  g_nSelectedPatch = -1;  
-
 // HACK: for tracking which view generated the click
 // as we dont want to deselect a point on a same point
 // click if it is from a different view
@@ -84,11 +74,11 @@
 // BEND states
 enum
 {
-  BEND_SELECT_ROTATION = 0,
-  BEND_SELECT_ORIGIN,
-  BEND_SELECT_EDGE,
-  BEND_BENDIT,
-  BEND_STATE_COUNT
+	BEND_SELECT_ROTATION = 0,
+	BEND_SELECT_ORIGIN,
+	BEND_SELECT_EDGE,
+	BEND_BENDIT,
+	BEND_STATE_COUNT
 };
 
 const char *g_pBendStateMsg[] =
@@ -103,13 +93,13 @@
 // INSERT states
 enum
 {
-  INSERT_SELECT_EDGE = 0,
-  INSERT_STATE_COUNT
+	INSERT_SELECT_EDGE = 0,
+	INSERT_STATE_COUNT
 };
 
 const char* g_pInsertStateMsg[] =
 {
-  "Use TAB to cycle through available rows/columns for insertion/deletion. Press INS to insert at the highlight, DEL to remove the pair"
+	"Use TAB to cycle through available rows/columns for insertion/deletion. Press INS to insert at the highlight, DEL to remove the pair"
 };
 
 
@@ -118,35 +108,7 @@
 const float fFullBright = 1.0;
 const float fLowerLimit = .50;
 const float fDec = .05;
-void _SetColor(face_t* f, float fColor[3])
-{
-  return;
-  fColor[0] = f->d_color[0];
-  fColor[1] = f->d_color[1];
-  fColor[2] = f->d_color[2];
-  qglColor3fv(fColor);
-}
 
-
-void _DecColor(float fColor[3])
-{
-  return;
-  fColor[0] -= fDec;
-  fColor[1] -= fDec ;
-  fColor[2] -= fDec;
-  for (int i = 0; i < 3; i++)
-  {
-    if (fColor[i] <= fLowerLimit)
-    {
-      fColor[0] = fFullBright;
-      fColor[1] = fFullBright;
-      fColor[2] = fFullBright;
-      break;
-    }
-  }
-	qglColor3fv(fColor);
-}
-
 vec_t __VectorNormalize (vec3_t in, edVec3_c &out)
 {
 	vec_t	length, ilength;
@@ -167,22 +129,13 @@
 }
 
 
-void Patch_SetType(patchMesh_t *p, int nType)
-{
-  p->type = (p->type & PATCH_STYLEMASK) | nType;
-}
 
-void Patch_SetStyle(patchMesh_t *p, int nStyle)
-{
-  p->type = (p->type & PATCH_TYPEMASK) | nStyle;
-}
-
 /*
 ==================
 Patch_MemorySize
 ==================
 */
-int Patch_MemorySize(patchMesh_t *p)
+int Patch_MemorySize(patchMesh_c *p)
 {
 	return _msize(p);
 }
@@ -194,40 +147,37 @@
 InterpolateInteriorPoints
 ===============
 */
-void InterpolateInteriorPoints( patchMesh_t *p ) 
+void patchMesh_c::interpolateInteriorPoints() 
 {
 	int		i, j, k;
 	int		next, prev;
 
-	for ( i = 0 ; i < p->width ; i += 2 ) 
-  {
-
-    next = ( i == p->width - 1 ) ? 1 : ( i + 1 ) % p->width;
-    prev = ( i == 0 ) ? p->width - 2 : i - 1;
-
+	for ( i = 0 ; i < this->width ; i += 2 ) 
+	{
+		next = ( i == this->width - 1 ) ? 1 : ( i + 1 ) % this->width;
+		prev = ( i == 0 ) ? this->width - 2 : i - 1;
 #if 0
 		if ( i == 0 ) 
-    {
-			next = ( i + 1 ) % p->width;
-			prev = p->width - 2;		      // joined wrap case
+		{
+			next = ( i + 1 ) % this->width;
+			prev = this->width - 2;		      // joined wrap case
 		} 
-    else if ( i == p->width - 1 ) 
-    {
+		else if ( i == this->width - 1 ) 
+		{
 			next = 1;
 			prev = i - 1;
 		} 
-    else 
-    {
-			next = ( i + 1 ) % p->width;
+		else 
+		{
+			next = ( i + 1 ) % this->width;
 			prev = i - 1;
 		}
 #endif
-
-		for ( j = 0 ; j < p->height ; j++ ) 
-    {
+		for ( j = 0 ; j < this->height ; j++ ) 
+		{
 			for ( k = 0 ; k < 3 ; k++ ) 
-      {
-				p->ctrl[i][j].xyz[k] = ( p->ctrl[next][j].xyz[k] + p->ctrl[prev][j].xyz[k] ) * 0.5;
+			{
+				this->ctrl[i][j].xyz[k] = ( this->ctrl[next][j].xyz[k] + this->ctrl[prev][j].xyz[k] ) * 0.5;
 			}
 		}
 	}
@@ -243,7 +193,7 @@
 	{0,1}, {1,1}, {1,0}, {1,-1}, {0,-1}, {-1,-1}, {-1,0}, {-1,1}
 };
 
-void Patch_MeshNormals(patchMesh_t *in ) 
+void patchMesh_c::meshNormals() 
 {
 	int		i, j, k, dist;
 	edVec3_c	normal;
@@ -259,89 +209,89 @@
 	float		len;
 
 	wrapWidth = false;
-	for ( i = 0 ; i < in->height ; i++ ) 
-  {
+	for ( i = 0 ; i < this->height ; i++ ) 
+	{
 
-		delta = in->ctrl[0][i].xyz - in->ctrl[in->width-1][i].xyz;
+		delta = this->ctrl[0][i].xyz - this->ctrl[this->width-1][i].xyz;
 		len = delta.vectorLength();
 		if ( len > 1.0 ) 
-    {
+		{
 			break;
 		}
 	}
-	if ( i == in->height ) 
-  {
+	if ( i == this->height ) 
+	{
 		wrapWidth = true;
 	}
 
 	wrapHeight = false;
-	for ( i = 0 ; i < in->width ; i++ ) 
-  {
-		delta = in->ctrl[i][0].xyz - in->ctrl[i][in->height-1].xyz;
+	for ( i = 0 ; i < this->width ; i++ ) 
+	{
+		delta = this->ctrl[i][0].xyz - this->ctrl[i][this->height-1].xyz;
 		len = delta.vectorLength();
 		if ( len > 1.0 ) 
-    {
+		{
 			break;
 		}
 	}
-	if ( i == in->width) 
-  {
+	if ( i == this->width) 
+	{
 		wrapHeight = true;
 	}
 
 
-	for ( i = 0 ; i < in->width ; i++ ) 
-  {
-		for ( j = 0 ; j < in->height ; j++ ) 
-    {
+	for ( i = 0 ; i < this->width ; i++ ) 
+	{
+		for ( j = 0 ; j < this->height ; j++ ) 
+		{
 			count = 0;
-			//--dv = reinterpret_cast<drawVert_t*>(in.ctrl[j*in.width+i]);
-			dv = &in->ctrl[i][j];
+			//--dv = reinterpret_cast<drawVert_t*>(this.ctrl[j*this.width+i]);
+			dv = &this->ctrl[i][j];
 			base = dv->xyz;
 			for ( k = 0 ; k < 8 ; k++ ) 
-      {
+			{
 				around[k].clear();
 				good[k] = false;
 
 				for ( dist = 1 ; dist <= 3 ; dist++ ) 
-        {
+				{
 					x = i + neighbors[k][0] * dist;
 					y = j + neighbors[k][1] * dist;
 					if ( wrapWidth ) 
-          {
+					{
 						if ( x < 0 ) 
-            {
-							x = in->width - 1 + x;
+						{
+							x = this->width - 1 + x;
 						} 
-            else if ( x >= in->width ) 
-            {
-							x = 1 + x - in->width;
+						else if ( x >= this->width ) 
+						{
+							x = 1 + x - this->width;
 						}
 					}
 					if ( wrapHeight ) 
-          {
+					{
 						if ( y < 0 ) 
-            {
-							y = in->height - 1 + y;
+						{
+							y = this->height - 1 + y;
 						} 
-            else if ( y >= in->height ) 
-            {
-							y = 1 + y - in->height;
+						else if ( y >= this->height ) 
+						{
+							y = 1 + y - this->height;
 						}
 					}
 
-					if ( x < 0 || x >= in->width || y < 0 || y >= in->height ) 
-          {
+					if ( x < 0 || x >= this->width || y < 0 || y >= this->height ) 
+					{
 						break;					// edge of patch
 					}
-					//--VectorSubtract( in.ctrl[y*in.width+x]->xyz, base, temp );
-					temp = in->ctrl[x][y].xyz - base;
+					//--VectorSubtract( this.ctrl[y*this.width+x]->xyz, base, temp );
+					temp = this->ctrl[x][y].xyz - base;
 					if ( __VectorNormalize( temp, temp ) == 0 ) 
-          {
+					{
 						continue;				// degenerate edge, get more dist
 					} 
-          else                 
-          {
+					else                 
+					{
 						good[k] = true;
 						around[k] = temp;
 						break;					// good edge
@@ -351,14 +301,14 @@
 
 			sum.clear();
 			for ( k = 0 ; k < 8 ; k++ ) 
-      {
+			{
 				if ( !good[k] || !good[(k+1)&7] ) 
-        {
+				{
 					continue;	// didn't get two points
 				}
 				normal.crossProduct( around[(k+1)&7], around[k] );
 				if ( __VectorNormalize( normal, normal ) == 0 ) 
-        {
+				{
 					continue;
 				}
 				normal += sum;
@@ -365,10 +315,10 @@
 				count++;
 			}
 			if ( count == 0 ) 
-      {
-        //printf("bad normal\n");
+			{
+				//printf("bad normal\n");
 				count = 1;
-        //continue;
+				//continue;
 			}
 			__VectorNormalize( sum, dv->normal );
 		}
@@ -383,26 +333,26 @@
 Patch_CalcBounds
 ==================
 */
-void Patch_CalcBounds(patchMesh_t *p, edVec3_c& vMin, edVec3_c& vMax)
+void patchMesh_c::calcPatchBounds(edVec3_c& vMin, edVec3_c& vMax)
 {
-  vMin[0] = vMin[1] = vMin[2] = 99999;
-  vMax[0] = vMax[1] = vMax[2] = -99999;
+	vMin[0] = vMin[1] = vMin[2] = 99999;
+	vMax[0] = vMax[1] = vMax[2] = -99999;
 
-  p->bDirty = true;
-  for (int w = 0; w < p->width; w++)
-  {
-    for (int h = 0; h < p->height; h++)
-    {
-      for (int j = 0; j < 3; j++)
-      {
-        float f = p->ctrl[w][h].xyz[j];
-        if (f < vMin[j])
-          vMin[j] = f;
-        if (f > vMax[j])
-          vMax[j] = f;
-      }
-    }
-  }
+	this->bDirty = true;
+	for (int w = 0; w < this->width; w++)
+	{
+		for (int h = 0; h < this->height; h++)
+		{
+			for (int j = 0; j < 3; j++)
+			{
+				float f = this->ctrl[w][h].xyz[j];
+				if (f < vMin[j])
+					vMin[j] = f;
+				if (f > vMax[j])
+					vMax[j] = f;
+			}
+		}
+	}
 }
 
 /*
@@ -410,38 +360,38 @@
 Brush_RebuildBrush
 ==================
 */
-void Brush_RebuildBrush(brush_t *b, vec3_t vMins, vec3_t vMaxs)
+void Brush_RebuildBrush(brush_s *b, vec3_t vMins, vec3_t vMaxs)
 {
-  //
-  // Total hack job 
-  // Rebuilds a brush
+	//
+	// Total hack job 
+	// Rebuilds a brush
 	int		i, j;
-	face_t	*f, *next;
+	face_s	*f, *next;
 	vec3_t	pts[4][2];
-  texdef_t	texdef;
+	texdef_t	texdef;
 	// free faces
 
-  for (j = 0; j < 3; j++)
-  {
-    if ((int)vMins[j] == (int)vMaxs[j])
-    {
-      vMins[j] -= 4;
-      vMaxs[j] += 4;
-    }
-  }
+	for (j = 0; j < 3; j++)
+	{
+		if ((int)vMins[j] == (int)vMaxs[j])
+		{
+			vMins[j] -= 4;
+			vMaxs[j] += 4;
+		}
+	}
 
-  
-  for (f=b->brush_faces ; f ; f=next)
+
+	for (f=b->brush_faces ; f ; f=next)
 	{
 		next = f->next;
-    if (f)
-      texdef = f->texdef;
-    Face_Free( f );
+		if (f)
+			texdef = f->texdef;
+		Face_Free( f );
 	}
 
-  b->brush_faces = NULL;
+	b->brush_faces = NULL;
 
-  // left the last face so we can use its texdef
+	// left the last face so we can use its texdef
 
 	for (i=0 ; i<3 ; i++)
 		if (vMaxs[i] < vMins[i])
@@ -449,16 +399,16 @@
 
 	pts[0][0][0] = vMins[0];
 	pts[0][0][1] = vMins[1];
-	
+
 	pts[1][0][0] = vMins[0];
 	pts[1][0][1] = vMaxs[1];
-	
+
 	pts[2][0][0] = vMaxs[0];
 	pts[2][0][1] = vMaxs[1];
-	
+
 	pts[3][0][0] = vMaxs[0];
 	pts[3][0][1] = vMins[1];
-	
+
 	for (i=0 ; i<4 ; i++)
 	{
 		pts[i][0][2] = vMins[2];
@@ -481,11 +431,11 @@
 		b->brush_faces = f;
 		j = (i+1)%4;
 
-		 f->planepts[0] = pts[j][1];
+		f->planepts[0] = pts[j][1];
 		f->planepts[1] = pts[i][1];
 		f->planepts[2] = pts[i][0];
 	}
-	
+
 	f = Face_Alloc();
 	f->texdef = texdef;
 	f->texdef.flags &= ~SURF_KEEP;
@@ -516,15 +466,15 @@
 	f->planepts[1] = pts[1][0];
 	f->planepts[2] = pts[0][0];
 
-  Brush_Build(b);
+	Brush_Build(b);
 }
 
-void WINAPI Patch_Rebuild(patchMesh_t *p)
+void patchMesh_c::rebuildPatch()
 {
-  edVec3_c vMin, vMax;
-  Patch_CalcBounds(p, vMin, vMax);
-  Brush_RebuildBrush(p->pSymbiot, vMin, vMax);
-  p->bDirty = true;
+	edVec3_c vMin, vMax;
+	this->calcPatchBounds(vMin, vMax);
+	Brush_RebuildBrush(this->pSymbiot, vMin, vMax);
+	this->bDirty = true;
 }
 
 /*
@@ -533,11 +483,11 @@
 ==================
  adds a patch brush and ties it to this patch id
 */
-brush_t* AddBrushForPatch(patchMesh_t *pm, bool bLinkToWorld )
+brush_s* AddBrushForPatch(patchMesh_c *pm, bool bLinkToWorld )
 {
   // find the farthest points in x,y,z
   edVec3_c vMin, vMax;
-  Patch_CalcBounds(pm, vMin, vMax);
+  pm->calcPatchBounds(vMin, vMax);
 
   for (int j = 0; j < 3; j++)
   {
@@ -548,8 +498,8 @@
     }
   }
 
-  brush_t *b = Brush_Create(vMin, vMax, &g_qeglobals.d_texturewin.texdef);
-	face_t		*f;
+  brush_s *b = Brush_Create(vMin, vMax, &g_qeglobals.d_texturewin.texdef);
+	face_s		*f;
 	for (f=b->brush_faces ; f ; f=f->next) 
   {
 		f->texdef.flags |= SURF_PATCH; 
@@ -573,20 +523,6 @@
   return b;
 }
 
-void Patch_SetPointIntensities(int n)
-{
-#if 0
-	patchMesh_t	*p = patchMeshes[n];
-  for (int i = 0; i < p->width; i++)
-  {
-    for (int j = 0; j < p->height; j++)
-    {
-
-    }
-  }
-#endif
-}
-
 // very approximate widths and heights
 
 /*
@@ -594,28 +530,28 @@
 Patch_Width
 ==================
 */
-float Patch_Width(patchMesh_t *p)
+float patchMesh_c::calcPatchWidth()
 {
-  float f = 0;
-  for (int i = 0; i < p->width-1; i++)
-  {
-    edVec3_c vTemp;
-    vTemp = p->ctrl[i][0].xyz - p->ctrl[i+1][0].xyz;
-    f += vTemp.vectorLength();
-  }
-  return f;
+	float f = 0;
+	for (int i = 0; i < this->width-1; i++)
+	{
+		edVec3_c vTemp;
+		vTemp = this->ctrl[i][0].xyz - this->ctrl[i+1][0].xyz;
+		f += vTemp.vectorLength();
+	}
+	return f;
 }
 
-float Patch_WidthDistanceTo(patchMesh_t *p, int j)
+float patchMesh_c::calcPatchWidthDistanceTo(int j)
 {
-  float f = 0;
-  for (int i = 0; i < j; i++)
-  {
-    edVec3_c vTemp;
-    vTemp = p->ctrl[i][0].xyz - p->ctrl[i+1][0].xyz;
-    f += vTemp.vectorLength();
-  }
-  return f;
+	float f = 0;
+	for (int i = 0; i < j; i++)
+	{
+		edVec3_c vTemp;
+		vTemp = this->ctrl[i][0].xyz - this->ctrl[i+1][0].xyz;
+		f += vTemp.vectorLength();
+	}
+	return f;
 }
 
 
@@ -625,28 +561,28 @@
 Patch_Height
 ==================
 */
-float Patch_Height(patchMesh_t *p)
+float patchMesh_c::calcPatchHeight()
 {
-  float f = 0;
-  for (int i = 0; i < p->height-1; i++)
-  {
-    edVec3_c vTemp;
-    vTemp = p->ctrl[0][i].xyz - p->ctrl[0][i+1].xyz;
-    f += vTemp.vectorLength();
-  }
-  return f;
+	float f = 0;
+	for (int i = 0; i < this->height-1; i++)
+	{
+		edVec3_c vTemp;
+		vTemp = this->ctrl[0][i].xyz - this->ctrl[0][i+1].xyz;
+		f += vTemp.vectorLength();
+	}
+	return f;
 }
 
-float Patch_HeightDistanceTo(patchMesh_t *p, int j)
+float patchMesh_c::calcPatchHeightDistanceTo(int j) 
 {
-  float f = 0;
-  for (int i = 0; i < j; i++)
-  {
-    edVec3_c vTemp;
-    vTemp = p->ctrl[0][i].xyz - p->ctrl[0][i+1].xyz;
-    f += vTemp.vectorLength();
-  }
-  return f;
+	float f = 0;
+	for (int i = 0; i < j; i++)
+	{
+		edVec3_c vTemp;
+		vTemp = this->ctrl[0][i].xyz - this->ctrl[0][i+1].xyz;
+		f += vTemp.vectorLength();
+	}
+	return f;
 }
 
 
@@ -659,50 +595,29 @@
 
 dist( this control point to first control point ) / dist ( last control pt to first)
 */
-void Patch_Naturalize(patchMesh_t *p)
+void patchMesh_c::naturalizePatch()
 {
-  int nWidth = p->d_texture->width * 0.5;
-  int nHeight = p->d_texture->height * 0.5 ;
-  float fPWidth = Patch_Width(p);
-  float fPHeight = Patch_Height(p);
-  float xAccum = 0;
-  for ( int i = 0 ; i < p->width ; i++ ) 
-  {
-    float yAccum = 0;
-	  for ( int j = 0 ; j < p->height ; j++ ) 
-    {
-		  p->ctrl[i][j].st[0] = (fPWidth / nWidth) * xAccum / fPWidth;
-		  p->ctrl[i][j].st[1] = (fPHeight / nHeight) * yAccum / fPHeight;
-		  yAccum = Patch_HeightDistanceTo(p,j+1);
-      //p->ctrl[i][j][3] = (fPWidth / nWidth) * (float)i / (p->width - 1);
-		  //p->ctrl[i][j][4] = (fPHeight/ nHeight) * (float)j / (p->height - 1);
-	  }
-    xAccum = Patch_WidthDistanceTo(p,i+1);
-  }
-  p->bDirty = true;
+	int nWidth = this->d_texture->width * 0.5;
+	int nHeight = this->d_texture->height * 0.5 ;
+	float fPWidth = this->calcPatchWidth();
+	float fPHeight = this->calcPatchHeight();
+	float xAccum = 0;
+	for ( int i = 0 ; i < this->width ; i++ ) 
+	{
+		float yAccum = 0;
+		for ( int j = 0 ; j < this->height ; j++ ) 
+		{
+			this->ctrl[i][j].st[0] = (fPWidth / nWidth) * xAccum / fPWidth;
+			this->ctrl[i][j].st[1] = (fPHeight / nHeight) * yAccum / fPHeight;
+			yAccum = this->calcPatchHeightDistanceTo(j+1);
+			//this->ctrl[i][j][3] = (fPWidth / nWidth) * (float)i / (this->width - 1);
+			//this->ctrl[i][j][4] = (fPHeight/ nHeight) * (float)j / (this->height - 1);
+		}
+		xAccum = this->calcPatchWidthDistanceTo(i+1);
+	}
+	this->bDirty = true;
 }
 
-/*
-  if (bIBevel)
-  {
-    VectorCopy(p->ctrl[1][0], p->ctrl[1][1]);
-  }
-
-  if (bIEndcap)
-  {
-    VectorCopy(p->ctrl[3][0], p->ctrl[4][1]);
-    VectorCopy(p->ctrl[2][0], p->ctrl[3][1]);
-    VectorCopy(p->ctrl[2][0], p->ctrl[2][1]);
-    VectorCopy(p->ctrl[2][0], p->ctrl[1][1]);
-    VectorCopy(p->ctrl[1][0], p->ctrl[0][1]);
-    VectorCopy(p->ctrl[1][0], p->ctrl[0][2]);
-    VectorCopy(p->ctrl[1][0], p->ctrl[1][2]);
-    VectorCopy(p->ctrl[2][0], p->ctrl[2][2]);
-    VectorCopy(p->ctrl[3][0], p->ctrl[3][2]);
-    VectorCopy(p->ctrl[3][0], p->ctrl[4][2]);
-  }
-*/
-
 int Index3By[][2] =
 {
   {0,0},
@@ -765,40 +680,40 @@
 int Interior3ByCount = sizeof(Interior3By) / sizeof(int[2]);
 int Interior5ByCount = sizeof(Interior5By) / sizeof(int[2]);
 
-face_t* Patch_GetAxisFace(patchMesh_t *p)
+face_s* Patch_GetAxisFace(patchMesh_c *p)
 {
-  face_t *f = NULL;
-  edVec3_c vTemp;
-  brush_t *b = p->pSymbiot;
+	face_s *f = NULL;
+	edVec3_c vTemp;
+	brush_s *b = p->pSymbiot;
 
 	for (f = b->brush_faces ; f ; f = f->next) 
-  {
-    vTemp = f->face_winding->points[1].getXYZ() - f->face_winding->points[0].getXYZ();
-    int nScore = 0;
+	{
+		vTemp = f->face_winding->points[1].getXYZ() - f->face_winding->points[0].getXYZ();
+		int nScore = 0;
 
-    // default edge faces on caps are 8 high so
-    // as soon as we hit one that is bigger it should be on the right axis
-    for (int j = 0; j < 3; j++)
-    {
-      if (vTemp[j] > 8)
-        nScore++;
-    }
+		// default edge faces on caps are 8 high so
+		// as soon as we hit one that is bigger it should be on the right axis
+		for (int j = 0; j < 3; j++)
+		{
+			if (vTemp[j] > 8)
+				nScore++;
+		}
 
-    if (nScore > 0)
-      break;
-  }
+		if (nScore > 0)
+			break;
+	}
 
-  if (f == NULL)
-    f = b->brush_faces;
-  return f;
+	if (f == NULL)
+		f = b->brush_faces;
+	return f;
 }
 
 int g_nFaceCycle = 0;
 
-face_t* nextFace(patchMesh_t *p)
+face_s* nextFace(patchMesh_c *p)
 {
-  brush_t *b = p->pSymbiot;
-  face_t *f = NULL;
+  brush_s *b = p->pSymbiot;
+  face_s *f = NULL;
   int n = 0;
 	for (f = b->brush_faces ; f && n <= g_nFaceCycle; f = f->next) 
   {
@@ -815,12 +730,12 @@
 }
 
 
-///extern void EmitTextureCoordinates ( texturedVertex_c & xyzst, qtexture_t *q, face_t *f);
+///extern void EmitTextureCoordinates ( texturedVertex_c & xyzst, qtexture_t *q, face_s *f);
 
-void Patch_CapTexture(patchMesh_t *p, bool bFaceCycle = false)
+void Patch_CapTexture(patchMesh_c *p, bool bFaceCycle = false)
 {
-  Patch_MeshNormals(p);
-  face_t *f = (bFaceCycle) ? nextFace(p) : Patch_GetAxisFace(p);
+	p->meshNormals();
+  face_s *f = (bFaceCycle) ? nextFace(p) : Patch_GetAxisFace(p);
   edVec3_c vSave = f->plane.normal;
   float fRotate = f->texdef.rotate;
   f->texdef.rotate = 0;
@@ -855,21 +770,21 @@
   p->bDirty = true;
 }
 
-void FillPatch(patchMesh_t *p, vec3_t v)
+void patchMesh_c::fillPatch(vec3_t v)
 {
-  for (int i = 0; i < p->width; i++)
-  {
-    for (int j = 0; j < p->height; j++)
-    {
-     p->ctrl[i][j].xyz = v;
-    }
-  }
+	for (int i = 0; i < this->width; i++)
+	{
+		for (int j = 0; j < this->height; j++)
+		{
+			this->ctrl[i][j].xyz = v;
+		}
+	}
 }
 
-brush_t* Cap(patchMesh_t *pParent, bool bByColumn, bool bFirst)
+brush_s* Cap(patchMesh_c *pParent, bool bByColumn, bool bFirst)
 {
-  brush_t *b;
-  patchMesh_t *p;
+  brush_s *b;
+  patchMesh_c *p;
   vec3_t vMin, vMax;
   int i, j;
 
@@ -902,7 +817,7 @@
   int nSize = (bByColumn) ? pParent->width : pParent->height;
   int nIndex = (bFirst) ? 0 : (bByColumn) ? pParent->height-1 : pParent->width-1;
 
-  FillPatch(p, pParent->ctrl[0][nIndex].xyz);
+  p->fillPatch(pParent->ctrl[0][nIndex].xyz);
 
   for (i = 0; i < nSize; i++)
   {
@@ -972,15 +887,15 @@
     }
   }
 
-  Patch_Rebuild(p);
+  p->rebuildPatch();
   Patch_CapTexture(p);
   return p->pSymbiot;
 }
 
-brush_t* CapSpecial(patchMesh_t *pParent, int nType, bool bFirst)
+brush_s* CapSpecial(patchMesh_c *pParent, int nType, bool bFirst)
 {
-  brush_t *b;
-  patchMesh_t *p;
+  brush_s *b;
+  patchMesh_c *p;
   edVec3_c vMin, vMax, vTemp;
   int i, j;
 
@@ -1005,7 +920,7 @@
   int nIndex = (bFirst) ? 0 : pParent->height-1;
 
   // parent bounds are used for some things
-  Patch_CalcBounds(pParent, vMin, vMax);
+  pParent->calcPatchBounds(vMin, vMax);
 
   for (j = 0; j < 3; j++)
   {
@@ -1109,9 +1024,7 @@
     }
   }
 
-  //--Patch_CalcBounds(p, vMin, vMax);
-  //--Brush_RebuildBrush(p->pSymbiot, vMin, vMax);
-  Patch_Rebuild(p);
+  p->rebuildPatch();
   Patch_CapTexture(p);
   return p->pSymbiot;
 }
@@ -1119,9 +1032,9 @@
 
 void Patch_CapCurrent(bool bInvertedBevel, bool bInvertedEndcap)
 {
-  patchMesh_t *pParent = NULL;
-  brush_t *b[4];
-  brush_t *pCap = NULL;
+  patchMesh_c *pParent = NULL;
+  brush_s *b[4];
+  brush_s *pCap = NULL;
   b[0] = b[1] = b[2] = b[3] = NULL;
   int nIndex = 0;
 
@@ -1132,7 +1045,7 @@
   }
 
 
-	for (brush_t *pb = selected_brushes.next ; pb != NULL && pb != &selected_brushes ; pb = pb->next)
+	for (brush_s *pb = selected_brushes.next ; pb != NULL && pb != &selected_brushes ; pb = pb->next)
 	{
     if (pb->patchBrush)
     {
@@ -1199,10 +1112,10 @@
           Select_Brush(b[nIndex]);
         }
       }
-      eclass_t *pecNew = Eclass_ForName("func_group", false);
+      eclass_s *pecNew = Eclass_ForName("func_group", false);
       if (pecNew)
       {
-        entity_t *e = Entity_Create(pecNew);
+        entity_s *e = Entity_Create(pecNew);
         SetKeyValue(e, "type", "patchCapped");
       }
     }
@@ -1212,16 +1125,16 @@
 
 //FIXME: Table drive all this crap
 //
-void GenerateEndCaps(brush_t *brushParent, bool bBevel, bool bEndcap, bool bInverted)
+void GenerateEndCaps(brush_s *brushParent, bool bBevel, bool bEndcap, bool bInverted)
 {
-  brush_t *b, *b2;
-  patchMesh_t *p, *p2, *pParent;
+  brush_s *b, *b2;
+  patchMesh_c *p, *p2, *pParent;
   edVec3_c vTemp, vMin, vMax;
   int i, j;
 
   pParent = brushParent->pPatch;
 
-  Patch_CalcBounds(pParent, vMin, vMax);
+  pParent->calcPatchBounds(vMin, vMax);
   // basically generate two endcaps, place them, and link the three brushes with a func_group
 
   if (pParent->width > 9)
@@ -1255,7 +1168,7 @@
     p->ctrl[Interior3By[i][0]][Interior3By[i][1]].xyz = vTemp;
   }
 
-  Patch_CalcBounds(p, vMin, vMax);
+  p->calcPatchBounds(vMin, vMax);
   Brush_RebuildBrush(p->pSymbiot, vMin, vMax);
   Select_Brush(p->pSymbiot);
   return;
@@ -1433,9 +1346,9 @@
     }
     //Select_Delete();
 
-    Patch_CalcBounds(p, vMin, vMax);
+    p->calcPatchBounds(vMin, vMax);
     Brush_RebuildBrush(p->pSymbiot, vMin, vMax);
-    Patch_CalcBounds(p2, vMin, vMax);
+    p2->calcPatchBounds(vMin, vMax);
     Brush_RebuildBrush(p2->pSymbiot, vMin, vMax);
     Select_Brush(p->pSymbiot);
     Select_Brush(p2->pSymbiot);
@@ -1456,8 +1369,8 @@
 */
 void Patch_BrushToMesh(bool bCone, bool bBevel, bool bEndcap, bool bSquare, int nHeight)
 {
-	brush_t		*b;
-	patchMesh_t	*p;
+	brush_s		*b;
+	patchMesh_c	*p;
 	int			i,j;
 
 	if (!QE_SingleBrush())
@@ -1552,7 +1465,7 @@
 		  p->ctrl[i][1].xyz[1] = ( p->ctrl[i][0].xyz[1] + p->ctrl[i][2].xyz[1] ) * 0.5;
 		  p->ctrl[i][1].xyz[2] = ( p->ctrl[i][0].xyz[2] + p->ctrl[i][2].xyz[2] ) * 0.5;
 	  }
-	  InterpolateInteriorPoints( p );
+	  p->interpolateInteriorPoints();
 
     if (bSquare)
     {
@@ -1595,7 +1508,7 @@
   }
 
 
-  Patch_Naturalize(p);
+  p->naturalizePatch();
 
   if (bCone)
   {
@@ -1665,7 +1578,7 @@
     Select_Delete();
     Select_Brush(b);
     GenerateEndCaps(b, bBevel, bEndcap, bInverted);
-    eclass_t *pecNew = Eclass_ForName("func_group", false);
+    eclass_s *pecNew = Eclass_ForName("func_group", false);
     if (pecNew)
     {
       Entity_Create(pecNew);
@@ -1685,73 +1598,73 @@
 Patch_GenericMesh
 ==================
 */
-brush_t* Patch_GenericMesh(int nWidth, int nHeight, int nOrientation, bool bDeleteSource, bool bOverride)
+brush_s* Patch_GenericMesh(int nWidth, int nHeight, int nOrientation, bool bDeleteSource, bool bOverride)
 {
-  int i,j;
+	int i,j;
 
-  if (nHeight < 3 || nHeight > 15 || nWidth < 3 || nWidth > 15)
-  {
-    Sys_Printf("Invalid patch width or height.\n");
-    return NULL;
-  }
+	if (nHeight < 3 || nHeight > 15 || nWidth < 3 || nWidth > 15)
+	{
+		Sys_Printf("Invalid patch width or height.\n");
+		return NULL;
+	}
 
 	if (! bOverride && !QE_SingleBrush())
-  {
-    Sys_Printf("Cannot generate a patch from multiple selections.\n");
+	{
+		Sys_Printf("Cannot generate a patch from multiple selections.\n");
 		return NULL;
-  }
+	}
 
 
 
-  patchMesh_t* p = MakeNewPatch();
+	patchMesh_c* p = MakeNewPatch();
 	p->d_texture = Texture_ForName(g_qeglobals.d_texturewin.texdef.name);
 
 	p->width = nWidth;
 	p->height = nHeight;
-  p->type = PATCH_GENERIC;
+	p->type = PATCH_GENERIC;
 
-  int nFirst = 0;
-  int nSecond = 1;
-  if (nOrientation == 0)
-  {
-    nFirst = 1;
-    nSecond = 2;
-  }
-  else if (nOrientation == 1)
-  {
-    nSecond = 2;
-  }
+	int nFirst = 0;
+	int nSecond = 1;
+	if (nOrientation == 0)
+	{
+		nFirst = 1;
+		nSecond = 2;
+	}
+	else if (nOrientation == 1)
+	{
+		nSecond = 2;
+	}
 
-	brush_t *b = selected_brushes.next;
+	brush_s *b = selected_brushes.next;
 
-  int xStep = b->getMins()[nFirst];
-  float xAdj = abs((b->getMaxs()[nFirst] - b->getMins()[nFirst]) / (nWidth - 1));
-  float yAdj = abs((b->getMaxs()[nSecond] - b->getMins()[nSecond]) / (nHeight - 1));
+	int xStep = b->getMins()[nFirst];
+	float xAdj = abs((b->getMaxs()[nFirst] - b->getMins()[nFirst]) / (nWidth - 1));
+	float yAdj = abs((b->getMaxs()[nSecond] - b->getMins()[nSecond]) / (nHeight - 1));
 
-  for (i = 0; i < nWidth; i++)
-  {
-    int yStep = b->getMins()[nSecond];
-    for (j = 0; j < nHeight; j++)
-    {
-      p->ctrl[i][j].xyz[nFirst] = xStep;
-      p->ctrl[i][j].xyz[nSecond] = yStep;
-      p->ctrl[i][j].xyz[nOrientation] = 0;
-      yStep += yAdj;
-    }
-    xStep += xAdj;
-  }
+	for (i = 0; i < nWidth; i++)
+	{
+		int yStep = b->getMins()[nSecond];
+		for (j = 0; j < nHeight; j++)
+		{
+			p->ctrl[i][j].xyz[nFirst] = xStep;
+			p->ctrl[i][j].xyz[nSecond] = yStep;
+			p->ctrl[i][j].xyz[nOrientation] = 0;
+			yStep += yAdj;
+		}
+		xStep += xAdj;
+	}
 
-  Patch_Naturalize(p);
+	p->naturalizePatch();
 
-  b = AddBrushForPatch(p);
-  if (bDeleteSource)
-  {
-    Select_Delete();
-    Select_Brush(b);
-  }
+	b = AddBrushForPatch(p);
+	if (bDeleteSource)
+	{
+		Select_Delete();
+		Select_Brush(b);
+	}
 
-  return b;
-  //g_qeglobals.d_select_mode = sel_curvepoint;
+	return b;
+	//g_qeglobals.d_select_mode = sel_curvepoint;
 }
 
 /*
@@ -1761,12 +1674,12 @@
 */
 int PointInMoveList(float *pf)
 {
-  for (int i = 0; i < g_qeglobals.d_num_move_points; i++)
-  {
-    if (pf == &g_qeglobals.d_move_points[i][0])
-      return i;
-  }
-  return -1;
+	for (int i = 0; i < g_qeglobals.d_num_move_points; i++)
+	{
+		if (pf == &g_qeglobals.d_move_points[i][0])
+			return i;
+	}
+	return -1;
 }
 
 /*
@@ -1776,12 +1689,12 @@
 */
 int PointValueInMoveList(const edVec3_c &v)
 {
-  for (int i = 0; i < g_qeglobals.d_num_move_points; i++)
-  {
-    if (v.vectorCompare(g_qeglobals.d_move_points[i]))
-      return i;
-  }
-  return -1;
+	for (int i = 0; i < g_qeglobals.d_num_move_points; i++)
+	{
+		if (v.vectorCompare(g_qeglobals.d_move_points[i]))
+			return i;
+	}
+	return -1;
 }
 
 
@@ -1792,15 +1705,15 @@
 */
 void RemovePointFromMoveList(const edVec3_c &v)
 {
-  int n;
-  while ( (n = PointValueInMoveList(v)) >= 0)
-  {
-    for (int i = n; i < g_qeglobals.d_num_move_points-1; i++)
-    {
-      g_qeglobals.d_move_points[i] = g_qeglobals.d_move_points[i+1];
-    }
-    g_qeglobals.d_num_move_points--;
-  }
+	int n;
+	while ( (n = PointValueInMoveList(v)) >= 0)
+	{
+		for (int i = n; i < g_qeglobals.d_num_move_points-1; i++)
+		{
+			g_qeglobals.d_move_points[i] = g_qeglobals.d_move_points[i+1];
+		}
+		g_qeglobals.d_num_move_points--;
+	}
 }
 
 /*
@@ -1808,14 +1721,14 @@
 ColumnSelected
 ==================
 */
-bool ColumnSelected(patchMesh_t* p, int nCol)
+bool ColumnSelected(patchMesh_c* p, int nCol)
 {
-  for (int i = 0; i < p->height; i++)
-  {
-    if (PointInMoveList(p->ctrl[nCol][i].xyz) == -1)
-      return false;
-  }
-  return true;
+	for (int i = 0; i < p->height; i++)
+	{
+		if (PointInMoveList(p->ctrl[nCol][i].xyz) == -1)
+			return false;
+	}
+	return true;
 }
 
 /*
@@ -1832,7 +1745,7 @@
 			
 	return true;
 }
-void AddPoint(patchMesh_t* p, vec3_t v, bool bWeldOrDrill = true)
+void AddPoint(patchMesh_c* p, vec3_t v, bool bWeldOrDrill = true)
 {
   int nDim1 = (g_pParentWnd->ActiveXY()->GetViewType() == YZ) ? 1 : 0;
   int nDim2 = (g_pParentWnd->ActiveXY()->GetViewType() == XY) ? 1 : 2;
@@ -1928,15 +1841,15 @@
 SelectRow
 ==================
 */
-void SelectRow(patchMesh_t* p, int nRow, bool bMulti)
+void SelectRow(patchMesh_c* p, int nRow, bool bMulti)
 {
-  if (!bMulti)
-    g_qeglobals.d_num_move_points = 0;
-  for (int i = 0; i < p->width; i++)
-  {
-    AddPoint(p, p->ctrl[i][nRow].xyz, false);
-  }
-  //Sys_Printf("Selected Row %d\n", nRow);
+	if (!bMulti)
+		g_qeglobals.d_num_move_points = 0;
+	for (int i = 0; i < p->width; i++)
+	{
+		AddPoint(p, p->ctrl[i][nRow].xyz, false);
+	}
+	//Sys_Printf("Selected Row %d\n", nRow);
 }
 
 /*
@@ -1944,15 +1857,15 @@
 SelectColumn
 ==================
 */
-void SelectColumn(patchMesh_t* p, int nCol, bool bMulti)
+void SelectColumn(patchMesh_c* p, int nCol, bool bMulti)
 {
-  if (!bMulti)
-    g_qeglobals.d_num_move_points = 0;
-  for (int i = 0; i < p->height; i++)
-  {
-    AddPoint(p, p->ctrl[nCol][i].xyz, false);
-  }
-  //Sys_Printf("Selected Col %d\n", nCol);
+	if (!bMulti)
+		g_qeglobals.d_num_move_points = 0;
+	for (int i = 0; i < p->height; i++)
+	{
+		AddPoint(p, p->ctrl[nCol][i].xyz, false);
+	}
+	//Sys_Printf("Selected Col %d\n", nCol);
 }
 
 
@@ -1963,64 +1876,64 @@
 */
 void AddPatchMovePoint(const edVec3_c &v, bool bMulti, bool bFull)
 {
-  if (!g_bSameView && !bMulti && !bFull)
-  {
-    g_bSameView = true;
-    return;
-  }
+	if (!g_bSameView && !bMulti && !bFull)
+	{
+		g_bSameView = true;
+		return;
+	}
 
-	for (brush_t *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
+	for (brush_s *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
 	{
-    if (pb->patchBrush)
-    {
-	    patchMesh_t* p = pb->pPatch;
-	    for ( int i = 0 ; i < p->width ; i++ ) 
-      {
-		    for ( int j = 0 ; j < p->height ; j++ ) 
-        {
-          if (v.vectorCompare(p->ctrl[i][j].xyz))
-          {
-            if (PointInMoveList(p->ctrl[i][j].xyz) == -1)
-            {
-              if (bFull)        // if we want the full row/col this is on
-              {
-                SelectColumn(p, i, bMulti);
-              }
-              else
-              {
-                if (!bMulti)
-                  g_qeglobals.d_num_move_points = 0;
-                AddPoint(p, p->ctrl[i][j].xyz);
-                //Sys_Printf("Selected col:row %d:%d\n", i, j);
-              }
-              //--if (!bMulti)
-              return;
-            }
-            else
-            {
-              if (bFull)
-              {
-                if (ColumnSelected(p, i))
-                {
-                  SelectRow(p, j, bMulti);
-                }
-                else
-                {
-                  SelectColumn(p, i, bMulti);
-                }
-                return;
-              }
-              if (g_bSameView)
-              {
-                RemovePointFromMoveList(v);
-                return;
-              }
-            }
-          }
-		    }
-	    }
-    }
-  }
+		if (pb->patchBrush)
+		{
+			patchMesh_c* p = pb->pPatch;
+			for ( int i = 0 ; i < p->width ; i++ ) 
+			{
+				for ( int j = 0 ; j < p->height ; j++ ) 
+				{
+					if (v.vectorCompare(p->ctrl[i][j].xyz))
+					{
+						if (PointInMoveList(p->ctrl[i][j].xyz) == -1)
+						{
+							if (bFull)        // if we want the full row/col this is on
+							{
+								SelectColumn(p, i, bMulti);
+							}
+							else
+							{
+								if (!bMulti)
+									g_qeglobals.d_num_move_points = 0;
+								AddPoint(p, p->ctrl[i][j].xyz);
+							//Sys_Printf("Selected col:row %d:%d\n", i, j);
+							}
+							//--if (!bMulti)
+								return;
+						}
+						else
+						{
+							if (bFull)
+							{
+								if (ColumnSelected(p, i))
+								{
+									SelectRow(p, j, bMulti);
+								}
+								else
+								{
+									SelectColumn(p, i, bMulti);
+								}
+								return;
+							}
+							if (g_bSameView)
+							{
+								RemovePointFromMoveList(v);
+								return;
+							}
+						}
+					}
+				}
+			}
+		}
+	}
 }
 
 /*
@@ -2039,12 +1952,12 @@
     }
   }
 
-	//--patchMesh_t* p = &patchMeshes[g_nSelectedPatch];
-	for (brush_t *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
+	//--patchMesh_c* p = &patchMeshes[g_nSelectedPatch];
+	for (brush_s *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
 	{
     if (pb->patchBrush)
     {
-	    patchMesh_t* p = pb->pPatch;
+	    patchMesh_c* p = pb->pPatch;
 
 
       g_qeglobals.d_numpoints = 0;
@@ -2061,7 +1974,7 @@
       }
 	    
       edVec3_c vMin, vMax;
-      Patch_CalcBounds(p, vMin, vMax);
+      p->calcPatchBounds(vMin, vMax);
       Brush_RebuildBrush(p->pSymbiot, vMin, vMax);
     }
   }
@@ -2083,9 +1996,9 @@
 
 	// find the control points for the v coordinate
 	for (vPoint = 0 ; vPoint < 3 ; vPoint++) 
-  {
+	{
 		for (axis = 0 ; axis < 5 ; axis++) 
-    {
+		{
 			float	a, b, c;
 			float	qA, qB, qC;
 
@@ -2102,7 +2015,7 @@
 
 	// interpolate the v value
 	for (axis = 0 ; axis < 5 ; axis++) 
-  {
+	{
 		float	a, b, c;
 		float	qA, qB, qC;
 
@@ -2129,58 +2042,27 @@
 	float	verts[CBLOCK_SUBDIVISIONS+1][CBLOCK_SUBDIVISIONS+1][5];
 
 	for (i = 0 ; i <= CBLOCK_SUBDIVISIONS ; i++) 
-  {
+	{
 		for (j = 0 ; j <= CBLOCK_SUBDIVISIONS ; j++) 
-    {
+		{
 			u = (float)i / CBLOCK_SUBDIVISIONS;
 			v = (float)j / CBLOCK_SUBDIVISIONS;
 			SampleSinglePatch (ctrl, u, v, verts[i][j]);
 		}
 	}
-  // at this point we have 
-
-  int nCount = -1;
+	// at this point we have 
 	for (i = 0 ; i < CBLOCK_SUBDIVISIONS ; i++) 
-  {
-    qglBegin (GL_QUAD_STRIP);
+	{
+		qglBegin (GL_QUAD_STRIP);
 
 		for (j = 0 ; j <= CBLOCK_SUBDIVISIONS ; j++) 
-    {
+		{
 			qglTexCoord2fv( verts[i+1][j] + 3 );
 			qglVertex3fv( verts[i+1][j] );
-/*
-      if (nCount >= 0)
-      {
-        VectorCopy(verts[i+1][j], vNormals[nCount]);
-      }
-      nCount++;
-      if (nCount == 3)
-      {
-        VectorSubtract(vNormals[0], vNormals[1], vNormals[0]);
-        VectorSubtract(vNormals[1], vNormals[2], vNormals[1]);
-        CrossProduct(vNormals[0], vNormals[1], vNormals[2]);
-        //VectorNormalize(vNormals[2]);
-        qglNormal3fv(vNormals[2]);
-        nCount = -1;
-      }
-*/
-      qglTexCoord2fv( verts[i][j] + 3 );
+			qglTexCoord2fv( verts[i][j] + 3 );
 			qglVertex3fv( verts[i][j] );
-/*
-      VectorCopy(verts[i][j], vNormals[nCount]);
-      nCount++;
-      if (nCount == 3)
-      {
-        VectorSubtract(vNormals[0], vNormals[1], vNormals[0]);
-        VectorSubtract(vNormals[1], vNormals[2], vNormals[1]);
-        CrossProduct(vNormals[0], vNormals[1], vNormals[2]);
-        //VectorNormalize(vNormals[2]);
-        qglNormal3fv(vNormals[2]);
-        nCount = -1;
-      }
-*/
 		}
-	  qglEnd ();
+		qglEnd ();
 	}
 
 }
@@ -2191,352 +2073,284 @@
 =================
 */
 //FIXME: this routine needs to be reorganized.. should be about 1/4 the size and complexity
-void DrawPatchMesh( patchMesh_t *pm, bool bPoints, bool bShade = false ) {
+void patchMesh_c::drawPatchMesh(bool bPoints, bool bShade) {
 	int		i, j, k, l;
 	float	ctrl[3][3][5];
 
-  bool bOverlay = pm->bOverlay;
+	bool bOverlay = this->bOverlay;
 	int nDrawMode = g_pParentWnd->GetCamera()->Camera().draw_mode;
 
-  //--float fColor[3];
-  //--if (bShade)
-  //--{
-  //--  face_t *f = pm->pSymbiot->brush_faces;
-  //--  _SetColor(f, fColor);
-  //--}
-  if (g_PrefsDlg.m_bDisplayLists)
-  {
-    if (pm->bDirty || pm->nListID <= 0)
-    {
-      if (pm->nListID <= 0)
-        pm->nListID = qglGenLists(1);
-      if (pm->nListID > 0)
-      {
-        qglNewList(pm->nListID, GL_COMPILE_AND_EXECUTE);
-      }
-      
+	if (g_PrefsDlg.m_bDisplayLists)
+	{
+	if (this->bDirty || this->nListID <= 0)
+	{
+	if (this->nListID <= 0)
+	this->nListID = qglGenLists(1);
+	if (this->nListID > 0)
+	{
+		qglNewList(this->nListID, GL_COMPILE_AND_EXECUTE);
+	}
 
 
-      if (pm->type != PATCH_TRIANGLE)
-      {
-        //vec3_t *vMeshData = new vec3_t[pm->width * pm->height];
 
-        // wasteful
-        if (g_PrefsDlg.m_bGLLighting)
-        {
-          Patch_MeshNormals(pm);
-          for (i = 0; i < pm->width; i++)
-          {
-            for (j = 0; j < pm->height; j++)
-            {
-              //VectorCopy(pm->ctrl[i][j].xyz, vMeshData[(j * pm->width) + i]);
-              qglNormal3fv(pm->ctrl[i][j].normal);
-            }
-          }
-        }
+	if (this->type != PATCH_TRIANGLE)
+	{
+		//vec3_t *vMeshData = new vec3_t[this->width * this->height];
+		for ( i = 0 ; i + 2 < this->width ; i += 2 ) 
+		{
+			for ( j = 0 ; j + 2 < this->height ; j += 2 ) 
+			{
+				for ( k = 0 ; k < 3 ; k++ ) 
+				{
+					vec3_t vAvg;
+					vAvg[0] = vAvg[1] = vAvg[2] = 0;
+					for ( l = 0 ; l < 3 ; l++ ) 
+					{
+						ctrl[k][l][0] = this->ctrl[ i + k ][ j + l ].xyz[ 0 ];
+						ctrl[k][l][1] = this->ctrl[ i + k ][ j + l ].xyz[ 1 ];
+						ctrl[k][l][2] = this->ctrl[ i + k ][ j + l ].xyz[ 2 ];
+						ctrl[k][l][3] = this->ctrl[ i + k ][ j + l ].xyz[ 3 ];
+						ctrl[k][l][4] = this->ctrl[ i + k ][ j + l ].xyz[ 4 ];
+					}
+				}
+				DrawSinglePatch( ctrl, bPoints );
+			}
+		}
+	}
+	else
+	{
+		qglBegin (GL_TRIANGLES);
+		qglTexCoord2fv( this->ctrl[0][0].st);
+		qglVertex3fv( this->ctrl[0][0].xyz);
+		qglTexCoord2fv( this->ctrl[2][0].st);
+		qglVertex3fv( this->ctrl[2][0].xyz);
+		qglTexCoord2fv( this->ctrl[2][2].st);
+		qglVertex3fv( this->ctrl[2][2].xyz);
+		qglEnd();
+	}
 
-	      for ( i = 0 ; i + 2 < pm->width ; i += 2 ) 
-        {
-		      for ( j = 0 ; j + 2 < pm->height ; j += 2 ) 
-          {
+	if (this->nListID > 0)
+	{
+		qglEndList();
+		this->bDirty = false;
+	}
+	}
+	else
+	{
+		qglCallList(this->nListID);
+	}
+	}
+	else
+	{
+		for ( i = 0 ; i + 2 < this->width ; i += 2 ) 
+		{
+			for ( j = 0 ; j + 2 < this->height ; j += 2 ) 
+			{
+				for ( k = 0 ; k < 3 ; k++ ) 
+				{
+					for ( l = 0 ; l < 3 ; l++ ) 
+					{
+						ctrl[k][l][0] = this->ctrl[ i + k ][ j + l ].xyz[ 0 ];
+						ctrl[k][l][1] = this->ctrl[ i + k ][ j + l ].xyz[ 1 ];
+						ctrl[k][l][2] = this->ctrl[ i + k ][ j + l ].xyz[ 2 ];
+						ctrl[k][l][3] = this->ctrl[ i + k ][ j + l ].xyz[ 3 ];
+						ctrl[k][l][4] = this->ctrl[ i + k ][ j + l ].xyz[ 4 ];
+					}
+				}
+				DrawSinglePatch( ctrl, bPoints );
+			}
+		}
+	}
 
-			      for ( k = 0 ; k < 3 ; k++ ) 
-            {
-              vec3_t vAvg;
-              vAvg[0] = vAvg[1] = vAvg[2] = 0;
-				      for ( l = 0 ; l < 3 ; l++ ) 
-              {
-					      ctrl[k][l][0] = pm->ctrl[ i + k ][ j + l ].xyz[ 0 ];
-					      ctrl[k][l][1] = pm->ctrl[ i + k ][ j + l ].xyz[ 1 ];
-					      ctrl[k][l][2] = pm->ctrl[ i + k ][ j + l ].xyz[ 2 ];
-					      ctrl[k][l][3] = pm->ctrl[ i + k ][ j + l ].xyz[ 3 ];
-					      ctrl[k][l][4] = pm->ctrl[ i + k ][ j + l ].xyz[ 4 ];
+	vec3_t* pSelectedPoints[256];
+	int nIndex = 0;
 
-                if (g_PrefsDlg.m_bGLLighting)
-                {
-                  qglNormal3fv(pm->ctrl[i+k][j+l].normal);
-                }
-				      }
+	qglPushAttrib(GL_CURRENT_BIT);
+	//--qglDisable(GL_BLEND);
+	//--qglDisable (GL_DEPTH_TEST);
+	//qglDisable (GL_TEXTURE_2D);
 
-			      }
+	bool bDisabledLighting = qglIsEnabled(GL_LIGHTING);
+	if (bDisabledLighting)
+	{
+		qglDisable(GL_LIGHTING);
+	}
 
-//--            if (g_pParentWnd->GetCamera()->Camera().draw_mode == cd_texture)
-//--            {
-//--              VectorCopy(pm->ctrl[i][j].normal, plane.normal);
-//--              float shade = SetShadeForPlane(&plane);
-//--              qtexture_t *q = pm->d_texture;
-//--              vec3_t vColor;
-//--
-//--              vColor[0] = shade;// * q->color[0];
-//--              vColor[1] = shade;// * q->color[1];
-//--              vColor[2] = shade;// * q->color[2];
-//--              qglColor3fv(vColor);
-//--            }
 
-            
-//--            if (g_PrefsDlg.m_bGLLighting)
-//--            {
-//--              //qglNormal3fv(pm->ctrl[i][j].normal);
-//--            }
-            DrawSinglePatch( ctrl, bPoints );
-          }
-        }
+	// FIXME: this bend painting code needs to be rolled up significantly as it is a cluster fuck right now
+	if (bPoints && (g_qeglobals.d_select_mode == sel_curvepoint || g_qeglobals.d_select_mode == sel_area || g_bPatchBendMode || g_bPatchInsertMode))
+	{
+	bOverlay = false;
 
-        // we have an array of clean control points
-        //
-        /*
-        qglMap2f(GL_MAP2_NORMAL, 0, 1, 3, 3, 0, 1, 9, 3, (float*)&vMeshData);
-        for (i = 0; i < pm->width; i++)
-        {
-          for (j = 0; j < pm->height; j++)
-          {
-            qglEvalPoint2(i, j);
-          }
-        }
+	// bending or inserting
+	if (g_bPatchBendMode || g_bPatchInsertMode)
+	{
+	qglPointSize(6);
+	if (g_bPatchAxisOnRow)
+	{
+	qglColor3f(1, 0, 1);
+	qglBegin(GL_POINTS);
+	for (i = 0; i < this->width; i++)
+	{
+	qglVertex3fv(reinterpret_cast<float(*)>(&this->ctrl[i][g_nPatchAxisIndex].xyz));
+	}
+	qglEnd();
 
-        delete []vMeshData;
-        */
-      }
-      else
-      {
-        qglBegin (GL_TRIANGLES);
-   	    qglTexCoord2fv( pm->ctrl[0][0].st);
-			  qglVertex3fv( pm->ctrl[0][0].xyz);
-			  qglTexCoord2fv( pm->ctrl[2][0].st);
-			  qglVertex3fv( pm->ctrl[2][0].xyz);
-			  qglTexCoord2fv( pm->ctrl[2][2].st);
-			  qglVertex3fv( pm->ctrl[2][2].xyz);
-        qglEnd();
-      }
+	// could do all of this in one loop but it was pretty messy
+	if (g_bPatchInsertMode)
+	{
+		qglColor3f(0, 0, 1);
+		qglBegin(GL_POINTS);
+		for (i = 0; i < this->width; i++)
+		{
+			qglVertex3fv(reinterpret_cast<float(*)>(&this->ctrl[i][g_nPatchAxisIndex].xyz));
+			qglVertex3fv(reinterpret_cast<float(*)>(&this->ctrl[i][g_nPatchAxisIndex+1].xyz));
+		}
+		qglEnd();
+	}
+	else
+	{
+	if (g_nPatchBendState == BEND_SELECT_EDGE || g_nPatchBendState == BEND_BENDIT || g_nPatchBendState == BEND_SELECT_ORIGIN)
+	{
+	qglColor3f(0, 0, 1);
+	qglBegin(GL_POINTS);
+	if (g_nPatchBendState == BEND_SELECT_ORIGIN)
+	{
+		qglVertex3fv(g_vBendOrigin);
+	}
+	else
+	{
+	for (i = 0; i < this->width; i++)
+	{
+	if (g_bPatchLowerEdge)
+	{
+	for (j = 0; j < g_nPatchAxisIndex; j++)
+	qglVertex3fv(reinterpret_cast<float(*)>(&this->ctrl[i][j].xyz));
+	}
+	else
+	{
+	for (j = this->height-1; j > g_nPatchAxisIndex; j--)
+	qglVertex3fv(reinterpret_cast<float(*)>(&this->ctrl[i][j].xyz));
+	}
+	}
+	}
+	qglEnd();
+	}
+	}
+	}
+	else
+	{
+	qglColor3f(1, 0, 1);
+	qglBegin(GL_POINTS);
+	for (i = 0; i < this->height; i++)
+	{
+		qglVertex3fv(reinterpret_cast<float(*)>(&this->ctrl[g_nPatchAxisIndex][i].xyz));
+	}
+	qglEnd();
 
-      if (pm->nListID > 0)
-      {
-        qglEndList();
-        pm->bDirty = false;
-      }
-    }
-    else
-    {
-      qglCallList(pm->nListID);
-    }
-  }
-  else
-  {
-	  for ( i = 0 ; i + 2 < pm->width ; i += 2 ) 
-    {
-		  for ( j = 0 ; j + 2 < pm->height ; j += 2 ) 
-      {
-			  for ( k = 0 ; k < 3 ; k++ ) 
-        {
-				  for ( l = 0 ; l < 3 ; l++ ) 
-          {
-					  ctrl[k][l][0] = pm->ctrl[ i + k ][ j + l ].xyz[ 0 ];
-					  ctrl[k][l][1] = pm->ctrl[ i + k ][ j + l ].xyz[ 1 ];
-					  ctrl[k][l][2] = pm->ctrl[ i + k ][ j + l ].xyz[ 2 ];
-					  ctrl[k][l][3] = pm->ctrl[ i + k ][ j + l ].xyz[ 3 ];
-					  ctrl[k][l][4] = pm->ctrl[ i + k ][ j + l ].xyz[ 4 ];
-				  }
-			  }
-        //--if (bShade)
-        //--{
-        //--  _DecColor(fColor);
-        //--}
-			  DrawSinglePatch( ctrl, bPoints );
-      }
-    }
-  }
+	// could do all of this in one loop but it was pretty messy
+	if (g_bPatchInsertMode)
+	{
+		qglColor3f(0, 0, 1);
+		qglBegin(GL_POINTS);
+		for (i = 0; i < this->height; i++)
+		{
+			qglVertex3fv(reinterpret_cast<float(*)>(&this->ctrl[g_nPatchAxisIndex][i].xyz));
+			qglVertex3fv(reinterpret_cast<float(*)>(&this->ctrl[g_nPatchAxisIndex+1][i].xyz));
+		}
+		qglEnd();
+	}
+	else
+	{
+		if (g_nPatchBendState == BEND_SELECT_EDGE || g_nPatchBendState == BEND_BENDIT || g_nPatchBendState == BEND_SELECT_ORIGIN)
+		{
+			qglColor3f(0, 0, 1);
+			qglBegin(GL_POINTS);
+			for (i = 0; i < this->height; i++)
+			{
+				if (g_nPatchBendState == BEND_SELECT_ORIGIN)
+				{
+					qglVertex3fv(reinterpret_cast<float(*)>(&this->ctrl[g_nBendOriginIndex][i].xyz));
+				}
+				else
+				{
+					if (g_bPatchLowerEdge)
+					{
+						for (j = 0; j < g_nPatchAxisIndex; j++)
+							qglVertex3fv(reinterpret_cast<float(*)>(&this->ctrl[j][i].xyz));
+					}
+						else
+						{
+							for (j = this->width-1; j > g_nPatchAxisIndex; j--)
+								qglVertex3fv(reinterpret_cast<float(*)>(&this->ctrl[j][i].xyz));
+						}
+					}
+				}
+				qglEnd();
+			}
+		}
+	}
+	}
+	else // just painting the grid for selection
+	{
+		qglPointSize(6);
+		for ( i = 0 ; i < this->width ; i++ )
+		{
+			for ( j = 0 ; j < this->height ; j++ ) 
+			{
+				qglBegin(GL_POINTS);
+				// FIXME: need to not do loop lookups inside here
+				int n = PointValueInMoveList(this->ctrl[i][j].xyz);
+				if (n >= 0)
+				{
+					pSelectedPoints[nIndex++] = reinterpret_cast<float(*)[3]>(&this->ctrl[i][j].xyz);
+				}
 
-  vec3_t* pSelectedPoints[256];
-  int nIndex = 0;
+				if (i & 0x01 || j & 0x01)
+					qglColor3f(1, 0, 1);
+				else
+					qglColor3f(0, 1, 0);
+				qglVertex3fv(this->ctrl[i][j].xyz);
+				qglEnd();
+			}
+		}
+	}
+	if (nIndex > 0)
+	{
+		qglBegin(GL_POINTS);
+		qglColor3f(0, 0, 1);
+		while (nIndex-- > 0)
+		{
+			qglVertex3fv(*pSelectedPoints[nIndex]);
+		}
+		qglEnd();
+	}
+	}
 
-  qglPushAttrib(GL_CURRENT_BIT);
-  //--qglDisable(GL_BLEND);
-  //--qglDisable (GL_DEPTH_TEST);
-  //qglDisable (GL_TEXTURE_2D);
+	if (bOverlay)
+	{
+		qglPointSize(6);
+		qglColor3f(0.5, 0.5, 0.5);
+		for ( i = 0 ; i < this->width ; i++ )
+		{
+			qglBegin(GL_POINTS);
+			for ( j = 0 ; j < this->height ; j++ ) 
+			{
+				if (i & 0x01 || j & 0x01)
+					qglColor3f(0.5, 0, 0.5);
+				else
+					qglColor3f(0, 0.5, 0);
+					qglVertex3fv(this->ctrl[i][j].xyz);
+			}
+			qglEnd();
+		}
+	}
 
-  bool bDisabledLighting = qglIsEnabled(GL_LIGHTING);
-  if (bDisabledLighting)
-  {
-    qglDisable(GL_LIGHTING);
-  }
+	if (bDisabledLighting)
+	{
+		qglEnable(GL_LIGHTING);
+	}
 
-
-  // FIXME: this bend painting code needs to be rolled up significantly as it is a cluster fuck right now
-  if (bPoints && (g_qeglobals.d_select_mode == sel_curvepoint || g_qeglobals.d_select_mode == sel_area || g_bPatchBendMode || g_bPatchInsertMode))
-  {
-    bOverlay = false;
-
-    // bending or inserting
-    if (g_bPatchBendMode || g_bPatchInsertMode)
-    {
-      qglPointSize(6);
-      if (g_bPatchAxisOnRow)
-      {
-        qglColor3f(1, 0, 1);
-        qglBegin(GL_POINTS);
-        for (i = 0; i < pm->width; i++)
-        {
-			    qglVertex3fv(reinterpret_cast<float(*)>(&pm->ctrl[i][g_nPatchAxisIndex].xyz));
-        }
-        qglEnd();
-      
-        // could do all of this in one loop but it was pretty messy
-        if (g_bPatchInsertMode)
-        {
-          qglColor3f(0, 0, 1);
-          qglBegin(GL_POINTS);
-          for (i = 0; i < pm->width; i++)
-          {
-			      qglVertex3fv(reinterpret_cast<float(*)>(&pm->ctrl[i][g_nPatchAxisIndex].xyz));
-			      qglVertex3fv(reinterpret_cast<float(*)>(&pm->ctrl[i][g_nPatchAxisIndex+1].xyz));
-          }
-          qglEnd();
-        }
-        else
-        {
-          if (g_nPatchBendState == BEND_SELECT_EDGE || g_nPatchBendState == BEND_BENDIT || g_nPatchBendState == BEND_SELECT_ORIGIN)
-          {
-            qglColor3f(0, 0, 1);
-            qglBegin(GL_POINTS);
-            if (g_nPatchBendState == BEND_SELECT_ORIGIN)
-            {
-              qglVertex3fv(g_vBendOrigin);
-            }
-            else
-            {
-              for (i = 0; i < pm->width; i++)
-              {
-                if (g_bPatchLowerEdge)
-                {
-                  for (j = 0; j < g_nPatchAxisIndex; j++)
-			              qglVertex3fv(reinterpret_cast<float(*)>(&pm->ctrl[i][j].xyz));
-                }
-                else
-                {
-                  for (j = pm->height-1; j > g_nPatchAxisIndex; j--)
-			              qglVertex3fv(reinterpret_cast<float(*)>(&pm->ctrl[i][j].xyz));
-                }
-              }
-            }
-            qglEnd();
-          }
-        }
-      }
-      else
-      {
-        qglColor3f(1, 0, 1);
-        qglBegin(GL_POINTS);
-        for (i = 0; i < pm->height; i++)
-        {
-			    qglVertex3fv(reinterpret_cast<float(*)>(&pm->ctrl[g_nPatchAxisIndex][i].xyz));
-        }
-        qglEnd();
-        
-        // could do all of this in one loop but it was pretty messy
-        if (g_bPatchInsertMode)
-        {
-          qglColor3f(0, 0, 1);
-          qglBegin(GL_POINTS);
-          for (i = 0; i < pm->height; i++)
-          {
-			      qglVertex3fv(reinterpret_cast<float(*)>(&pm->ctrl[g_nPatchAxisIndex][i].xyz));
-			      qglVertex3fv(reinterpret_cast<float(*)>(&pm->ctrl[g_nPatchAxisIndex+1][i].xyz));
-          }
-          qglEnd();
-        }
-        else
-        {
-          if (g_nPatchBendState == BEND_SELECT_EDGE || g_nPatchBendState == BEND_BENDIT || g_nPatchBendState == BEND_SELECT_ORIGIN)
-          {
-            qglColor3f(0, 0, 1);
-            qglBegin(GL_POINTS);
-            for (i = 0; i < pm->height; i++)
-            {
-              if (g_nPatchBendState == BEND_SELECT_ORIGIN)
-              {
-                qglVertex3fv(reinterpret_cast<float(*)>(&pm->ctrl[g_nBendOriginIndex][i].xyz));
-              }
-              else
-              {
-                if (g_bPatchLowerEdge)
-                {
-                  for (j = 0; j < g_nPatchAxisIndex; j++)
-			              qglVertex3fv(reinterpret_cast<float(*)>(&pm->ctrl[j][i].xyz));
-                }
-                else
-                {
-                  for (j = pm->width-1; j > g_nPatchAxisIndex; j--)
-			              qglVertex3fv(reinterpret_cast<float(*)>(&pm->ctrl[j][i].xyz));
-                }
-              }
-            }
-            qglEnd();
-          }
-        }
-      }
-    }
-    else // just painting the grid for selection
-    {
-      qglPointSize(6);
-	    for ( i = 0 ; i < pm->width ; i++ )
-      {
-		    for ( j = 0 ; j < pm->height ; j++ ) 
-        {
-	        qglBegin(GL_POINTS);
-          // FIXME: need to not do loop lookups inside here
-          int n = PointValueInMoveList(pm->ctrl[i][j].xyz);
-          if (n >= 0)
-          {
-            pSelectedPoints[nIndex++] = reinterpret_cast<float(*)[3]>(&pm->ctrl[i][j].xyz);
-          }
-
-          if (i & 0x01 || j & 0x01)
-            qglColor3f(1, 0, 1);
-          else
-            qglColor3f(0, 1, 0);
-			    qglVertex3fv(pm->ctrl[i][j].xyz);
-	        qglEnd();
-        }
-      }
-    }
-    if (nIndex > 0)
-    {
-      qglBegin(GL_POINTS);
-      qglColor3f(0, 0, 1);
-      while (nIndex-- > 0)
-      {
-			  qglVertex3fv(*pSelectedPoints[nIndex]);
-      }
-      qglEnd();
-    }
-  }
-
-  if (bOverlay)
-  {
-    qglPointSize(6);
-    qglColor3f(0.5, 0.5, 0.5);
-	  for ( i = 0 ; i < pm->width ; i++ )
-    {
-      qglBegin(GL_POINTS);
-		  for ( j = 0 ; j < pm->height ; j++ ) 
-      {
-			  if (i & 0x01 || j & 0x01)
-          qglColor3f(0.5, 0, 0.5);
-        else
-          qglColor3f(0, 0.5, 0);
-        qglVertex3fv(pm->ctrl[i][j].xyz);
-      }
-      qglEnd();
-    }
-  }
-	//--qglEnable (GL_TEXTURE_2D);
-	//--qglEnable (GL_DEPTH_TEST);
-
-  if (bDisabledLighting)
-  {
-    qglEnable(GL_LIGHTING);
-  }
-
 	qglPopAttrib();
 
 }
@@ -2546,25 +2360,18 @@
 Patch_DrawXY
 ==================
 */
-void Patch_DrawXY(patchMesh_t *pm)
+void patchMesh_c::drawPatchXY()
 {
 	qglPolygonMode (GL_FRONT_AND_BACK, GL_LINE);
-  if (pm->bSelected)
-  {
-    qglColor3fv(g_qeglobals.d_savedinfo.colors[COLOR_SELBRUSHES]);
-    //qglDisable (GL_LINE_STIPPLE);
-	  //qglLineWidth (1);
-  }
-  else
-    qglColor3fv(g_qeglobals.d_savedinfo.colors[COLOR_BRUSHES]);
+	if (this->bSelected)
+	{
+		qglColor3fv(g_qeglobals.d_savedinfo.colors[COLOR_SELBRUSHES]);
+	}
+	else
+		qglColor3fv(g_qeglobals.d_savedinfo.colors[COLOR_BRUSHES]);
 
-	DrawPatchMesh( pm , pm->bSelected );
+	this->drawPatchMesh(this->bSelected);
 	qglPolygonMode (GL_FRONT_AND_BACK, GL_FILL);
-  if (pm->bSelected)
-  {
-	  //qglLineWidth (2);
-    //qglEnable (GL_LINE_STIPPLE);
-  }
 }
 
 /*
@@ -2572,94 +2379,78 @@
 Patch_DrawCam
 ==================
 */
-void Patch_DrawCam(patchMesh_t *pm)
+void patchMesh_c::drawPatchCam()
 {
 	qglColor3f (1,1,1);
-  qglPushAttrib(GL_ALL_ATTRIB_BITS);
+	qglPushAttrib(GL_ALL_ATTRIB_BITS);
 
-  if (g_bPatchWireFrame)
-  {
-	  qglDisable( GL_CULL_FACE );
-	  qglPolygonMode (GL_FRONT_AND_BACK, GL_LINE);
-	  qglDisable(GL_TEXTURE_2D);
-    if (g_PrefsDlg.m_bGLLighting)
-    {
-      qglDisable(GL_LIGHTING);
-    }
-	  DrawPatchMesh( pm , pm->bSelected, true );
-    if (g_PrefsDlg.m_bGLLighting)
-    {
-      qglEnable(GL_LIGHTING);
-    }
-	  qglEnable( GL_CULL_FACE );
-  }
-  else
-  {
-    if (g_PrefsDlg.m_bGLLighting)
-    {
-      //qglEnable(GL_NORMALIZE);
-    }
-	  qglEnable( GL_CULL_FACE );
-    qglCullFace(GL_FRONT);
-    qglBindTexture (GL_TEXTURE_2D, pm->d_texture->texture_number);
+	if (g_bPatchWireFrame)
+	{
+		qglDisable( GL_CULL_FACE );
+		qglPolygonMode (GL_FRONT_AND_BACK, GL_LINE);
+		qglDisable(GL_TEXTURE_2D);
+		this->drawPatchMesh(this->bSelected, true );
+		qglEnable( GL_CULL_FACE );
+	}
+	else
+	{
+		qglEnable( GL_CULL_FACE );
+		qglCullFace(GL_FRONT);
+		qglBindTexture (GL_TEXTURE_2D, this->d_texture->texture_number);
 
-    if (pm->d_texture->bFromShader && pm->d_texture->fTrans < 1.0)
-    {
-	    //qglEnable ( GL_BLEND );
-	    //qglBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-      qglColor4f(pm->d_texture->color[0], pm->d_texture->color[1], pm->d_texture->color[2], pm->d_texture->fTrans); 
-    }
-    DrawPatchMesh( pm , pm->bSelected, true );
-    
-    qglCullFace(GL_BACK);
-	  //qglDisable(GL_TEXTURE_2D);
-	  qglPolygonMode (GL_FRONT_AND_BACK, GL_LINE);
+		if (this->d_texture->bFromShader && this->d_texture->fTrans < 1.0)
+		{
+			//qglEnable ( GL_BLEND );
+			//qglBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+			qglColor4f(this->d_texture->color[0], this->d_texture->color[1], this->d_texture->color[2], this->d_texture->fTrans); 
+		}
+		this->drawPatchMesh(this->bSelected, true );
 
-    qglDisable ( GL_BLEND );
-	  DrawPatchMesh( pm , pm->bSelected, true );
-  }
+		qglCullFace(GL_BACK);
+		//qglDisable(GL_TEXTURE_2D);
+		qglPolygonMode (GL_FRONT_AND_BACK, GL_LINE);
 
+		qglDisable ( GL_BLEND );
+		this->drawPatchMesh(this->bSelected, true );
+	}
+
 #if 0 // this paints normal indicators on the ctrl points
-      //--qglDisable (GL_DEPTH_TEST);
-      qglDisable (GL_TEXTURE_2D);
-      qglColor3f (1,1,1);
+//--qglDisable (GL_DEPTH_TEST);
+qglDisable (GL_TEXTURE_2D);
+qglColor3f (1,1,1);
 
-      for (int i = 0; i < pm->width; i++)
-      {
-        for (int j = 0; j < pm->height; j++)
-        {
-          vec3_t temp;
-	        qglBegin (GL_LINES);
-		      qglVertex3fv (pm->ctrl[i][j].xyz);
-		      VectorMA (pm->ctrl[i][j].xyz, 8, pm->ctrl[i][j].normal, temp);
-		      qglVertex3fv (temp);
-	        qglEnd ();
-        }
-      }
-      qglEnable (GL_TEXTURE_2D);
-      //--qglEnable (GL_DEPTH_TEST);
+for (int i = 0; i < this->width; i++)
+{
+for (int j = 0; j < this->height; j++)
+{
+vec3_t temp;
+qglBegin (GL_LINES);
+qglVertex3fv (this->ctrl[i][j].xyz);
+VectorMA (this->ctrl[i][j].xyz, 8, this->ctrl[i][j].normal, temp);
+qglVertex3fv (temp);
+qglEnd ();
+}
+}
+qglEnable (GL_TEXTURE_2D);
+//--qglEnable (GL_DEPTH_TEST);
 #endif
 
 
-  qglPopAttrib();
+	qglPopAttrib();
 }
 
 
 
 
-void ConvexHullForSection( float section[2][4][7] ) {
-}
 
-void BrushesForSection( float section[2][4][7] ) {
-}
 
 //
 //================
 //Patch_BuildPoints
 //================
-void Patch_BuildPoints (brush_t *b) 
+void Patch_BuildPoints (brush_s *b) 
 {
-	face_t		*f;
+	face_s		*f;
 	b->patchBrush = false;
 	for (f=b->brush_faces ; f ; f=f->next) 
   {
@@ -2730,24 +2521,23 @@
 Patch_Move
 ==================
 */
-void Patch_Move(patchMesh_t *pm, const vec3_t vMove, bool bRebuild)
+void patchMesh_c::movePatch(const vec3_t vMove, bool bRebuild)
 {
-  pm->bDirty = true;
-  for (int w = 0; w < pm->width; w++)
-  {
-    for (int h = 0; h < pm->height; h++)
-    {
-      pm->ctrl[w][h].xyz += vMove;
-    }
-  }
-  if (bRebuild)
-  {
-    edVec3_c vMin, vMax;
-    Patch_CalcBounds(pm, vMin, vMax);
-    //Brush_RebuildBrush(patchMeshes[n].pSymbiot, vMin, vMax);
-  }
-  UpdatePatchInspector();
-
+	this->bDirty = true;
+	for (int w = 0; w < this->width; w++)
+	{
+		for (int h = 0; h < this->height; h++)
+		{
+			this->ctrl[w][h].xyz += vMove;
+		}
+	}
+	if (bRebuild)
+	{
+		edVec3_c vMin, vMax;
+		this->calcPatchBounds(vMin, vMax);
+		//Brush_RebuildBrush(patchMeshes[n].pSymbiot, vMin, vMax);
+	}
+	UpdatePatchInspector();
 }
 
 /*
@@ -2755,7 +2545,7 @@
 Patch_ApplyMatrix
 ==================
 */
-void Patch_ApplyMatrix(patchMesh_t *p, const class edVec3_c &vOrigin, const edVec3_c vMatrix[3], bool bSnap)
+void Patch_ApplyMatrix(patchMesh_c *p, const class edVec3_c &vOrigin, const edVec3_c vMatrix[3], bool bSnap)
 {
   edVec3_c vTemp;
 
@@ -2778,7 +2568,7 @@
     }
   }
   edVec3_c vMin, vMax;
-  Patch_CalcBounds(p, vMin, vMax);
+  p->calcPatchBounds(vMin, vMax);
   Brush_RebuildBrush(p->pSymbiot, vMin, vMax);
 }
 
@@ -2789,30 +2579,29 @@
 */
 void Patch_EditPatch()
 {
-  //--patchMesh_t* p = &patchMeshes[n];
-  g_qeglobals.d_numpoints = 0;
-  g_qeglobals.d_num_move_points = 0;
-	
-  for (brush_t *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
+	g_qeglobals.d_numpoints = 0;
+	g_qeglobals.d_num_move_points = 0;
+
+	for (brush_s *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
 	{
-    if (pb->patchBrush)
-    {
-	    patchMesh_t* p = pb->pPatch;
-	    for ( int i = 0 ; i < p->width ; i++ ) 
-      {
-		    for ( int j = 0 ; j < p->height ; j++ ) 
-        {
-	        g_qeglobals.d_points[g_qeglobals.d_numpoints] = p->ctrl[i][j].xyz;
-          if (g_qeglobals.d_numpoints < MAX_POINTS-1)
-          {
-	          g_qeglobals.d_numpoints++;
-          }
-		    }
-      }
-    }
-  }
-  g_qeglobals.d_select_mode = sel_curvepoint;
-  //--g_nSelectedPatch = n;
+		if (pb->patchBrush)
+		{
+			patchMesh_c* p = pb->pPatch;
+			for ( int i = 0 ; i < p->width ; i++ ) 
+			{
+				for ( int j = 0 ; j < p->height ; j++ ) 
+				{
+					g_qeglobals.d_points[g_qeglobals.d_numpoints] = p->ctrl[i][j].xyz;
+					if (g_qeglobals.d_numpoints < MAX_POINTS-1)
+					{
+						g_qeglobals.d_numpoints++;
+					}
+				}
+			}
+		}
+	}
+	g_qeglobals.d_select_mode = sel_curvepoint;
+	//--g_nSelectedPatch = n;
 }
 
 
@@ -2825,24 +2614,24 @@
 //FIXME: need all sorts of asserts throughout a lot of this crap
 void Patch_Deselect()
 {
-  //--g_nSelectedPatch = -1;
+	//--g_nSelectedPatch = -1;
 	clearSelection();
 
-	for (brush_t *b = selected_brushes.next ; b != 0 && b != &selected_brushes ; b=b->next)
-  {
-    if (b->patchBrush)
-    {
-      b->pPatch->bSelected = false;
-    }
-  }
+	for (brush_s *b = selected_brushes.next ; b != 0 && b != &selected_brushes ; b=b->next)
+	{
+		if (b->patchBrush)
+		{
+			b->pPatch->bSelected = false;
+		}
+	}
 
-  //for (int i = 0; i < numPatchMeshes; i++)
-  //  patchMeshes[i].bSelected = false;
+	//for (int i = 0; i < numPatchMeshes; i++)
+	//  patchMeshes[i].bSelected = false;
 
-  if (g_bPatchBendMode)
-    Patch_BendToggle();
-  if (g_bPatchInsertMode)
-    Patch_InsDelToggle();
+	if (g_bPatchBendMode)
+		Patch_BendToggle();
+	if (g_bPatchInsertMode)
+		Patch_InsDelToggle();
 }
 
 
@@ -2851,12 +2640,12 @@
 Patch_Select
 ==================
 */
-void Patch_Select(patchMesh_t *p)
+void Patch_Select(patchMesh_c *p)
 {
-  // maintained for point manip.. which i need to fix as this 
-  // is pf error prone
-  //--g_nSelectedPatch = n;
-  p->bSelected = true;
+	// maintained for point manip.. which i need to fix as this 
+	// is pf error prone
+	//--g_nSelectedPatch = n;
+	p->bSelected = true;
 }
 
 
@@ -2865,9 +2654,9 @@
 Patch_Deselect
 ==================
 */
-void Patch_Deselect(patchMesh_t *p)
+void Patch_Deselect(patchMesh_c *p)
 {
-  p->bSelected = false;
+	p->bSelected = false;
 }
 
 
@@ -2876,22 +2665,14 @@
 Patch_Delete
 ==================
 */
-void Patch_Delete(patchMesh_t *p)
+void Patch_Delete(patchMesh_c *p)
 {
-  p->pSymbiot->pPatch = NULL;
-  p->pSymbiot->patchBrush = false;
+	p->pSymbiot->pPatch = NULL;
+	p->pSymbiot->patchBrush = false;
 
-  free(p);
-  p = NULL;
+	delete p;
 
-  // bump the array down
-  //for (int i = n; i < numPatchMeshes; i++)
-  //{
-  //  patchMeshes[i].pSymbiot->nPatchID--;
-  //  patchMeshes[i] = patchMeshes[i+1];
-  //}
-  //numPatchMeshes--;
-  UpdatePatchInspector();
+	UpdatePatchInspector();
 }
 
 
@@ -2900,30 +2681,30 @@
 Patch_Scale
 ==================
 */
-void Patch_Scale(patchMesh_t *p, const vec3_t vOrigin, const vec3_t vAmt, bool bRebuild)
+void Patch_Scale(patchMesh_c *p, const vec3_t vOrigin, const vec3_t vAmt, bool bRebuild)
 {
 
-  for (int w = 0; w < p->width; w++)
-  {
-    for (int h = 0; h < p->height; h++)
-    {
-      if (g_qeglobals.d_select_mode == sel_curvepoint && PointInMoveList(p->ctrl[w][h].xyz) == -1)
-        continue;
+	for (int w = 0; w < p->width; w++)
+	{
+		for (int h = 0; h < p->height; h++)
+		{
+			if (g_qeglobals.d_select_mode == sel_curvepoint && PointInMoveList(p->ctrl[w][h].xyz) == -1)
+				continue;
 			for (int i=0 ; i<3 ; i++)
 			{
-        p->ctrl[w][h].xyz[i] -= vOrigin[i];
-        p->ctrl[w][h].xyz[i] *= vAmt[i];
-        p->ctrl[w][h].xyz[i] += vOrigin[i];
-      }
-    }
-  }
-  if (bRebuild)
-  {
-    edVec3_c vMin, vMax;
-    Patch_CalcBounds(p, vMin, vMax);
-    Brush_RebuildBrush(p->pSymbiot, vMin, vMax);
-  }
-  UpdatePatchInspector();
+				p->ctrl[w][h].xyz[i] -= vOrigin[i];
+				p->ctrl[w][h].xyz[i] *= vAmt[i];
+				p->ctrl[w][h].xyz[i] += vOrigin[i];
+			}
+		}
+	}
+	if (bRebuild)
+	{
+		edVec3_c vMin, vMax;
+		p->calcPatchBounds(vMin, vMax);
+		Brush_RebuildBrush(p->pSymbiot, vMin, vMax);
+	}
+	UpdatePatchInspector();
 }
 
 
@@ -2934,8 +2715,8 @@
 */
 void Patch_Cleanup()
 {
-  //--g_nSelectedPatch = -1;
-  //numPatchMeshes = 0;
+	//--g_nSelectedPatch = -1;
+	//numPatchMeshes = 0;
 }
 
 
@@ -2947,8 +2728,8 @@
 */
 void Patch_SetView(int n)
 {
-  g_bSameView = (n == g_nPatchClickedView);
-  g_nPatchClickedView = n;
+	g_bSameView = (n == g_nPatchClickedView);
+	g_nPatchClickedView = n;
 }
 
 
@@ -2958,10 +2739,10 @@
 ==================
 */
 // FIXME: need array validation throughout
-void Patch_SetTexture(patchMesh_t *p, texdef_t *tex_def, IPluginTexdef* pPlugTexdef)
+void Patch_SetTexture(patchMesh_c *p, texdef_t *tex_def, IPluginTexdef* pPlugTexdef)
 {
-  p->d_texture = Texture_ForName(tex_def->name);
-  UpdatePatchInspector();
+	p->d_texture = Texture_ForName(tex_def->name);
+	UpdatePatchInspector();
 }
 
 
@@ -2970,12 +2751,12 @@
 Patch_DragScale
 ==================
 */
-bool Patch_DragScale(patchMesh_t *p, const edVec3_c &vAmt, const edVec3_c &vMove)
+bool Patch_DragScale(patchMesh_c *p, const edVec3_c &vAmt, const edVec3_c &vMove)
 {
   edVec3_c vMin, vMax, vScale, vTemp, vMid;
   int i;
 
-  Patch_CalcBounds(p, vMin, vMax);
+  p->calcPatchBounds(vMin, vMax);
 
   vTemp = vMax - vMin;
 
@@ -3008,7 +2789,7 @@
 
   vTemp = vMax - vMin;
 
-  Patch_CalcBounds(p, vMin, vMax);
+  p->calcPatchBounds(vMin, vMax);
   
   vMid = vMax - vMin;
 
@@ -3026,7 +2807,7 @@
     }
   }
 
-  Patch_Move(p, vTemp);
+  p->movePatch(vTemp);
   return true;
 }
 
@@ -3036,7 +2817,7 @@
 Patch_AddRow
 ==================
 */
-void Patch_AddRow(patchMesh_t *p)
+void Patch_AddRow(patchMesh_c *p)
 {
   edVec3_c vMin, vMax, vTemp;
   int i, j;
@@ -3044,7 +2825,7 @@
 
   if (p->height+2 < MAX_PATCH_HEIGHT)
   {
-    Patch_CalcBounds(p, vMin, vMax);
+    p->calcPatchBounds(vMin, vMax);
     vTemp = vMax - vMin;
     for (i = 0; i < 3; i++)
     {
@@ -3064,7 +2845,7 @@
       }
     }
     
-    Patch_CalcBounds(p, vMin, vMax);
+    p->calcPatchBounds(vMin, vMax);
     Brush_RebuildBrush(p->pSymbiot, vMin, vMax);
   }
   UpdatePatchInspector();
@@ -3075,7 +2856,7 @@
 Patch_InsertColumn
 ==================
 */
-void Patch_InsertColumn(patchMesh_t *p, bool bAdd)
+void Patch_InsertColumn(patchMesh_c *p, bool bAdd)
 {
   int h, w, i, j;
   edVec3_c vTemp;
@@ -3129,7 +2910,7 @@
 Patch_InsertRow
 ==================
 */
-void Patch_InsertRow(patchMesh_t *p, bool bAdd)
+void Patch_InsertRow(patchMesh_c *p, bool bAdd)
 {
   int h, w, i, j;
   edVec3_c vTemp;
@@ -3183,25 +2964,24 @@
 Patch_RemoveRow
 ==================
 */
-void Patch_RemoveRow(patchMesh_t *p, bool bFirst)
+void Patch_RemoveRow(patchMesh_c *p, bool bFirst)
 {
-  
-  if (p->height <= MIN_PATCH_HEIGHT)
-    return;
+	if (p->height <= MIN_PATCH_HEIGHT)
+		return;
 
-  p->height -= 2;
+	p->height -= 2;
 
-  if (bFirst)
-  {
-    for (int w = 0; w < p->width; w++)
-    {
-      for (int h = 0; h < p->height; h++)
-      {
-        memcpy(&p->ctrl[w][h], &p->ctrl[w][h+2], sizeof(drawVert_t));
-      }
-    }
-  }
-  UpdatePatchInspector();
+	if (bFirst)
+	{
+		for (int w = 0; w < p->width; w++)
+		{
+			for (int h = 0; h < p->height; h++)
+			{
+				memcpy(&p->ctrl[w][h], &p->ctrl[w][h+2], sizeof(drawVert_t));
+			}
+		}
+	}
+	UpdatePatchInspector();
 }
 
 
@@ -3210,25 +2990,24 @@
 Patch_RemoveColumn
 ==================
 */
-void Patch_RemoveColumn(patchMesh_t *p, bool bFirst)
+void patchMesh_c::removePatchColumn(bool bFirst)
 {
-  
-  if (p->width <= MIN_PATCH_WIDTH)
-    return;
+	if (this->width <= MIN_PATCH_WIDTH)
+		return;
 
-  p->width -= 2;
+	this->width -= 2;
 
-  if (bFirst)
-  {
-    for (int h = 0; h < p->height; h++)
-    {
-      for (int w = 0; w < p->width; w++)
-      {
-        memcpy(&p->ctrl[w][h], &p->ctrl[w+2][h], sizeof(drawVert_t));
-      }
-    }
-  }
-  UpdatePatchInspector();
+	if (bFirst)
+	{
+		for (int h = 0; h < this->height; h++)
+		{
+			for (int w = 0; w < this->width; w++)
+			{
+				memcpy(&this->ctrl[w][h], &this->ctrl[w+2][h], sizeof(drawVert_t));
+			}
+		}
+	}
+	UpdatePatchInspector();
 }
 
 
@@ -3237,47 +3016,47 @@
 Patch_AdjustColumns
 ==================
 */
-void Patch_AdjustColumns(patchMesh_t *p, int nCols)
+void patchMesh_c::adjustPatchColumns(int nCols)
 {
-  edVec3_c vTemp, vTemp2;
-  int i, w, h;
+	edVec3_c vTemp, vTemp2;
+	int i, w, h;
 
-  if (nCols & 0x01 || p->width + nCols < 3 || p->width + nCols > MAX_PATCH_WIDTH)
-    return;
+	if (nCols & 0x01 || this->width + nCols < 3 || this->width + nCols > MAX_PATCH_WIDTH)
+		return;
 
-  // add in column adjustment
-  p->width += nCols;
+	// add in column adjustment
+	this->width += nCols;
 
-  for (h = 0; h < p->height; h++)
-  {
-    // for each column, we need to evenly disperse p->width number 
-    // of points across the old bounds
-    
-    // calc total distance to interpolate 
-    vTemp = p->ctrl[p->width - 1 - nCols][h].xyz - p->ctrl[0][h].xyz;
+	for (h = 0; h < this->height; h++)
+	{
+	// for each column, we need to evenly disperse this->width number 
+	// of points across the old bounds
 
-    // amount per cycle
-    for (i = 0; i < 3; i ++)
-    {
-      vTemp2[i] = vTemp[i] / (p->width - 1);
-    }
+	// calc total distance to interpolate 
+	vTemp = this->ctrl[this->width - 1 - nCols][h].xyz - this->ctrl[0][h].xyz;
 
-    // move along
-    for (w = 0; w < p->width-1; w++)
-    {
-       p->ctrl[w+1][h].xyz = p->ctrl[w][h].xyz + vTemp2;
-    }
+	// amount per cycle
+	for (i = 0; i < 3; i ++)
+	{
+		vTemp2[i] = vTemp[i] / (this->width - 1);
+	}
 
-  }
-	for ( w = 0 ; w < p->width ; w++ ) 
-  {
-		for ( h = 0 ; h < p->height ; h++ ) 
-    {
-			p->ctrl[w][h].st[0] = 4 * (float)w / (p->width - 1);
-			p->ctrl[w][h].st[1] = 4 * (float)h / (p->height - 1);
+	// move along
+	for (w = 0; w < this->width-1; w++)
+	{
+		this->ctrl[w+1][h].xyz = this->ctrl[w][h].xyz + vTemp2;
+	}
+
+	}
+	for ( w = 0 ; w < this->width ; w++ ) 
+	{
+		for ( h = 0 ; h < this->height ; h++ ) 
+		{
+			this->ctrl[w][h].st[0] = 4 * (float)w / (this->width - 1);
+			this->ctrl[w][h].st[1] = 4 * (float)h / (this->height - 1);
 		}
 	}
-  UpdatePatchInspector();
+	UpdatePatchInspector();
 }
 
 
@@ -3286,100 +3065,100 @@
 Patch_AdjustRows
 ==================
 */
-void Patch_AdjustRows(patchMesh_t *p, int nRows)
+void patchMesh_c::adjustPatchRows(int nRows)
 {
-  edVec3_c vTemp, vTemp2;
-  int i, w, h;
+	edVec3_c vTemp, vTemp2;
+	int i, w, h;
 
-  if (nRows & 0x01 || p->height + nRows < 3 || p->height + nRows > MAX_PATCH_HEIGHT)
-    return;
+	if (nRows & 0x01 || this->height + nRows < 3 || this->height + nRows > MAX_PATCH_HEIGHT)
+		return;
 
-  // add in column adjustment
-  p->height += nRows;
+	// add in column adjustment
+	this->height += nRows;
 
-  for (w = 0; w < p->width; w++)
-  {
-    // for each row, we need to evenly disperse p->height number 
-    // of points across the old bounds
+	for (w = 0; w < this->width; w++)
+	{
+		// for each row, we need to evenly disperse this->height number 
+		// of points across the old bounds
 
-    // calc total distance to interpolate 
-    vTemp = p->ctrl[w][p->height - 1 - nRows].xyz - p->ctrl[w][0].xyz;
-    
-    //vTemp[0] = vTemp[1] = vTemp[2] = 0;
-    //for (h = 0; h < p->height - nRows; h ++)
-    //{
-    //  VectorAdd(vTemp, p->ctrl[w][h], vTemp);
-    //}
+		// calc total distance to interpolate 
+		vTemp = this->ctrl[w][this->height - 1 - nRows].xyz - this->ctrl[w][0].xyz;
 
-    // amount per cycle
-    for (i = 0; i < 3; i ++)
-    {
-      vTemp2[i] = vTemp[i] / (p->height - 1);
-    }
+		//vTemp[0] = vTemp[1] = vTemp[2] = 0;
+		//for (h = 0; h < this->height - nRows; h ++)
+		//{
+		//  VectorAdd(vTemp, this->ctrl[w][h], vTemp);
+		//}
 
-    // move along
-    for (h = 0; h < p->height-1; h++)
-    {
-      p->ctrl[w][h+1].xyz = p->ctrl[w][h].xyz + vTemp2;
-    }
+		// amount per cycle
+		for (i = 0; i < 3; i ++)
+		{
+			vTemp2[i] = vTemp[i] / (this->height - 1);
+		}
 
-  }
-	for ( w = 0 ; w < p->width ; w++ ) 
-  {
-		for ( h = 0 ; h < p->height ; h++ ) 
-    {
-			p->ctrl[w][h].st[0] = 4 * (float)w / (p->width - 1);
-			p->ctrl[w][h].st[1] = 4 * (float)h / (p->height - 1);
+		// move along
+		for (h = 0; h < this->height-1; h++)
+		{
+			this->ctrl[w][h+1].xyz = this->ctrl[w][h].xyz + vTemp2;
 		}
+
 	}
-  UpdatePatchInspector();
+	for ( w = 0 ; w < this->width ; w++ ) 
+	{
+		for ( h = 0 ; h < this->height ; h++ ) 
+		{
+			this->ctrl[w][h].st[0] = 4 * (float)w / (this->width - 1);
+			this->ctrl[w][h].st[1] = 4 * (float)h / (this->height - 1);
+		}
+	}
+	UpdatePatchInspector();
 }
 
 
 void Patch_DisperseRows()
 {
-  edVec3_c vTemp, vTemp2;
-  int i, w, h;
+	edVec3_c vTemp, vTemp2;
+	int i, w, h;
 
 
-	for (brush_t *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
+	for (brush_s *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
 	{
-    if (pb->patchBrush)
-    {
-      patchMesh_t *p = pb->pPatch;
-      Patch_Rebuild(p);
-      for (w = 0; w < p->width; w++)
-      {
-        // for each row, we need to evenly disperse p->height number 
-        // of points across the old bounds
+		if (pb->patchBrush)
+		{
+			patchMesh_c *p = pb->pPatch;
+			p->rebuildPatch();
+			for (w = 0; w < p->width; w++)
+			{
+				// for each row, we need to evenly disperse p->height number 
+				// of points across the old bounds
 
-        // calc total distance to interpolate 
-        vTemp = p->ctrl[w][p->height - 1].xyz - p->ctrl[w][0].xyz;
-    
-        //vTemp[0] = vTemp[1] = vTemp[2] = 0;
-        //for (h = 0; h < p->height - nRows; h ++)
-        //{
-        //  VectorAdd(vTemp, p->ctrl[w][h], vTemp);
-        //}
+				// calc total distance to interpolate 
+				vTemp = p->ctrl[w][p->height - 1].xyz - p->ctrl[w][0].xyz;
 
-        // amount per cycle
-        for (i = 0; i < 3; i ++)
-        {
-          vTemp2[i] = vTemp[i] / (p->height - 1);
-        }
+				//vTemp[0] = vTemp[1] = vTemp[2] = 0;
+				//for (h = 0; h < p->height - nRows; h ++)
+				//{
+				//  VectorAdd(vTemp, p->ctrl[w][h], vTemp);
+				//}
 
-        // move along
-        for (h = 0; h < p->height-1; h++)
-        {
-          p->ctrl[w][h+1].xyz = p->ctrl[w][h].xyz + vTemp2;
-        }
-        Patch_Naturalize(p);
+				// amount per cycle
+				for (i = 0; i < 3; i ++)
+				{
+					vTemp2[i] = vTemp[i] / (p->height - 1);
+				}
 
-      }
-    }
-  }
-  UpdatePatchInspector();
+				// move along
+				for (h = 0; h < p->height-1; h++)
+				{
+					p->ctrl[w][h+1].xyz = p->ctrl[w][h].xyz + vTemp2;
+				}
+				p->naturalizePatch();
 
+			}
+		}
+	}
+	UpdatePatchInspector();
+
 }
 
 /*
@@ -3389,41 +3168,41 @@
 */
 void Patch_DisperseColumns()
 {
-  edVec3_c vTemp, vTemp2;
-  int i, w, h;
+	edVec3_c vTemp, vTemp2;
+	int i, w, h;
 
-	for (brush_t *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
+	for (brush_s *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
 	{
-    if (pb->patchBrush)
-    {
-      patchMesh_t *p = pb->pPatch;
-      Patch_Rebuild(p);
+		if (pb->patchBrush)
+		{
+			patchMesh_c *p = pb->pPatch;
+			p->rebuildPatch();
 
-      for (h = 0; h < p->height; h++)
-      {
-        // for each column, we need to evenly disperse p->width number 
-        // of points across the old bounds
-    
-        // calc total distance to interpolate 
-        vTemp = p->ctrl[p->width - 1][h].xyz - p->ctrl[0][h].xyz;
+			for (h = 0; h < p->height; h++)
+			{
+			// for each column, we need to evenly disperse p->width number 
+			// of points across the old bounds
 
-        // amount per cycle
-        for (i = 0; i < 3; i ++)
-        {
-          vTemp2[i] = vTemp[i] / (p->width - 1);
-        }
+			// calc total distance to interpolate 
+			vTemp = p->ctrl[p->width - 1][h].xyz - p->ctrl[0][h].xyz;
 
-        // move along
-        for (w = 0; w < p->width-1; w++)
-        {
-          p->ctrl[w+1][h].xyz = p->ctrl[w][h].xyz + vTemp2;
-        }
+			// amount per cycle
+			for (i = 0; i < 3; i ++)
+			{
+				vTemp2[i] = vTemp[i] / (p->width - 1);
+			}
 
-      }
-      Patch_Naturalize(p);
-    }
-  }
-  UpdatePatchInspector();
+			// move along
+			for (w = 0; w < p->width-1; w++)
+			{
+				p->ctrl[w+1][h].xyz = p->ctrl[w][h].xyz + vTemp2;
+			}
+
+			}
+			p->naturalizePatch();
+		}
+	}
+	UpdatePatchInspector();
 }
 
 
@@ -3435,44 +3214,44 @@
 */
 void Patch_AdjustSelected(bool bInsert, bool bColumn, bool bFlag)
 {
-  bool bUpdate = false;
-	for (brush_t* pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
+	bool bUpdate = false;
+	for (brush_s* pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
 	{
-    if (pb->patchBrush)
-    {
-      if (bInsert)
-      {
-        if (bColumn)
-        {
-          Patch_InsertColumn(pb->pPatch, bFlag);
-        }
-        else
-        {
-          Patch_InsertRow(pb->pPatch, bFlag);
-        }
-      }
-      else
-      {
-        if (bColumn)
-        {
-          Patch_RemoveColumn(pb->pPatch, bFlag);
-        }
-        else
-        {
-          Patch_RemoveRow(pb->pPatch, bFlag);
-        }
-      }
-      bUpdate = true;
-      edVec3_c vMin, vMax;
-      patchMesh_t *p = pb->pPatch;
-      Patch_CalcBounds(p, vMin, vMax);
-      Brush_RebuildBrush(p->pSymbiot, vMin, vMax);
-    }
-  }
-  if (bUpdate)
-  {
-    Sys_UpdateWindows(W_ALL);
-  }
+	if (pb->patchBrush)
+	{
+	if (bInsert)
+	{
+	if (bColumn)
+	{
+	Patch_InsertColumn(pb->pPatch, bFlag);
+	}
+	else
+	{
+	Patch_InsertRow(pb->pPatch, bFlag);
+	}
+	}
+	else
+	{
+	if (bColumn)
+	{
+	pb->pPatch->removePatchColumn(bFlag);
+	}
+	else
+	{
+	Patch_RemoveRow(pb->pPatch, bFlag);
+	}
+	}
+	bUpdate = true;
+	edVec3_c vMin, vMax;
+	patchMesh_c *p = pb->pPatch;
+	p->calcPatchBounds(vMin, vMax);
+	Brush_RebuildBrush(p->pSymbiot, vMin, vMax);
+	}
+	}
+	if (bUpdate)
+	{
+		Sys_UpdateWindows(W_ALL);
+	}
 }
 
 
@@ -3483,23 +3262,23 @@
 */
 void Patch_AdjustSelectedRowCols(int nRows, int nCols)
 {
-	for (brush_t* pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
+	for (brush_s* pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
 	{
-    if (pb->patchBrush)
-    {
-      Patch_InsertColumn(pb->pPatch, false);
-      if (nRows != 0)
-      {
-        Patch_AdjustRows(pb->pPatch, nRows);
-      }
-      
-      if (nCols != 0)
-      {
-        Patch_AdjustColumns(pb->pPatch, nCols);
-      }
+		if (pb->patchBrush)
+		{
+			Patch_InsertColumn(pb->pPatch, false);
+			if (nRows != 0)
+			{
+				pb->pPatch->adjustPatchRows(nRows);
+			}
+
+			if (nCols != 0)
+			{
+				pb->pPatch->adjustPatchColumns(nCols);
+			}
 		}
-  }
-  UpdatePatchInspector();
+	}
+	UpdatePatchInspector();
 }
 
 
@@ -3536,7 +3315,7 @@
 }
 
 // parses a patch
-brush_t* Patch_Parse(bool bOld)
+brush_s* Patch_Parse(bool bOld)
 {
     //--if (bOld)
     //--{
@@ -3548,7 +3327,7 @@
   if (strcmp(token, "{"))
     return NULL;
 
-	patchMesh_t *pm = MakeNewPatch();
+	patchMesh_c *pm = MakeNewPatch();
 
 
 	{
@@ -3619,22 +3398,22 @@
 
   GetToken(true);
 
-	if (g_qeglobals.m_bBrushPrimitMode)
-  {
-    // we are in brush primit mode, but maybe it's a classic patch that needs converting, test "}"
-    if (strcmp(token, "}") && strcmp (token, "(") )
-	  {
-		  epair_t *ep = ParseEpair();
-		  ep->next = pm->epairs;
-		  pm->epairs = ep;
-      GetToken(true);
-	  }
-  }
+	//if (g_qeglobals.m_bBrushPrimitMode)
+ // {
+ //   // we are in brush primit mode, but maybe it's a classic patch that needs converting, test "}"
+ //   if (strcmp(token, "}") && strcmp (token, "(") )
+	//  {
+	//	  epair_s *ep = ParseEpair();
+	//	  ep->next = pm->epairs;
+	//	  pm->epairs = ep;
+ //     GetToken(true);
+	//  }
+ // }
 
   if (strcmp(token, "}"))
     return NULL;
 
-  brush_t *b = AddBrushForPatch(pm, false);
+  brush_s *b = AddBrushForPatch(pm, false);
 
   return b;
 }
@@ -3645,7 +3424,7 @@
 Patch_Write 
 ==================
 */
-void Patch_Write (patchMesh_t *p, CMemFile *file)
+void Patch_Write (patchMesh_c *p, CMemFile *file)
 {
   //--MemFile_fprintf(file, " {\n  patchDef3\n  {\n");
   MemFile_fprintf(file, " {\n  patchDef2\n  {\n");
@@ -3672,21 +3451,10 @@
 
   _Write3DMatrix(file, p->width, p->height, 5, reinterpret_cast<float*>(&ctrl));
 
-	if (g_qeglobals.m_bBrushPrimitMode)
-  {
-	  if (p->epairs)
-    {
-			for (epair_t *ep = p->epairs ; ep ; ep=ep->next)
-      {
-				MemFile_fprintf (file, "\"%s\" \"%s\"\n", ep->key, ep->value);
-      }
-    }
-  }
-
   MemFile_fprintf(file, "  }\n }\n");
 }
 
-void Patch_Write (patchMesh_t *p, FILE *file)
+void Patch_Write (patchMesh_c *p, FILE *file)
 {
 	fprintf(file, " {\n  patchDef2\n  {\n");
 	
@@ -3712,16 +3480,6 @@
 
   _Write3DMatrix(file, p->width, p->height, 5, reinterpret_cast<float*>(&ctrl));
 
-	if (g_qeglobals.m_bBrushPrimitMode)
-  {
-	  if (p->epairs)
-    {
-			for (epair_t *ep = p->epairs ; ep ; ep=ep->next)
-      {
-				fprintf (file, "\"%s\" \"%s\"\n", ep->key, ep->value);
-      }
-    }
-  }
 
   fprintf(file, "  }\n }\n");
 }
@@ -3732,10 +3490,10 @@
 Patch_RotateTexture
 ==================
 */
-void Patch_RotateTexture(patchMesh_t *p, float fAngle)
+void Patch_RotateTexture(patchMesh_c *p, float fAngle)
 {
   edVec3_c vMin, vMax;
-  Patch_CalcBounds(p, vMin, vMax);
+  p->calcPatchBounds(vMin, vMax);
   p->bDirty = true;
   for (int w = 0; w < p->width; w++)
   {
@@ -3758,7 +3516,7 @@
 Patch_ScaleTexture
 ==================
 */
-void Patch_ScaleTexture(patchMesh_t *p, float fx, float fy, bool bFixup)
+void Patch_ScaleTexture(patchMesh_c *p, float fx, float fy, bool bFixup)
 {
   // FIXME:
   // this hack turns scales into 1.1 or 0.9
@@ -3795,7 +3553,7 @@
 Patch_ShiftTexture
 ==================
 */
-void Patch_ShiftTexture(patchMesh_t *p, float fx, float fy)
+void Patch_ShiftTexture(patchMesh_c *p, float fx, float fy)
 {
   //if (fx)
   //  fx = (fx > 0) ? 0.1 : -0.1;
@@ -3819,17 +3577,17 @@
   p->bDirty = true;
 }
 
-void patchInvert(patchMesh_t *p)
+void patchMesh_c::invertPatch()
 {
-  drawVert_t vertTemp;
-  p->bDirty = true;
-	for ( int i = 0 ; i < p->width ; i++ ) 
-  {
-    for (int j = 0; j < p->height / 2; j++)
-    {
-      memcpy(&vertTemp, &p->ctrl[i][p->height - 1- j], sizeof (drawVert_t));
-      memcpy(&p->ctrl[i][p->height - 1 - j], &p->ctrl[i][j], sizeof(drawVert_t));
-      memcpy(&p->ctrl[i][j], &vertTemp, sizeof(drawVert_t));
+	drawVert_t vertTemp;
+	this->bDirty = true;
+	for ( int i = 0 ; i < this->width ; i++ ) 
+	{
+		for (int j = 0; j < this->height / 2; j++)
+		{
+			memcpy(&vertTemp, &this->ctrl[i][this->height - 1- j], sizeof (drawVert_t));
+			memcpy(&this->ctrl[i][this->height - 1 - j], &this->ctrl[i][j], sizeof(drawVert_t));
+			memcpy(&this->ctrl[i][j], &vertTemp, sizeof(drawVert_t));
 		}
 	}
 }
@@ -3843,12 +3601,12 @@
 {
   bool bUpdate = false;
 
-	for (brush_t *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
+	for (brush_s *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
 	{
     if (pb->patchBrush)
     {
       bUpdate = true;
-      patchInvert(pb->pPatch);
+      pb->pPatch->invertPatch();
     }
   }
 
@@ -3869,12 +3627,12 @@
   bool bUpdate = false;
 
   float fTemp[2];
-	for (brush_t *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
+	for (brush_s *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
 	{
     if (pb->patchBrush)
     {
       bUpdate = true;
-      patchMesh_t *p = pb->pPatch;
+      patchMesh_c *p = pb->pPatch;
       p->bDirty = true;
       if (bY)
       {
@@ -3920,11 +3678,11 @@
  Saves patch ctrl info (originally to deal with a 
  cancel in the surface dialog
 */
-void Patch_Save(patchMesh_t *p)
+void Patch_Save(patchMesh_c *p)
 {
-  patchSave.width = p->width;
-  patchSave.height = p->height;
-  memcpy(patchSave.ctrl, p->ctrl, sizeof(p->ctrl));
+	patchSave.width = p->width;
+	patchSave.height = p->height;
+	memcpy(patchSave.ctrl, p->ctrl, sizeof(p->ctrl));
 }
 
 
@@ -3933,139 +3691,139 @@
 Patch_Restore
 ==================
 */
-void Patch_Restore(patchMesh_t *p)
+void Patch_Restore(patchMesh_c *p)
 {
-  p->width = patchSave.width;
-  p->height = patchSave.height;
-  memcpy(p->ctrl, patchSave.ctrl, sizeof(p->ctrl));
+	p->width = patchSave.width;
+	p->height = patchSave.height;
+	memcpy(p->ctrl, patchSave.ctrl, sizeof(p->ctrl));
 }
 
 void Patch_ResetTexturing(float fx, float fy)
 {
-	for (brush_t* pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
+	for (brush_s* pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
 	{
-    if (pb->patchBrush)
-    {
-      patchMesh_t *p = pb->pPatch;
-      p->bDirty = true;
-	    for ( int i = 0 ; i < p->width ; i++ ) 
-      {
-		    for ( int j = 0 ; j < p->height ; j++ ) 
-        {
-			    p->ctrl[i][j].st[0] = fx * (float)i / (p->width - 1);
-			    p->ctrl[i][j].st[1] = fy * (float)j / (p->height - 1);
-		    }
-	    }
-    }
-  }
+		if (pb->patchBrush)
+		{
+			patchMesh_c *p = pb->pPatch;
+			p->bDirty = true;
+			for ( int i = 0 ; i < p->width ; i++ ) 
+			{
+				for ( int j = 0 ; j < p->height ; j++ ) 
+				{
+					p->ctrl[i][j].st[0] = fx * (float)i / (p->width - 1);
+					p->ctrl[i][j].st[1] = fy * (float)j / (p->height - 1);
+				}
+			}
+		}
+	}
 }
 
 
 void Patch_FitTexturing()
 {
-	for (brush_t *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
+	for (brush_s *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
 	{
-    if (pb->patchBrush)
-    {
-      patchMesh_t *p = pb->pPatch;
-      p->bDirty = true;
-	    for ( int i = 0 ; i < p->width ; i++ ) 
-      {
-		    for ( int j = 0 ; j < p->height ; j++ ) 
-        {
-			    p->ctrl[i][j].st[0] = 1 * (float)i / (p->width - 1);
-			    p->ctrl[i][j].st[1] = 1 * (float)j / (p->height - 1);
-		    }
-	    }
-    }
-  }
+		if (pb->patchBrush)
+		{
+			patchMesh_c *p = pb->pPatch;
+			p->bDirty = true;
+			for ( int i = 0 ; i < p->width ; i++ ) 
+			{
+				for ( int j = 0 ; j < p->height ; j++ ) 
+				{
+					p->ctrl[i][j].st[0] = 1 * (float)i / (p->width - 1);
+					p->ctrl[i][j].st[1] = 1 * (float)j / (p->height - 1);
+				}
+			}
+		}
+	}
 }
 
 
 void Patch_SetTextureInfo(texdef_t *pt)
 {
-	for (brush_t *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
+	for (brush_s *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
 	{
-    if (pb->patchBrush)
-    {
-      if (pt->rotate)
-        Patch_RotateTexture(pb->pPatch, pt->rotate);
+		if (pb->patchBrush)
+		{
+			if (pt->rotate)
+				Patch_RotateTexture(pb->pPatch, pt->rotate);
 
-      if (pt->shift[0] || pt->shift[1])
-        Patch_ShiftTexture(pb->pPatch, pt->shift[0], pt->shift[1]);
+			if (pt->shift[0] || pt->shift[1])
+				Patch_ShiftTexture(pb->pPatch, pt->shift[0], pt->shift[1]);
 
-      if (pt->scale[0] || pt->scale[1])
-        Patch_ScaleTexture(pb->pPatch, pt->scale[0], pt->scale[1], false);
+			if (pt->scale[0] || pt->scale[1])
+				Patch_ScaleTexture(pb->pPatch, pt->scale[0], pt->scale[1], false);
 
-      patchMesh_t *p = pb->pPatch;
-      p->contents = pt->contents;
-      p->flags = pt->flags;
-      p->value = pt->value;
-    }
-  }
+			patchMesh_c *p = pb->pPatch;
+			p->contents = pt->contents;
+			p->flags = pt->flags;
+			p->value = pt->value;
+		}
+	}
 }
 
 bool WINAPI OnlyPatchesSelected()
 {
-  if (g_ptrSelectedFaces.GetSize() > 0 || selected_brushes.next == &selected_brushes)
-    return false;
-	for (brush_t *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
+	if (g_ptrSelectedFaces.GetSize() > 0 || selected_brushes.next == &selected_brushes)
+		return false;
+	for (brush_s *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
 	{
-    if (!pb->patchBrush)
-    {
-      return false;
-    }
-  }
-  return true;
+		if (!pb->patchBrush)
+		{
+			return false;
+		}
+	}
+	return true;
 }
 
 bool WINAPI AnyPatchesSelected()
 {
-  if (g_ptrSelectedFaces.GetSize() > 0  || selected_brushes.next == &selected_brushes)
-    return false;
-	for (brush_t *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
+	if (g_ptrSelectedFaces.GetSize() > 0  || selected_brushes.next == &selected_brushes)
+		return false;
+	for (brush_s *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
 	{
-    if (pb->patchBrush)
-    {
-      return true;
-    }
-  }
-  return false;
+		if (pb->patchBrush)
+		{
+			return true;
+		}
+	}
+	return false;
 }
 
-patchMesh_t* SinglePatchSelected()
+patchMesh_c* SinglePatchSelected()
 {
 	if (selected_brushes.next->patchBrush)
-  {
-    return selected_brushes.next->pPatch;
-  }
-  return NULL;
+	{
+		return selected_brushes.next->pPatch;
+	}
+	return NULL;
 }
 
 void Patch_BendToggle()
 {
-  if (g_bPatchBendMode)
-  {
-    g_bPatchBendMode = false;
-    HideInfoDialog();
-    g_pParentWnd->UpdatePatchToolbarButtons() ;
-    return;
-  }
+	if (g_bPatchBendMode)
+	{
+		g_bPatchBendMode = false;
+		HideInfoDialog();
+		g_pParentWnd->UpdatePatchToolbarButtons() ;
+		return;
+	}
 
-	brush_t* b = selected_brushes.next;
+	brush_s* b = selected_brushes.next;
 
-  if (!QE_SingleBrush() || !b->patchBrush)
-  {
-    Sys_Printf("Must bend a single patch");
+	if (!QE_SingleBrush() || !b->patchBrush)
+	{
+		Sys_Printf("Must bend a single patch");
 		return;
-  }
+	}
 
-  Patch_Save(b->pPatch);
+	Patch_Save(b->pPatch);
 	g_bPatchBendMode = true;
-  g_nPatchBendState = BEND_SELECT_ROTATION;
-  g_bPatchAxisOnRow = true;
-  g_nPatchAxisIndex = 1;
-  ShowInfoDialog(g_pBendStateMsg[BEND_SELECT_ROTATION]);
+	g_nPatchBendState = BEND_SELECT_ROTATION;
+	g_bPatchAxisOnRow = true;
+	g_nPatchAxisIndex = 1;
+	ShowInfoDialog(g_pBendStateMsg[BEND_SELECT_ROTATION]);
 }
 
 void Patch_BendHandleTAB()
@@ -4075,7 +3833,7 @@
     return;
   }
 
-	brush_t* b = selected_brushes.next;
+	brush_s* b = selected_brushes.next;
   if (!QE_SingleBrush() || !b->patchBrush)
   {
     Patch_BendToggle();
@@ -4083,7 +3841,7 @@
 		return;
   }
 
-  patchMesh_t *p = b->pPatch;
+  patchMesh_c *p = b->pPatch;
 
   bool bShift = (GetKeyState(VK_SHIFT) & 0x8000);
 
@@ -4194,7 +3952,7 @@
     return;
   }
   Patch_BendToggle();
-	brush_t* b = selected_brushes.next;
+	brush_s* b = selected_brushes.next;
   if (QE_SingleBrush() && b->patchBrush)
   {
     Patch_Restore(b->pPatch);
@@ -4202,7 +3960,7 @@
   Sys_UpdateWindows(W_ALL);
 }
 
-void Patch_SetBendRotateOrigin(patchMesh_t *p)
+void Patch_SetBendRotateOrigin(patchMesh_c *p)
 {
 #if 1
   int nType = g_pParentWnd->ActiveXY()->GetViewType();
@@ -4263,7 +4021,7 @@
 // also sets the rotational origin
 void Patch_SelectBendAxis()
 {
-	brush_t* b = selected_brushes.next;
+	brush_s* b = selected_brushes.next;
   if (!QE_SingleBrush() || !b->patchBrush)
   {
     // should not ever happen
@@ -4271,7 +4029,7 @@
 		return;
   }
 
-  patchMesh_t *p = b->pPatch;
+  patchMesh_c *p = b->pPatch;
   if (g_bPatchAxisOnRow)
   {
     SelectRow(p, g_nPatchAxisIndex, false);
@@ -4288,7 +4046,7 @@
 
 void Patch_SelectBendNormal()
 {
-	brush_t* b = selected_brushes.next;
+	brush_s* b = selected_brushes.next;
   if (!QE_SingleBrush() || !b->patchBrush)
   {
     // should not ever happen
@@ -4296,7 +4054,7 @@
 		return;
   }
 
-  patchMesh_t *p = b->pPatch;
+  patchMesh_c *p = b->pPatch;
 
   g_qeglobals.d_num_move_points = 0;
   if (g_bPatchAxisOnRow)
@@ -4340,7 +4098,7 @@
     return;
   }
 
-	brush_t* b = selected_brushes.next;
+	brush_s* b = selected_brushes.next;
 
   if (!QE_SingleBrush() || !b->patchBrush)
   {
@@ -4380,7 +4138,7 @@
     return;
   }
 
-	brush_t* b = selected_brushes.next;
+	brush_s* b = selected_brushes.next;
   if (!QE_SingleBrush() || !b->patchBrush)
   {
     Patch_BendToggle();
@@ -4388,7 +4146,7 @@
 		return;
   }
 
-  patchMesh_t *p = b->pPatch;
+  patchMesh_c *p = b->pPatch;
 
   // only able to deal with odd numbered rows/cols
   g_nPatchAxisIndex += 2;
@@ -4487,7 +4245,7 @@
 
 void Patch_NaturalizeSelected(bool bCap, bool bCycleCap)
 {
-	for (brush_t *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
+	for (brush_s *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
 	{
     if (pb->patchBrush)
     {
@@ -4494,7 +4252,7 @@
       if (bCap)
         Patch_CapTexture(pb->pPatch, bCycleCap);
       else
-        Patch_Naturalize(pb->pPatch);
+        pb->pPatch->naturalizePatch();
     }
   }
 }
@@ -4519,11 +4277,11 @@
   g_qeglobals.d_num_move_points = 0;
   g_nPatchClickedView = -1;
 
-	for (brush_t *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
+	for (brush_s *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
 	{
     if (pb->patchBrush)
     {
-      patchMesh_t *p = pb->pPatch;
+      patchMesh_c *p = pb->pPatch;
       for (int i = 0; i < p->width; i++)
       {
         for (int j = 0; j < p->height; j++)
@@ -4540,10 +4298,10 @@
 
 const char* Patch_GetTextureName()
 {
-	brush_t* b = selected_brushes.next;
+	brush_s* b = selected_brushes.next;
   if (b->patchBrush)
   {
-    patchMesh_t *p = b->pPatch;
+    patchMesh_c *p = b->pPatch;
     if (p->d_texture->name)
       return p->d_texture->name;
   }
@@ -4550,10 +4308,10 @@
   return "";
 }
 
-patchMesh_t* Patch_Duplicate(patchMesh_t *pFrom)
+patchMesh_c* Patch_Duplicate(patchMesh_c *pFrom)
 {
-  patchMesh_t* p = MakeNewPatch();
-  memcpy(p, pFrom , sizeof(patchMesh_t));
+  patchMesh_c* p = MakeNewPatch();
+  memcpy(p, pFrom , sizeof(patchMesh_c));
   p->bSelected = false;
   p->bDirty = true;
   p->bOverlay = false;
@@ -4568,8 +4326,8 @@
 void Patch_Thicken(int nAmount, bool bSeam)
 {
   int i, j, h, w;
-  brush_t *b;
-  patchMesh_t *pSeam;
+  brush_s *b;
+  patchMesh_c *pSeam;
   edVec3_c vMin, vMax;
   CPtrArray brushes;
 
@@ -4582,13 +4340,13 @@
 		return;
   }
 
-	for (brush_t *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
+	for (brush_s *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
 	{
     if (pb->patchBrush)
     {
-      patchMesh_t *p = pb->pPatch;
-      Patch_MeshNormals(p);
-      patchMesh_t *pNew = Patch_Duplicate(p);
+      patchMesh_c *p = pb->pPatch;
+      p->meshNormals();
+      patchMesh_c *pNew = Patch_Duplicate(p);
       for (i = 0; i < p->width; i++)
       {
         for (j = 0; j < p->height; j++)
@@ -4597,7 +4355,7 @@
         }
       }
 
-      Patch_Rebuild(pNew);
+      pNew->rebuildPatch();
       pNew->type |= PATCH_THICK;
       brushes.Add(pNew->pSymbiot);
 
@@ -4620,11 +4378,11 @@
           }
 
 
-          Patch_CalcBounds(pSeam, vMin, vMax);
+          pSeam->calcPatchBounds(vMin, vMax);
           Brush_RebuildBrush(pSeam->pSymbiot, vMin, vMax);
           //--Patch_CapTexture(pSeam);
-          Patch_Naturalize(pSeam);
-          patchInvert(pSeam);
+          pSeam->naturalizePatch();
+          pSeam->invertPatch();
           brushes.Add(b);
 
           w = p->width - 1;
@@ -4638,10 +4396,10 @@
             pSeam->ctrl[1][i].xyz = pSeam->ctrl[0][i].xyz + pSeam->ctrl[2][i].xyz;
             pSeam->ctrl[1][i].xyz *= 0.5;
           }
-          Patch_CalcBounds(pSeam, vMin, vMax);
+          pSeam->calcPatchBounds(vMin, vMax);
           Brush_RebuildBrush(pSeam->pSymbiot, vMin, vMax);
           //--Patch_CapTexture(pSeam);
-          Patch_Naturalize(pSeam);
+          pSeam->naturalizePatch();
           brushes.Add(b);
         }
     
@@ -4659,11 +4417,11 @@
           }
 
 
-          Patch_CalcBounds(pSeam, vMin, vMax);
+          pSeam->calcPatchBounds(vMin, vMax);
           Brush_RebuildBrush(pSeam->pSymbiot, vMin, vMax);
           //--Patch_CapTexture(pSeam);
-          Patch_Naturalize(pSeam);
-          patchInvert(pSeam);
+          pSeam->naturalizePatch();
+          pSeam->invertPatch();
           brushes.Add(b);
 
           h = p->height - 1;
@@ -4677,16 +4435,16 @@
             pSeam->ctrl[i][1].xyz = pSeam->ctrl[i][0].xyz + pSeam->ctrl[i][2].xyz;
             pSeam->ctrl[i][1].xyz *= 0.5;
           }
-          Patch_CalcBounds(pSeam, vMin, vMax);
+          pSeam->calcPatchBounds(vMin, vMax);
           Brush_RebuildBrush(pSeam->pSymbiot, vMin, vMax);
           //--Patch_CapTexture(pSeam);
-          Patch_Naturalize(pSeam);
+          pSeam->naturalizePatch();
           brushes.Add(b);
 
-          eclass_t *pecNew = Eclass_ForName("func_group", false);
+          eclass_s *pecNew = Eclass_ForName("func_group", false);
           if (pecNew)
           {
-            entity_t *e = Entity_Create(pecNew);
+            entity_s *e = Entity_Create(pecNew);
             SetKeyValue(e, "type", "patchThick");
           }
 
@@ -4693,13 +4451,13 @@
         
         //--}
       }
-      patchInvert(pNew);
+      pNew->invertPatch();
     }
   }
 
   for (i = 0; i < brushes.GetSize(); i++)
   {
-    Select_Brush(reinterpret_cast<brush_t*>(brushes.GetAt(i)));
+    Select_Brush(reinterpret_cast<brush_s*>(brushes.GetAt(i)));
   }
 
   UpdatePatchInspector();
@@ -4727,13 +4485,13 @@
 
 void Patch_SetOverlays()
 {
-	for (brush_t *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
+	for (brush_s *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
 	{
-    if (pb->patchBrush)
-    {
-      pb->pPatch->bOverlay = true;
-    }
-  }
+		if (pb->patchBrush)
+		{
+			pb->pPatch->bOverlay = true;
+		}
+	}
 }
 
 
@@ -4740,29 +4498,27 @@
 
 void Patch_ClearOverlays()
 {
-  brush_t *pb;
+	brush_s *pb;
 	for (pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
 	{
-    if (pb->patchBrush)
-    {
-      pb->pPatch->bOverlay = false;
-    }
-  }
-
+		if (pb->patchBrush)
+		{
+			pb->pPatch->bOverlay = false;
+		}
+	}
 	for (pb = active_brushes.next ; pb != &active_brushes ; pb = pb->next)
 	{
-    if (pb->patchBrush)
-    {
-      pb->pPatch->bOverlay = false;
-    }
-  }
-
+		if (pb->patchBrush)
+		{
+			pb->pPatch->bOverlay = false;
+		}
+	}
 }
 
 // freezes selected vertices
 void Patch_Freeze()
 {
-  brush_t *pb;
+  brush_s *pb;
 	for (pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
 	{
     if (pb->patchBrush)
@@ -4791,11 +4547,11 @@
 {
 	int		i, j, w;
   drawVert_t dv;
-	for (brush_t *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
+	for (brush_s *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
 	{
     if (pb->patchBrush)
     {
-      patchMesh_t *p = pb->pPatch;
+      patchMesh_c *p = pb->pPatch;
 
     	if ( p->width > p->height ) 
       {
@@ -4843,8 +4599,8 @@
       w = p->width;
       p->width = p->height;
       p->height = w;
-      patchInvert(p);
-      Patch_Rebuild(p);
+      p->invertPatch();
+      p->rebuildPatch();
 		}
 	}
 }
@@ -4854,11 +4610,11 @@
 void Select_SnapToGrid()
 {
 	int i,j, k;
-	for (brush_t *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
+	for (brush_s *pb = selected_brushes.next ; pb != &selected_brushes ; pb = pb->next)
 	{
     if (pb->patchBrush)
     {
-      patchMesh_t *p = pb->pPatch;
+      patchMesh_c *p = pb->pPatch;
 #if 0
 	    float		ctrl[MAX_PATCH_WIDTH][MAX_PATCH_HEIGHT][5];
       memcpy(ctrl, p->ctrl, sizeof(p->ctrl));
@@ -4890,7 +4646,7 @@
       }
 #endif
       edVec3_c vMin, vMax;
-      Patch_CalcBounds(p, vMin, vMax);
+      p->calcPatchBounds(vMin, vMax);
       Brush_RebuildBrush(p->pSymbiot, vMin, vMax);
     }
     else
@@ -4901,38 +4657,35 @@
 }
 
 
-void Patch_FindReplaceTexture(brush_t *pb, const char *pFind, const char *pReplace, bool bForce)
+void Patch_FindReplaceTexture(brush_s *pb, const char *pFind, const char *pReplace, bool bForce)
 {
-  if (pb->patchBrush)
-  {
-    patchMesh_t *p = pb->pPatch;
-    if (bForce || strcmpi(p->d_texture->name, pFind) == 0)
-    {
-      p->d_texture = Texture_ForName(pReplace);
-      //strcpy(p->d_texture->name, pReplace);
-    }
-  }
+	if (pb->patchBrush)
+	{
+		patchMesh_c *p = pb->pPatch;
+		if (bForce || strcmpi(p->d_texture->name, pFind) == 0)
+		{
+			p->d_texture = Texture_ForName(pReplace);
+			//strcpy(p->d_texture->name, pReplace);
+		}
+	}
 }
 
-void Patch_ReplaceQTexture(brush_t *pb, qtexture_t *pOld, qtexture_t *pNew)
+void Patch_ReplaceQTexture(brush_s *pb, qtexture_t *pOld, qtexture_t *pNew)
 {
-  if (pb->patchBrush)
-  {
-    patchMesh_t *p = pb->pPatch;
-    if (p->d_texture == pOld)
-    {
-      p->d_texture = pNew;
-    }
-  }
+	if (pb->patchBrush)
+	{
+		patchMesh_c *p = pb->pPatch;
+		if (p->d_texture == pOld)
+		{
+			p->d_texture = pNew;
+		}
+	}
 }
 
-void Patch_Clone(patchMesh_t *p, brush_t *pNewOwner)
-{
-}
 
 void Patch_FromTriangle(vec5_t vx, vec5_t vy, vec5_t vz)
 {
-  patchMesh_t* p = MakeNewPatch();
+  patchMesh_c* p = MakeNewPatch();
 	p->d_texture = Texture_ForName(g_qeglobals.d_texturewin.texdef.name);
 	p->width = 3;
 	p->height = 3;
@@ -5007,42 +4760,14 @@
   p->ctrl[2][2].st[1] = vz[4];
 
 
-  //Patch_Naturalize(p);
+  //p->naturalizePatch();
 
-  brush_t *b = AddBrushForPatch(p);
+  brush_s *b = AddBrushForPatch(p);
 
 }
 
 
-/*
-==============
-Patch_SetEpair
-sets an epair for the given patch
-==============
-*/
-void Patch_SetEpair(patchMesh_t *p, const char *pKey, const char *pValue)
-{
-	if (g_qeglobals.m_bBrushPrimitMode)
-	{
-		SetKeyValue(p->epairs, pKey, pValue);
-	}
-}
 
-/* 
-=================
-Patch_GetKeyValue
-=================
-*/
-const char* Patch_GetKeyValue(patchMesh_t *p, const char *pKey)
-{
-	if (g_qeglobals.m_bBrushPrimitMode)
-	{
-    return ValueForKey(p->epairs, pKey);
-	}
-  return "";
-}
-
-
 //Real nitpicky, but could you make CTRL-S save the current map with the current name? (ie: File/Save)
 /*
 Feature addition.
Index: q3radiant/PrefsDlg.cpp
===================================================================
--- q3radiant/PrefsDlg.cpp	(revision 439)
+++ q3radiant/PrefsDlg.cpp	(working copy)
@@ -174,7 +174,6 @@
   m_bSelectWholeEntities = TRUE;
   m_nTextureQuality = 3;
   m_bShowShaders = TRUE;
-  m_bGLLighting = FALSE;
   m_nShader = 0;
   m_nUndoLevels = 64;
 }
@@ -365,7 +364,6 @@
   m_bSelectWholeEntities = AfxGetApp()->GetProfileInt(PREF_SECTION, SELWHOLEENTS_KEY, TRUE);
   m_nTextureQuality = AfxGetApp()->GetProfileInt(PREF_SECTION, TEXTUREQUALITY_KEY, 6);
   m_bShowShaders = AfxGetApp()->GetProfileInt(PREF_SECTION, SHOWSHADERS_KEY, TRUE);
-  m_bGLLighting = AfxGetApp()->GetProfileInt(PREF_SECTION, GLLIGHTING_KEY, FALSE);
   m_nShader = AfxGetApp()->GetProfileInt(PREF_SECTION, LOADSHADERS_KEY, 0);
   m_bNoStipple = AfxGetApp()->GetProfileInt(PREF_SECTION, NOSTIPPLE_KEY, 0);
   m_nUndoLevels = AfxGetApp()->GetProfileInt(PREF_SECTION, UNDOLEVELS_KEY, 0);
@@ -441,7 +439,6 @@
   AfxGetApp()->WriteProfileInt(PREF_SECTION, SELWHOLEENTS_KEY, m_bSelectWholeEntities);
   AfxGetApp()->WriteProfileInt(PREF_SECTION, TEXTUREQUALITY_KEY, m_nTextureQuality);
   AfxGetApp()->WriteProfileInt(PREF_SECTION, SHOWSHADERS_KEY, m_bShowShaders);
-  AfxGetApp()->WriteProfileInt(PREF_SECTION, GLLIGHTING_KEY, m_bGLLighting);
   AfxGetApp()->WriteProfileInt(PREF_SECTION, LOADSHADERS_KEY, m_nShader);
   AfxGetApp()->WriteProfileInt(PREF_SECTION, NOSTIPPLE_KEY, m_bNoStipple);
   AfxGetApp()->WriteProfileInt(PREF_SECTION, UNDOLEVELS_KEY, m_nUndoLevels);
Index: q3radiant/PrefsDlg.h
===================================================================
--- q3radiant/PrefsDlg.h	(revision 439)
+++ q3radiant/PrefsDlg.h	(working copy)
@@ -120,7 +120,6 @@
   BOOL m_bSwitchClip;
   BOOL m_bSelectWholeEntities;
   int m_nTextureQuality;
-	BOOL	m_bGLLighting;
 
 	// brush primitive mode
 	//++timo moved into g_qeglobals
Index: q3radiant/QE3.CPP
===================================================================
--- q3radiant/QE3.CPP	(revision 459)
+++ q3radiant/QE3.CPP	(working copy)
@@ -364,7 +364,7 @@
 {
 	//char	filename[1024];
 	FILE	*fp;
-	epair_t	*ep;
+	epair_s	*ep;
 
 	//sprintf (filename, "%s\\%s.prj", g_projectdir, g_username);
 
@@ -402,7 +402,7 @@
 */
 void ConnectEntities (void)
 {
-	entity_t	*e1, *e2, *e;
+	entity_s	*e1, *e2, *e;
 	char		*target, *tn;
 	int			maxtarg, targetnum;
 	char		newtarg[32];
@@ -470,18 +470,18 @@
 	if ( (selected_brushes.next == &selected_brushes)
 		|| (selected_brushes.next->next != &selected_brushes) )
 	{
-	  if (!bQuiet)
-    {
-	  	Sys_Printf ("Error: you must have a single brush selected\n");
-	  }
+		if (!bQuiet)
+		{
+			Sys_Printf ("Error: you must have a single brush selected\n");
+		}
 		return false;
 	}
 	if (selected_brushes.next->owner->eclass->fixedsize)
 	{
-	  if (!bQuiet)
-	  {
-		  Sys_Printf ("Error: you cannot manipulate fixed size entities\n");
-	  }
+		if (!bQuiet)
+		{
+			Sys_Printf ("Error: you cannot manipulate fixed size entities\n");
+		}
 		return false;
 	}
 
@@ -525,8 +525,8 @@
 	static int      s_lastbrushcount, s_lastentitycount;
 	static bool s_didonce;
 	
-	//entity_t   *e;
-	brush_t	   *b, *next;
+	//entity_s   *e;
+	brush_s	   *b, *next;
 
 	g_numbrushes = 0;
 	g_numentities = 0;
Index: q3radiant/QE3.H
===================================================================
--- q3radiant/QE3.H	(revision 459)
+++ q3radiant/QE3.H	(working copy)
@@ -100,7 +100,7 @@
 typedef struct
 {
 	int		p1, p2;
-	face_t	*f1, *f2;
+	face_s	*f1, *f2;
 } pedge_t;
 
 typedef struct
@@ -143,7 +143,7 @@
 	
 	int      d_num_entities;
 	
-	entity_t *d_project_entity;
+	entity_s *d_project_entity;
 	
 	float     d_new_brush_bottom_z,
 		      d_new_brush_top_z;
@@ -161,7 +161,6 @@
 	HWND      d_hwndXY;
 	HWND      d_hwndZ;
 	HWND      d_hwndStatus;
-	HWND      d_hwndGroup;
 	HWND      d_hwndMedia;
 	
 	edVec3_c  d_points[MAX_POINTS];
@@ -188,7 +187,7 @@
 	
 	// connect entities uses the last two brushes selected
 	int			 d_select_count;
-	brush_t		*d_select_order[2];
+	brush_s		*d_select_order[2];
 	edVec3_c       d_select_translate;    // for dragging w/o making new display lists
 	select_t     d_select_mode;
 	
@@ -321,7 +320,7 @@
 //
 BOOL CreateEntityWindow(HINSTANCE hInstance);
 void FillClassList (void);
-BOOL UpdateEntitySel(eclass_t *pec);	
+BOOL UpdateEntitySel(eclass_s *pec);	
 void SetInspectorMode(int iType);
 int DrawTexControls(HWND hWnd);
 void SetSpawnFlags(void);
@@ -370,7 +369,7 @@
 
 //++timo clean (moved into qertypes.h)
 //enum VIEWTYPE {YZ, XZ, XY};
-bool IsBrushSelected(brush_t* bSel);
+bool IsBrushSelected(brush_s* bSel);
 
 // curve brushes
 
@@ -379,11 +378,11 @@
 
 void Curve_Invert (void);
 
-void Curve_AddFakePlanes( brush_t *B );
-void Curve_StripFakePlanes( brush_t *B );
-void Curve_BuildPoints (brush_t *b);
-void Curve_XYDraw (brush_t *b);
-void Curve_CameraDraw (brush_t *b);
+void Curve_AddFakePlanes( brush_s *B );
+void Curve_StripFakePlanes( brush_s *B );
+void Curve_BuildPoints (brush_s *b);
+void Curve_XYDraw (brush_s *b);
+void Curve_CameraDraw (brush_s *b);
 
 void Curve_WriteFile (char *name);
 
@@ -394,50 +393,48 @@
 extern int  g_nPatchClickedView;
 bool within(vec3_t vTest, vec3_t vTL, vec3_t vBR);
 
-void Brush_RebuildBrush(brush_t *b, vec3_t vMins, vec3_t vMaxs );
-patchMesh_t* MakeNewPatch();
-brush_t* AddBrushForPatch(patchMesh_t *pm, bool bLinkToWorld = true);
-brush_t* Patch_GenericMesh(int nWidth, int nHeight, int nOrientation = 2, bool bDeleteSource = true, bool bOverride = false);
+void Brush_RebuildBrush(brush_s *b, vec3_t vMins, vec3_t vMaxs );
+patchMesh_c* MakeNewPatch();
+brush_s* AddBrushForPatch(patchMesh_c *pm, bool bLinkToWorld = true);
+brush_s* Patch_GenericMesh(int nWidth, int nHeight, int nOrientation = 2, bool bDeleteSource = true, bool bOverride = false);
 void Patch_ReadFile (char *name);
 void Patch_WriteFile (char *name); 
-void Patch_BuildPoints (brush_t *b);
-void Patch_Move(patchMesh_t *p, const vec3_t vMove, bool bRebuild = false);
-void Patch_ApplyMatrix(patchMesh_t *p, const class edVec3_c &vOrigin, const edVec3_c vMatrix[3], bool bSnap = false);
+void Patch_BuildPoints (brush_s *b);
+//void Patch_Move(patchMesh_c *p, const vec3_t vMove, bool bRebuild = false);
+void Patch_ApplyMatrix(patchMesh_c *p, const class edVec3_c &vOrigin, const edVec3_c vMatrix[3], bool bSnap = false);
 void Patch_EditPatch();
 void Patch_Deselect();
-void Patch_Deselect(patchMesh_t *p);
-void Patch_Delete(patchMesh_t *p);
-int  Patch_MemorySize(patchMesh_t *p);
-void Patch_Select(patchMesh_t *p);
-void Patch_Scale(patchMesh_t *p, const vec3_t vOrigin, const vec3_t vAmt, bool bRebuilt = true);
+void Patch_Deselect(patchMesh_c *p);
+void Patch_Delete(patchMesh_c *p);
+int  Patch_MemorySize(patchMesh_c *p);
+void Patch_Select(patchMesh_c *p);
+void Patch_Scale(patchMesh_c *p, const vec3_t vOrigin, const vec3_t vAmt, bool bRebuilt = true);
 void Patch_Cleanup();
 void Patch_SetView(int n);
-void Patch_SetTexture(patchMesh_t *p, texdef_t *tex_def, IPluginTexdef* pPlugTexdef = NULL);
+void Patch_SetTexture(patchMesh_c *p, texdef_t *tex_def, IPluginTexdef* pPlugTexdef = NULL);
 void Patch_BrushToMesh(bool bCone = false, bool bBevel = false, bool bEndcap = false, bool bSquare = false, int nHeight = 3);
-bool Patch_DragScale(patchMesh_t *p, const edVec3_c &vAmt, const edVec3_c &vMove);
+bool Patch_DragScale(patchMesh_c *p, const edVec3_c &vAmt, const edVec3_c &vMove);
 void Patch_ReadBuffer(char* pBuff, bool bSelect = false);
 void Patch_WriteFile (CMemFile* pMemFile);
 void Patch_UpdateSelected(vec3_t vMove);
-void Patch_AddRow(patchMesh_t *p);
-brush_t* Patch_Parse(bool bOld);
-void Patch_Write (patchMesh_t *p, FILE *f);
-void Patch_Write (patchMesh_t *p, CMemFile *file);
-void Patch_AdjustColumns(patchMesh_t *p, int nCols);
-void Patch_AdjustRows(patchMesh_t *p, int nRows);
+void Patch_AddRow(patchMesh_c *p);
+brush_s* Patch_Parse(bool bOld);
+void Patch_Write (patchMesh_c *p, FILE *f);
+void Patch_Write (patchMesh_c *p, CMemFile *file);
+//void Patch_AdjustColumns(patchMesh_c *p, int nCols);
+//void Patch_AdjustRows(patchMesh_c *p, int nRows);
 void Patch_AdjustSelected(bool bInsert, bool bColumn, bool bFlag);
-patchMesh_t* Patch_Duplicate(patchMesh_t *pFrom);
-void Patch_RotateTexture(patchMesh_t *p, float fAngle);
-void Patch_ScaleTexture(patchMesh_t *p, float fx, float fy, bool bFixup = true);
-void Patch_ShiftTexture(patchMesh_t *p, float fx, float fy);
-void Patch_DrawCam(patchMesh_t *p);
-void Patch_DrawXY(patchMesh_t *p);
-void Patch_InsertColumn(patchMesh_t *p, bool bAdd);
-void Patch_InsertRow(patchMesh_t *p, bool bAdd);
-void Patch_RemoveRow(patchMesh_t *p, bool bFirst);
-void Patch_RemoveColumn(patchMesh_t *p, bool bFirst);
+patchMesh_c* Patch_Duplicate(patchMesh_c *pFrom);
+void Patch_RotateTexture(patchMesh_c *p, float fAngle);
+void Patch_ScaleTexture(patchMesh_c *p, float fx, float fy, bool bFixup = true);
+void Patch_ShiftTexture(patchMesh_c *p, float fx, float fy);
+//void Patch_DrawCam(patchMesh_c *p);
+//void Patch_InsertColumn(patchMesh_c *p, bool bAdd);
+//void Patch_InsertRow(patchMesh_c *p, bool bAdd);
+//void Patch_RemoveRow(patchMesh_c *p, bool bFirst);
 void Patch_ToggleInverted();
-void Patch_Restore(patchMesh_t *p);
-void Patch_Save(patchMesh_t *p);
+void Patch_Restore(patchMesh_c *p);
+void Patch_Save(patchMesh_c *p);
 void Patch_SetTextureInfo(texdef_t* pt);
 void Patch_NaturalTexturing();
 void Patch_ResetTexturing(float fx, float fy);
@@ -450,7 +447,7 @@
 void Patch_SelectBendAxis();
 bool WINAPI OnlyPatchesSelected();
 bool WINAPI AnyPatchesSelected();
-patchMesh_t* SinglePatchSelected();
+patchMesh_c* SinglePatchSelected();
 void Patch_CapCurrent(bool bInvertedBevel = false, bool bInvertedEndcap = false);
 void Patch_DisperseRows();
 void Patch_DisperseColumns();
@@ -467,8 +464,8 @@
 void Patch_Freeze();
 void Patch_UnFreeze(bool bAll);
 const char* Patch_GetTextureName();
-void Patch_FindReplaceTexture(brush_t *pb, const char *pFind, const char *pReplace, bool bForce);
-void Patch_ReplaceQTexture(brush_t *pb, qtexture_t *pOld, qtexture_t *pNew);
+void Patch_FindReplaceTexture(brush_s *pb, const char *pFind, const char *pReplace, bool bForce);
+void Patch_ReplaceQTexture(brush_s *pb, qtexture_t *pOld, qtexture_t *pNew);
 void Select_SnapToGrid();
 extern bool g_bPatchShowBounds;
 extern bool g_bPatchWireFrame;
@@ -478,66 +475,23 @@
 extern bool g_bPatchBendMode;
 extern edVec3_c g_vBendOrigin;
 void Patch_FromTriangle(vec5_t vx, vec5_t vy, vec5_t vz);
-const char* Patch_GetKeyValue(patchMesh_t *p, const char *pKey);
-void Patch_SetEpair(patchMesh_t *p, const char *pKey, const char *pValue);
 
-
-
-// group stuff
-// group_t are loaded / saved through "group_info" entities
-// they hold epairs for group settings and additionnal access info (tree nodes)
-typedef struct group_s
-{
-	struct group_s	*next;
-	epair_t *epairs;
-	HTREEITEM itemOwner;
-} group_t;
-
-// NOTES: grouping only enabled in brush primitives mode
-// grouping works by naming brushes and setting display properties
-// the group hierarchy is not related with the map hierarchy (entity list, brushes etc.)
-// brushes with no group are under the "world" node (default for all brushes)
-// void Group_GetListFromWorld(CStringArray *pArray);
-void Group_RemoveListFromWorld();
-// void Group_SetListToWorld(CStringArray *pArray);
-// void Group_BuildTree(CTreeCtrl *pTree);
-// void Group_DecomposeTree(CTreeCtrl *pTree);
-// save group_t as "classname" "group_info" things
-void Group_Save(FILE *f);
-// clean the brushes ownerItem, clean the treeview and rebuild everything
-// is usually called when loading a new map, but may be called anytime
-void Group_Init();
-void Group_Add(entity_t *e);
-
-// remove a brush from it's current group, will erase the "group" epair if any, and delete the tree control node
-void Group_RemoveBrush(brush_t *b);
-void Group_AddToWorld(brush_t *b);
-// will remove brush of it's current group if any, and will add it wherever needed according to it's "group" key
-void Group_AddToProperGroup(brush_t *b);
-void Group_AddToSelected(brush_t *b);
-// allocate a new group, set name
-group_t* Group_Alloc(const char *name);
-// we use entities to store information about the groups
-// these entities are not linked into the world, and they have no brushes
-// only loaded / saved in map file
-group_t* Group_ForName(const char *name);
-
 // Timo
 // new brush primitive stuff
 void ComputeAxisBase(edVec3_c &normal, edVec3_c &texS, edVec3_c &texT);
-void FaceToBrushPrimitFace(face_t *f);
-void EmitBrushPrimitTextureCoordinates(face_t *, winding_t *);
+void FaceToBrushPrimitFace(face_s *f);
+void EmitBrushPrimitTextureCoordinates(face_s *, winding_t *);
 // EmitTextureCoordinates, is old code used for brush to brush primitive conversion
-void EmitTextureCoordinates ( class texturedVertex_c &out, qtexture_t *q, face_t *f);
-void BrushPrimit_Parse(brush_t *);
+void EmitTextureCoordinates ( class texturedVertex_c &out, qtexture_t *q, face_s *f);
+void BrushPrimit_Parse(brush_s *);
 // compute a fake shift scale rot representation from the texture matrix
 void TexMatToFakeTexCoords( vec_t texMat[2][3], float shift[2], float *rot, float scale[2] );
 void FakeTexCoordsToTexMat( float shift[2], float rot, float scale[2], vec_t texMat[2][3] );
-void ConvertTexMatWithQTexture( brushprimit_texdef_t *texMat1, qtexture_t *qtex1, brushprimit_texdef_t *texMat2, qtexture_t *qtex2 );
+void ConvertTexMatWithQTexture( brushprimit_texdef_s *texMat1, qtexture_t *qtex1, brushprimit_texdef_s *texMat2, qtexture_t *qtex2 );
 // texture locking
-void Face_MoveTexture_BrushPrimit(face_t *f, const edVec3_c &delta);
-void Select_ShiftTexture_BrushPrimit( face_t *f, int x, int y );
-void RotateFaceTexture_BrushPrimit(face_t *f, int nAxis, float fDeg, vec3_t vOrigin );
+void Face_MoveTexture_BrushPrimit(face_s *f, const edVec3_c &delta);
+void Select_ShiftTexture_BrushPrimit( face_s *f, int x, int y );
+void RotateFaceTexture_BrushPrimit(face_s *f, int nAxis, float fDeg, vec3_t vOrigin );
 // used in CCamWnd::ShiftTexture_BrushPrimit
 void ComputeBest2DVector( const edVec3_c &v, const edVec3_c &X, const edVec3_c &Y, int &x, int &y );
 
@@ -547,17 +501,10 @@
 //
 extern bool parsing_single;
 extern bool eclass_found;
-extern eclass_t *eclass_e;
+extern eclass_s *eclass_e;
 void Eclass_ScanFile( char *filename );
 
 //
-// SurfaceDlg.cpp and surface properties plugin
-//
-//++timo some patch in/out stuff is in there, needs to be moved out in a dedicated interface
-void WINAPI Patch_Rebuild(patchMesh_t *p);
-
-
-//
 // ShaderInfo.cpp
 //
 #include "ShaderInfo.h"
Index: q3radiant/QERTYPES.H
===================================================================
--- q3radiant/QERTYPES.H	(revision 459)
+++ q3radiant/QERTYPES.H	(working copy)
@@ -100,10 +100,10 @@
 
 // Timo
 // new brush primitive texdef
-typedef struct brushprimit_texdef_s
+struct brushprimit_texdef_s
 {
 	vec_t	coords[2][3];
-} brushprimit_texdef_t;
+};
 
 class texturewin_t
 {
@@ -116,8 +116,8 @@
   }
 	int			width, height;
 	int			originy;
-	// add brushprimit_texdef_t for brush primitive coordinates storage
-	brushprimit_texdef_t	brushprimit_texdef;
+	// add brushprimit_texdef_s for brush primitive coordinates storage
+	brushprimit_texdef_s	brushprimit_texdef;
 	int m_nTotalHeight;
 	texdef_t	texdef;
 };
@@ -183,12 +183,12 @@
 // you should read float points[..][5]
 // see NewWinding definition
 #define MAX_POINTS_ON_WINDING 64
-typedef struct
+struct winding_t
 {
 	int		numpoints;
 	int		maxpoints;
 	texturedVertex_c 	points[8];			// variable sized
-} winding_t;
+};
 
 #define	NORMAL_EPSILON	0.0001
 #define	DIST_EPSILON	0.02
@@ -243,7 +243,7 @@
 
 //++timo texdef and brushprimit_texdef are static
 // TODO : do dynamic ?
-typedef struct face_s
+struct face_s
 {
 	struct face_s			*next;
 	struct face_s			*original;		//used for vertex movement
@@ -257,20 +257,16 @@
 	qtexture_t				*d_texture;
 
 	// Timo new brush primit texdef
-	brushprimit_texdef_t	brushprimit_texdef;
-} face_t;
+	brushprimit_texdef_s	brushprimit_texdef;
+};
 
-typedef struct {
+struct curveVertex_t {
 	edVec3_c xyz;
 	float	sideST[2];
 	float	capST[2];
-} curveVertex_t;
+};
 
-typedef struct {
-	curveVertex_t	v[2];
-} sideVertex_t;
 
-
 #define	MIN_PATCH_WIDTH		3
 #define	MIN_PATCH_HEIGHT 	3
 
@@ -303,7 +299,7 @@
 #define PATCH_BTYPEMASK    0x0000f000    // 
 #define PATCH_STYLEMASK    0xffff0000    // 
 
-typedef struct {
+struct drawVert_t {
 	edVec3_c	xyz;
 	float		st[2];
 	float		lightmap[2];
@@ -312,33 +308,68 @@
 	texturedVertex_c &asWindingPoint() {
 		return *((texturedVertex_c*)(this));
 	}
-} drawVert_t;
+};
 
 // used in brush primitive AND entities
-typedef struct epair_s
+struct epair_s
 {
 	struct epair_s	*next;
 	char	*key;
 	char	*value;
-} epair_t;
+};
 
-struct brush_s;
-typedef struct brush_s brush_t;
-
-typedef struct {
+class patchMesh_c {
+	float calcPatchWidth();
+	float calcPatchWidthDistanceTo(int j);
+	float calcPatchHeight();
+	float calcPatchHeightDistanceTo(int j);
+public:
 	int	width, height;		// in control points, not patches
 	int   contents, flags, value, type;
 	qtexture_t *d_texture;
 	drawVert_t ctrl[MAX_PATCH_WIDTH][MAX_PATCH_HEIGHT];
-	brush_t *pSymbiot;
+	struct brush_s *pSymbiot;
 	bool bSelected;
 	bool bOverlay;
 	bool bDirty;
 	int  nListID;
-	epair_t *epairs;
-} patchMesh_t;
 
+	patchMesh_c() {
+		width = height = 0;
+		contents = flags = value = type = 0;
+		d_texture = 0;
+		pSymbiot = 0;
+		bSelected = false;
+		bOverlay = false;
+		bDirty = false;
+		nListID = 0;
+	}
+	/*void setType(int nType)
+	{
+		this->type = (this->type & PATCH_STYLEMASK) | nType;
+	}
+	void setStyle(int nStyle)
+	{
+		this->type = (this->type & PATCH_TYPEMASK) | nStyle;
+	}*/
+	void fillPatch(vec3_t v);
+	void naturalizePatch();
+	void invertPatch();
+	void meshNormals();
+	void interpolateInteriorPoints();
+	void rebuildPatch();
+	void adjustPatchRows(int nRows);
+	void adjustPatchColumns(int nCols);
+	void movePatch(const vec3_t vMove, bool bRebuild = false);
+	void calcPatchBounds(edVec3_c& vMin, edVec3_c& vMax);
+	void drawPatchMesh(bool bPoints, bool bShade = false);
+	void drawPatchXY();
+	void removePatchColumn(bool bFirst);
+	void drawPatchCam();
 
+};
+
+
 typedef struct brush_s
 {
 	struct brush_s	*prev, *next;	// links in active/selected
@@ -345,7 +376,7 @@
 	struct brush_s	*oprev, *onext;	// links in entity
 	struct entity_s	*owner;
 	edAABB_c bounds;
-	face_t     *brush_faces;
+	face_s     *brush_faces;
 
 	bool bModelFailed;
 	//
@@ -355,7 +386,7 @@
 	bool	hiddenBrush;
 	bool	terrainBrush;
   
-	patchMesh_t *pPatch;
+	patchMesh_c *pPatch;
 
 	struct entity_s *pUndoOwner;
 
@@ -363,18 +394,6 @@
 	int redoId;						//redo ID
 	int ownerId;					//entityId of the owner entity for undo
 
-	// TTimo: HTREEITEM is MFC, some plugins really don't like it
-#ifdef QERTYPES_USE_MFC
-	int numberId;         // brush number
-	HTREEITEM itemOwner;  // owner for grouping
-#else
-	int numberId;
-	DWORD itemOwner;
-#endif
-
-	// brush primitive only
-	epair_t *epairs;
-
 	const edAABB_c &getBounds() const {
 		return bounds;
 	}
@@ -384,30 +403,12 @@
 	const edVec3_c &getMaxs() const {
 		return bounds.getMaxs();
 	}
-} brush_t;
+} brush_s;
 
 
-#define	MAX_FLAGS	8
+//#define	MAX_FLAGS	8
+//
 
-
-typedef struct trimodel_t
-{
-  vec3_t v[3];
-  float  st[3][2];
-} trimodel;
-
-typedef struct entitymodel_t
-{
-  struct entitymodel_t *pNext;
-  int nTriCount;
-  trimodel *pTriList;
-  int nTextureBind;
-  int nSkinWidth;
-  int nSkinHeight;
-  int	nModelPosition;
-} entitymodel;
-
-
 // eclass show flags
 
 #define     ECLASS_LIGHT      0x00000001
@@ -416,7 +417,7 @@
 #define     ECLASS_MISCMODEL  0x00000008
 #define		ECLASS_PLUGINENTITY 0x00000010
 
-typedef struct eclass_s
+struct eclass_s
 {
 	struct eclass_s *next;
 	char	*name;
@@ -426,23 +427,17 @@
 	vec3_t	color;
 	texdef_t	texdef;
 	char	*comments;
-	char	flagnames[MAX_FLAGS][32];
+	char	flagnames[8][32];
 
-/*
-  int nTriCount;
-  trimodel *pTriList;
-  int nTextureBind;
-  int nSkinWidth, nSkinHeight;
-*/
-  entitymodel *model;
-  char	*modelpath;
-  char	*skinpath;
-  int   nFrame;
-  unsigned int nShowFlags;
-} eclass_t;
 
-extern	eclass_t	*eclass;
+	char	*modelpath;
+	char	*skinpath;
+	int   nFrame;
+	unsigned int nShowFlags;
+};
 
+extern	eclass_s	*eclass;
+
 /*
 ** window bits
 */
@@ -464,8 +459,4 @@
 // used in some Drawing routines
 enum VIEWTYPE {YZ, XZ, XY};
 
-enum terrainnoise_t { NOISE_NONE, NOISE_PLUS, NOISE_PLUSMINUS };
-enum terrainbrush_t { TERRAIN_BRUSH_CIRCLE, TERRAIN_BRUSH_SQUARE };
-enum terrainfalloff_t { TERRAIN_FALLOFF_LINEAR, TERRAIN_FALLOFF_CURVED };
-
 #endif
\ No newline at end of file
Index: q3radiant/QFILES.H
===================================================================
--- q3radiant/QFILES.H	(revision 436)
+++ q3radiant/QFILES.H	(working copy)
@@ -25,163 +25,7 @@
 // This file must be identical in the quake and utils directories
 //
 
-/*
-========================================================================
 
-.MD2 triangle model file format
-
-========================================================================
-*/
-
-#define IDALIASHEADER		(('2'<<24)+('P'<<16)+('D'<<8)+'I')
-#define ALIAS_VERSION	8
-
-#define	MAX_TRIANGLES	4096
-#define MAX_VERTS		2048
-#define MAX_FRAMES		512
-#define MAX_MD2SKINS	32
-#define	MAX_SKINNAME	64
-
-typedef struct
-{
-	short	s;
-	short	t;
-} dstvert_t;
-
-typedef struct 
-{
-	short	index_xyz[3];
-	short	index_st[3];
-} dtriangle_t;
-
-typedef struct
-{
-	byte	v[3];			// scaled byte to fit in frame mins/maxs
-	byte	lightnormalindex;
-} dtrivertx_t;
-
-typedef struct
-{
-	float		scale[3];	// multiply byte verts by this
-	float		translate[3];	// then add this
-	char		name[16];	// frame name from grabbing
-	dtrivertx_t	verts[1];	// variable sized
-} daliasframe_t;
-
-
-// the glcmd format:
-// a positive integer starts a tristrip command, followed by that many
-// vertex structures.
-// a negative integer starts a trifan command, followed by -x vertexes
-// a zero indicates the end of the command list.
-// a vertex consists of a floating point s, a floating point t,
-// and an integer vertex index.
-
-
-typedef struct
-{
-	int			ident;
-	int			version;
-
-	int			skinwidth;
-	int			skinheight;
-	int			framesize;		// byte size of each frame
-
-	int			num_skins;
-	int			num_xyz;
-	int			num_st;			// greater than num_xyz for seams
-	int			num_tris;
-	int			num_glcmds;		// dwords in strip/fan command list
-	int			num_frames;
-
-	int			ofs_skins;		// each skin is a MAX_SKINNAME string
-	int			ofs_st;			// byte offset from start for stverts
-	int			ofs_tris;		// offset for dtriangles
-	int			ofs_frames;		// offset for first frame
-	int			ofs_glcmds;	
-	int			ofs_end;		// end of file
-
-} dmdl_t;
-
-#define MD3_IDENT			(('3'<<24)+('P'<<16)+('D'<<8)+'I')
-#define	MAX_QPATH			64		// max length of a quake game pathname
-#define	MD3_XYZ_SCALE		(1.0/64)
-
-typedef struct {
-	int			ident;
-	int			version;
-
-	char		name[MAX_QPATH];	// model name
-
-	int			flags;
-
-	int			numFrames;
-	int			numTags;			
-	int			numSurfaces;
-
-	int			numSkins;
-
-	int			ofsFrames;			// offset for first frame
-	int			ofsTags;			// numFrames * numTags
-	int			ofsSurfaces;		// first surface, others follow
-
-	int			ofsEnd;				// end of file
-} md3Header_t;
-
-typedef struct {
-	int		ident;				// 
-
-	char	name[MAX_QPATH];	// polyset name
-
-	int		flags;
-	int		numFrames;			// all surfaces in a model should have the same
-
-	int		numShaders;			// all surfaces in a model should have the same
-	int		numVerts;
-
-	int		numTriangles;
-	int		ofsTriangles;
-
-	int		ofsShaders;			// offset from start of md3Surface_t
-	int		ofsSt;				// texture coords are common for all frames
-	int		ofsXyzNormals;		// numVerts * numFrames
-
-	int		ofsEnd;				// next surface follows
-
-} md3Surface_t;
-
-typedef struct {
-	char			name[MAX_QPATH];
-	int				shaderIndex;	// for in-game use
-} md3Shader_t;
-
-typedef struct {
-	int			indexes[3];
-} md3Triangle_t;
-
-typedef struct {
-	float		st[2];
-} md3St_t;
-
-typedef struct {
-	short		xyz[3];
-	short		normal;
-} md3XyzNormal_t;
-
-
-typedef struct
-{
-  float st[2];
-  int   nVertIndex;
-} glst_t;
-
-typedef struct
-{
-  int     nCount;
-  int     ObjectIndex;
-  glst_t  GlSt;
-} gl_t;
-
 #define MAX_WORLD_COORD		( 128*1024 )
 #define MIN_WORLD_COORD		( -128*1024 )
 #define WORLD_SIZE			( MAX_WORLD_COORD - MIN_WORLD_COORD )
@@ -189,9 +33,9 @@
 #define	MAX_MAP_ENTITIES	2048
 
 
-
 #define	MAX_MAP_BRUSHES		8192
 
+
 #define MAX_BRUSH_SIZE		( WORLD_SIZE )
 
 // key / value pair sizes
@@ -202,32 +46,11 @@
 //=============================================================================
 
 
-typedef struct
-{
-	float	point[3];
-} dvertex_t;
 
 
-// 0-2 are axial planes
-#define	PLANE_X			0
-#define	PLANE_Y			1
-#define	PLANE_Z			2
-
-// 3-5 are non-axial planes snapped to the nearest
-#define	PLANE_ANYX		3
-#define	PLANE_ANYY		4
-#define	PLANE_ANYZ		5
-
 // planes (x&~1) and (x&~1)+1 are allways opposites
 
-typedef struct
-{
-	float	normal[3];
-	float	dist;
-	int		type;		// PLANE_X - PLANE_ANYZ ?remove? trivial to regenerate
-} dplane_t;
 
-
 // contents flags are seperate bits
 // a given brush can contribute multiple content bits
 // multiple brushes can be in a single leaf
@@ -246,13 +69,6 @@
 #define	CONTENTS_PLAYERCLIP		0x10000
 #define	CONTENTS_MONSTERCLIP	0x20000
 
-// currents can be added to any other contents, and may be mixed
-#define	CONTENTS_CURRENT_0		0x40000
-#define	CONTENTS_CURRENT_90		0x80000
-#define	CONTENTS_CURRENT_180	0x100000
-#define	CONTENTS_CURRENT_270	0x200000
-#define	CONTENTS_CURRENT_UP		0x400000
-#define	CONTENTS_CURRENT_DOWN	0x800000
 
 #define	CONTENTS_ORIGIN			    0x1000000	  // removed before bsping an entity
 
@@ -267,14 +83,6 @@
 
 
 
-typedef struct texinfo_s
-{
-	float		vecs[2][4];		// [s/t][xyz offset]
-	int			flags;			// miptex flags + overrides
-	int			value;			// light emission, etc
-	char		texture[32];	// texture name (textures/*.wal)
-	int			nexttexinfo;	// for animations, -1 = end of chain
-} texinfo_t;
 
 
 #define	SURF_LIGHT		0x1		// value will hold the light strength
Index: q3radiant/Radiant.cpp
===================================================================
--- q3radiant/Radiant.cpp	(revision 436)
+++ q3radiant/Radiant.cpp	(working copy)
@@ -26,11 +26,12 @@
 #include "Radiant.h"
 
 #include "MainFrm.h"
-#include "ChildFrm.h"
 #include "RadiantDoc.h"
 #include "RadiantView.h"
 #include "PrefsDlg.h"
 
+extern bool g_bClosingRadiant;
+
 #ifdef _DEBUG
 #define new DEBUG_NEW
 #undef THIS_FILE
@@ -59,12 +60,11 @@
 	// TODO: add construction code here,
 	// Place all significant initialization in InitInstance
 }
+CRadiantApp::~CRadiantApp()
+{
 
-/////////////////////////////////////////////////////////////////////////////
-// The one and only CRadiantApp object
+}
 
-CRadiantApp theApp;
-
 /////////////////////////////////////////////////////////////////////////////
 // CRadiantApp initialization
 
@@ -255,7 +255,67 @@
 	return CWinApp::OnIdle(lCount);
 }
 
+void CRadiantApp::OnClose()
+{
+
+}
 void CRadiantApp::OnHelp() 
 {
   ShellExecute(m_pMainWnd->GetSafeHwnd(), "open", m_pszHelpFilePath, NULL, NULL, SW_SHOW);
 }
+
+int CRadiantApp::Run( void ) 
+{
+	BOOL bIdle = TRUE;
+	LONG lIdleCount = 0;
+
+
+//#if _MSC_VER >= 1300
+//	MSG *msg = AfxGetCurrentMessage();			// TODO Robert fix me!!
+//#else
+	MSG *msg = &m_msgCur;
+//#endif
+
+	// phase1: check to see if we can do idle work
+	while (bIdle &&	!::PeekMessage(msg, NULL, NULL, NULL, PM_NOREMOVE)) {
+		// call OnIdle while in bIdle state
+		if (!OnIdle(lIdleCount++)) {
+			bIdle = FALSE; // assume "no idle" state
+		}
+	}
+
+	// phase2: pump messages while available
+	do {
+		// pump message, but quit on WM_QUIT
+		if (!PumpMessage()) {
+			return ExitInstance();
+		}
+
+		// reset "no idle" state after pumping "normal" message
+		if (IsIdleMessage(msg)) {
+			bIdle = TRUE;
+			lIdleCount = 0;
+		}
+
+	} while (::PeekMessage(msg, NULL, NULL, NULL, PM_NOREMOVE));
+
+	return 0;
+}
+void main()
+{
+	CRadiantApp* app = new CRadiantApp();
+
+	AfxWinInit( GetModuleHandle(NULL), NULL, "", SW_SHOW );
+	AfxInitRichEdit();
+
+	app->InitApplication();
+    app->InitInstance();
+
+	while(g_bClosingRadiant==false) {
+		int iRunResult = app->Run();
+		//printf("iRunResult: %i\n",iRunResult);
+	}
+
+	app->ExitInstance();
+	delete app;
+}
\ No newline at end of file
Index: q3radiant/Radiant.h
===================================================================
--- q3radiant/Radiant.h	(revision 436)
+++ q3radiant/Radiant.h	(working copy)
@@ -44,6 +44,7 @@
 {
 public:
 	CRadiantApp();
+	virtual ~CRadiantApp();
 
 // Overrides
 	// ClassWizard generated virtual function overrides
@@ -53,10 +54,12 @@
 	virtual int ExitInstance();
 	virtual BOOL OnIdle(LONG lCount);
 	//}}AFX_VIRTUAL
-
+
+	virtual int Run( void ) ;
 // Implementation
 
 	//{{AFX_MSG(CRadiantApp)
+	afx_msg void OnClose();
 	afx_msg void OnHelp();
 	//}}AFX_MSG
 	DECLARE_MESSAGE_MAP()
Index: q3radiant/Radiant.rc
===================================================================
--- q3radiant/Radiant.rc	(revision 459)
+++ q3radiant/Radiant.rc	(working copy)
@@ -454,7 +454,6 @@
         MENUITEM "Cubic Clipping",              ID_VIEW_CUBICCLIPPING
         , CHECKED
         MENUITEM SEPARATOR
-        MENUITEM "OpenGL Lighting",             ID_VIEW_OPENGLLIGHTING
     END
     POPUP "&Selection"
     BEGIN
@@ -2763,10 +2762,6 @@
     IDR_SHADERTYPE          "\nUntitled\nSHADER Document\nShader Files (*.shader)\n.shader\nShaderFileType\nSHADER File Type\nSHADER\nShader Files\n"
 END
 
-STRINGTABLE DISCARDABLE 
-BEGIN
-    ID_VIEW_OPENGLLIGHTING  "Toggle OpenGL Lighting"
-END
 
 STRINGTABLE DISCARDABLE 
 BEGIN
Index: q3radiant/Radiant.vcproj
===================================================================
--- q3radiant/Radiant.vcproj	(revision 459)
+++ q3radiant/Radiant.vcproj	(working copy)
@@ -187,7 +187,7 @@
 				ProgramDatabaseFile=".\Debug/q3radiant.pdb"
 				GenerateMapFile="true"
 				MapFileName=".\Debug/q3radiant.map"
-				SubSystem="2"
+				SubSystem="0"
 				RandomizedBaseAddress="1"
 				DataExecutionPrevention="0"
 				TargetMachine="1"
@@ -602,31 +602,6 @@
 				</FileConfiguration>
 			</File>
 			<File
-				RelativePath="GroupDlg.cpp"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BrowseInformation="1"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
 				RelativePath="IShaders.cpp"
 				>
 				<FileConfiguration
@@ -802,56 +777,10 @@
 				</FileConfiguration>
 			</File>
 			<File
-				RelativePath="mru.cpp"
+				RelativePath=".\MRU.CPP"
 				>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BrowseInformation="1"
-					/>
-				</FileConfiguration>
 			</File>
 			<File
-				RelativePath="NameDlg.cpp"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BrowseInformation="1"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
 				RelativePath="NewProjDlg.cpp"
 				>
 				<FileConfiguration
@@ -1285,29 +1214,8 @@
 				</FileConfiguration>
 			</File>
 			<File
-				RelativePath="TexEdit.cpp"
+				RelativePath=".\TexEdit.cpp"
 				>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BrowseInformation="1"
-					/>
-				</FileConfiguration>
 			</File>
 			<File
 				RelativePath="TextureBar.cpp"
@@ -1673,10 +1581,6 @@
 				>
 			</File>
 			<File
-				RelativePath="ChildFrm.h"
-				>
-			</File>
-			<File
 				RelativePath="CommandsDlg.h"
 				>
 			</File>
@@ -1709,14 +1613,6 @@
 				>
 			</File>
 			<File
-				RelativePath="GroupBar.h"
-				>
-			</File>
-			<File
-				RelativePath="GroupDlg.h"
-				>
-			</File>
-			<File
 				RelativePath="LstToolBar.h"
 				>
 			</File>
@@ -1729,10 +1625,6 @@
 				>
 			</File>
 			<File
-				RelativePath="NameDlg.h"
-				>
-			</File>
-			<File
 				RelativePath="NewProjDlg.h"
 				>
 			</File>
@@ -1809,7 +1701,7 @@
 				>
 			</File>
 			<File
-				RelativePath="TexEdit.h"
+				RelativePath=".\TexEdit.h"
 				>
 			</File>
 			<File
@@ -1882,11 +1774,11 @@
 				>
 			</File>
 			<File
-				RelativePath="q.bmp"
+				RelativePath="res\q.bmp"
 				>
 			</File>
 			<File
-				RelativePath="res\q.bmp"
+				RelativePath="q.bmp"
 				>
 			</File>
 			<File
@@ -1918,11 +1810,11 @@
 				>
 			</File>
 			<File
-				RelativePath="res\toolbar1.bmp"
+				RelativePath="toolbar1.bmp"
 				>
 			</File>
 			<File
-				RelativePath="toolbar1.bmp"
+				RelativePath="res\toolbar1.bmp"
 				>
 			</File>
 			<File
Index: q3radiant/resource.h
===================================================================
--- q3radiant/resource.h	(revision 459)
+++ q3radiant/resource.h	(working copy)
@@ -633,7 +633,6 @@
 #define ID_SHOW_ENTITIES                32990
 #define ID_VIEW_ENTITIESAS_WIREFRAME    32991
 #define ID_VIEW_SHOWHINT                32993
-#define ID_VIEW_OPENGLLIGHTING          32998
 #define ID_VIEW_SHOWCAULK               32999
 #define ID_VIEW_SHOWANGLES              33000
 #define ID_EDIT_SAVEPREFAB              33001
Index: q3radiant/SELECT.CPP
===================================================================
--- q3radiant/SELECT.CPP	(revision 459)
+++ q3radiant/SELECT.CPP	(working copy)
@@ -43,8 +43,8 @@
 #define	DIST_START	999999
 trace_t Test_Ray (vec3_t origin, vec3_t dir, int flags)
 {
-	brush_t	*brush;
-	face_t	*face;
+	brush_s	*brush;
+	face_s	*face;
 	float	dist;
 	trace_t	t;
 
@@ -54,7 +54,7 @@
 	if (flags & SF_CYCLE)
 	{
 		CPtrArray array;
-		brush_t *pToSelect = (selected_brushes.next != &selected_brushes) ? selected_brushes.next : NULL;
+		brush_s *pToSelect = (selected_brushes.next != &selected_brushes) ? selected_brushes.next : NULL;
 		Select_Deselect();
 
 		// go through active brushes and accumulate all "hit" brushes
@@ -89,19 +89,19 @@
 			bool bFound = false;
 			for (int i = 0; i < nSize; i++)
 			{
-				brush_t *b = reinterpret_cast<brush_t*>(array.GetAt(i));
+				brush_s *b = reinterpret_cast<brush_s*>(array.GetAt(i));
 				// did we hit the last one selected yet ?
 				if (b == pToSelect)
 				{
 					// yes we want to select the next one in the list 
 					int n = (i > 0) ? i-1 : nSize-1;
-					pToSelect = reinterpret_cast<brush_t*>(array.GetAt(n));
+					pToSelect = reinterpret_cast<brush_s*>(array.GetAt(n));
 					bFound = true;
 					break;
 				}
 			}
 			if (!bFound)
-				pToSelect = reinterpret_cast<brush_t*>(array.GetAt(0));
+				pToSelect = reinterpret_cast<brush_s*>(array.GetAt(0));
 		}
 		if (pToSelect)
 		{
@@ -186,10 +186,10 @@
 
 ============
 */
-void Select_Brush (brush_t *brush, bool bComplete, bool bStatus)
+void Select_Brush (brush_s *brush, bool bComplete, bool bStatus)
 {
-	brush_t	*b;
-	entity_t	*e;
+	brush_s	*b;
+	entity_s	*e;
 
   g_ptrSelectedFaces.RemoveAll();
   g_ptrSelectedFaceBrushes.RemoveAll();
@@ -263,7 +263,7 @@
 		bool bOk = true;
 		for (int i = 0; i < nCount; i++)
 		{
-			if (t.face == reinterpret_cast<face_t*>(g_SelectedFaces.GetAt(i)))
+			if (t.face == reinterpret_cast<face_s*>(g_SelectedFaces.GetAt(i)))
 			{
 				bOk = false;
 				// need to move remove i'th entry
@@ -281,7 +281,7 @@
 		Sys_UpdateWindows (W_ALL);
 		clearSelection();
 		// Texture_SetTexture requires a brushprimit_texdef fitted to the default width=2 height=2 texture
-		brushprimit_texdef_t brushprimit_texdef;
+		brushprimit_texdef_s brushprimit_texdef;
 		ConvertTexMatWithQTexture ( &t.face->brushprimit_texdef, t.face->d_texture, &brushprimit_texdef, NULL );
 		Texture_SetTexture ( &t.face->texdef, &brushprimit_texdef, false, false );
 		UpdateSurfaceDialog();
@@ -309,7 +309,7 @@
 
 void Select_Delete (void)
 {
-	brush_t	*brush;
+	brush_s	*brush;
 
   g_ptrSelectedFaces.RemoveAll();
   g_ptrSelectedFaceBrushes.RemoveAll();
@@ -338,7 +338,7 @@
 
 void Select_Deselect (bool bDeselectFaces)
 {
-	brush_t	*b;
+	brush_s	*b;
 
   Patch_Deselect();
 
@@ -393,7 +393,7 @@
 */
 void Select_Move (vec3_t delta, bool bSnap)
 {
-	brush_t	*b;
+	brush_s	*b;
   
  
 // actually move the selected brushes
@@ -430,9 +430,9 @@
   Sys_UpdateWindows(W_ALL);
 #else
 
-	brush_t		*b, *b2, *n, *next, *next2;
+	brush_s		*b, *b2, *n, *next, *next2;
 	vec3_t		delta;
-	entity_t	*e;
+	entity_s	*e;
 
 	g_qeglobals.d_workcount++;
 	clearSelection();
@@ -516,9 +516,9 @@
 		if NULL, means we have no information, ask for a default
 ============
 */
-void WINAPI Select_SetTexture (texdef_t *texdef, brushprimit_texdef_t *brushprimit_texdef, bool bFitScale, void* pPlugTexdef )
+void WINAPI Select_SetTexture (texdef_t *texdef, brushprimit_texdef_s *brushprimit_texdef, bool bFitScale, void* pPlugTexdef )
 {
-	brush_t	*b;
+	brush_s	*b;
 	int nCount = g_ptrSelectedFaces.GetSize();
 	if (nCount > 0)
 	{
@@ -526,8 +526,8 @@
 		ASSERT(g_ptrSelectedFaces.GetSize() == g_ptrSelectedFaceBrushes.GetSize());
 		for (int i = 0; i < nCount; i++)
 		{
-			face_t *selFace = reinterpret_cast<face_t*>(g_ptrSelectedFaces.GetAt(i));
-			brush_t *selBrush = reinterpret_cast<brush_t*>(g_ptrSelectedFaceBrushes.GetAt(i));
+			face_s *selFace = reinterpret_cast<face_s*>(g_ptrSelectedFaces.GetAt(i));
+			brush_s *selBrush = reinterpret_cast<brush_s*>(g_ptrSelectedFaceBrushes.GetAt(i));
 			Undo_AddBrush(selBrush);
 			SetFaceTexdef (selBrush, selFace, texdef, brushprimit_texdef, bFitScale, static_cast<IPluginTexdef *>(pPlugTexdef) );
 			Brush_Build(selBrush, bFitScale);
@@ -561,7 +561,7 @@
 
 void Select_GetBounds (edVec3_c &mins, edVec3_c &maxs)
 {
-	brush_t	*b;
+	brush_s	*b;
 	int		i;
 
 	for (i=0 ; i<3 ; i++)
@@ -615,8 +615,8 @@
 
 void Select_ApplyMatrix (bool bSnap, bool bRotation, int nAxis, float fDeg)
 {
-	brush_t	*b;
-	face_t	*f;
+	brush_s	*b;
+	face_s	*f;
 	int		i, j;
 	edVec3_c	temp;
 
@@ -639,13 +639,13 @@
 			}
 		}
 
-		if(b->owner->eclass->fixedsize)
-		{
-			if (bRotation && b->owner->md3Class)
-			{
-				b->owner->vRotation[nAxis] += fDeg;
-			}
-		}
+		//if(b->owner->eclass->fixedsize)
+		//{
+		//	if (bRotation && b->owner->md3Class)
+		//	{
+		//		b->owner->vRotation[nAxis] += fDeg;
+		//	}
+		//}
 
 		Brush_Build(b, bSnap);
     
@@ -669,13 +669,14 @@
 		p[0] = 0;
 	else if (fabs(dir[1]) == 1)
 		p[1] = 0;
-	else p[2] = 0;
+	else
+		p[2] = 0;
 }
 
 
 
 // using scale[0] and scale[1]
-void ComputeScale(const edVec3_c &rex, const edVec3_c &rey, edVec3_c &p, const face_t *f)
+void ComputeScale(const edVec3_c &rex, const edVec3_c &rey, edVec3_c &p, const face_s *f)
 {
 	float px = rex.dotProduct(p);
 	float py = rey.dotProduct(p);
@@ -689,7 +690,7 @@
 	p += aux;
 }
 
-void ComputeAbsolute(face_t* f, edVec3_c &p1, edVec3_c &p2, edVec3_c &p3)
+void ComputeAbsolute(face_s* f, edVec3_c &p1, edVec3_c &p2, edVec3_c &p3)
 {
 	edVec3_c ex,ey,ez;	        // local axis base
 
@@ -734,7 +735,7 @@
 };
 
 
-void AbsoluteToLocal(const class edPlane_c &normal2, face_t* f, edVec3_c& p1, edVec3_c& p2, edVec3_c& p3)
+void AbsoluteToLocal(const class edPlane_c &normal2, face_s* f, edVec3_c& p1, edVec3_c& p2, edVec3_c& p3)
 {
 	edVec3_c ex,ey,ez;
 
@@ -798,7 +799,7 @@
 
 }
 
-void RotateFaceTexture(face_t* f, int nAxis, float fDeg)
+void RotateFaceTexture(face_s* f, int nAxis, float fDeg)
 {
 	edVec3_c p1,p2,p3, rota;   
 	p1.clear();
@@ -827,9 +828,9 @@
 
 void RotateTextures(int nAxis, float fDeg, vec3_t vOrigin)
 {
-	for (brush_t* b=selected_brushes.next ; b != &selected_brushes ; b=b->next)
+	for (brush_s* b=selected_brushes.next ; b != &selected_brushes ; b=b->next)
 	{
-		for (face_t* f=b->brush_faces ; f ; f=f->next)
+		for (face_s* f=b->brush_faces ; f ; f=f->next)
 		{
 			if (g_qeglobals.m_bBrushPrimitMode)
 				RotateFaceTexture_BrushPrimit( f, nAxis, fDeg, vOrigin );
@@ -864,9 +865,9 @@
 void Select_Scale(float x, float y, float z)
 {
 	Select_GetMid (select_origin);
-	for (brush_t* b=selected_brushes.next ; b != &selected_brushes ; b=b->next)
+	for (brush_s* b=selected_brushes.next ; b != &selected_brushes ; b=b->next)
 	{
-		for (face_t* f=b->brush_faces ; f ; f=f->next)
+		for (face_s* f=b->brush_faces ; f ; f=f->next)
 		{
 			for (int i=0 ; i<3 ; i++)
 			{
@@ -1002,7 +1003,7 @@
 
 void Select_CompleteTall (void)
 {
-	brush_t	*b, *next;
+	brush_s	*b, *next;
 	//int		i;
 	edVec3_c	mins, maxs;
 
@@ -1048,7 +1049,7 @@
 
 void Select_PartialTall (void)
 {
-	brush_t	*b, *next;
+	brush_s	*b, *next;
 	//int		i;
 	edVec3_c	mins, maxs;
 
@@ -1096,7 +1097,7 @@
 
 void Select_Touching (void)
 {
-	brush_t	*b, *next;
+	brush_s	*b, *next;
 	int		i;
 	edVec3_c	mins, maxs;
 
@@ -1130,7 +1131,7 @@
 
 void Select_Inside (void)
 {
-	brush_t	*b, *next;
+	brush_s	*b, *next;
 	int		i;
 	edVec3_c	mins, maxs;
 
@@ -1172,8 +1173,8 @@
 void Select_Ungroup(void)
 {
 	int numselectedgroups;
-	entity_t	*e;
-	brush_t		*b, *sb;
+	entity_s	*e;
+	brush_s		*b, *sb;
 
 	numselectedgroups = 0;
 	for (sb = selected_brushes.next; sb != &selected_brushes; sb = sb->next)
@@ -1215,8 +1216,8 @@
 */
 void Select_MakeStructural (void)
 {
-	brush_t	*b;
-	face_t	*f;
+	brush_s	*b;
+	face_s	*f;
 
 	for (b=selected_brushes.next ; b != &selected_brushes ; b=b->next)
 		for (f=b->brush_faces ; f ; f=f->next)
@@ -1227,8 +1228,8 @@
 
 void Select_MakeDetail (void)
 {
-	brush_t	*b;
-	face_t	*f;
+	brush_s	*b;
+	face_s	*f;
 
 	for (b=selected_brushes.next ; b != &selected_brushes ; b=b->next)
 		for (f=b->brush_faces ; f ; f=f->next)
@@ -1239,8 +1240,8 @@
 
 void Select_ShiftTexture(int x, int y)
 {
-	brush_t		*b;
-	face_t		*f;
+	brush_s		*b;
+	face_s		*f;
 
   int nFaceCount = g_ptrSelectedFaces.GetSize();
 
@@ -1274,8 +1275,8 @@
 	{
     for (int i = 0; i < nFaceCount; i++)
     {
-      face_t *selFace = reinterpret_cast<face_t*>(g_ptrSelectedFaces.GetAt(i));
-      brush_t *selBrush = reinterpret_cast<brush_t*>(g_ptrSelectedFaceBrushes.GetAt(i));
+      face_s *selFace = reinterpret_cast<face_s*>(g_ptrSelectedFaces.GetAt(i));
+      brush_s *selBrush = reinterpret_cast<brush_s*>(g_ptrSelectedFaceBrushes.GetAt(i));
   		if (g_qeglobals.m_bBrushPrimitMode)
 	  	{
 
@@ -1298,8 +1299,8 @@
 
 void Select_ScaleTexture(int x, int y)
 {
-	brush_t		*b;
-	face_t		*f;
+	brush_s		*b;
+	face_s		*f;
 
   int nFaceCount = g_ptrSelectedFaces.GetSize();
 
@@ -1318,7 +1319,7 @@
 				float	shift[2];
 				float	rotate;
 				float	scale[2];
-				brushprimit_texdef_t bp; 
+				brushprimit_texdef_s bp; 
 				// compute normalized texture matrix
 				ConvertTexMatWithQTexture( &f->brushprimit_texdef, f->d_texture, &bp, NULL );
 				// compute fake shift scale rot
@@ -1348,14 +1349,14 @@
 	{
     for (int i = 0; i < nFaceCount; i++)
     {
-      face_t *selFace = reinterpret_cast<face_t*>(g_ptrSelectedFaces.GetAt(i));
-      brush_t *selBrush = reinterpret_cast<brush_t*>(g_ptrSelectedFaceBrushes.GetAt(i));
+      face_s *selFace = reinterpret_cast<face_s*>(g_ptrSelectedFaces.GetAt(i));
+      brush_s *selBrush = reinterpret_cast<brush_s*>(g_ptrSelectedFaceBrushes.GetAt(i));
 		  if (g_qeglobals.m_bBrushPrimitMode)
 		  {
 			  float	shift[2];
 			  float	rotate;
 			  float	scale[2];
-			  brushprimit_texdef_t bp; 
+			  brushprimit_texdef_s bp; 
 			  ConvertTexMatWithQTexture( &selFace->brushprimit_texdef, selFace->d_texture, &bp, NULL );
 			  TexMatToFakeTexCoords( bp.coords, shift, &rotate, scale );
 			  scale[0]+=static_cast<float>(x)*0.1;
@@ -1377,8 +1378,8 @@
 
 void Select_RotateTexture(int amt)
 {
-	brush_t		*b;
-	face_t		*f;
+	brush_s		*b;
+	face_s		*f;
 
   int nFaceCount = g_ptrSelectedFaces.GetSize();
 
@@ -1397,7 +1398,7 @@
 				float	shift[2];
 				float	rotate;
 				float	scale[2];
-				brushprimit_texdef_t bp; 
+				brushprimit_texdef_s bp; 
 				// compute normalized texture matrix
 				ConvertTexMatWithQTexture( &f->brushprimit_texdef, f->d_texture, &bp, NULL );
 				// compute fake shift scale rot
@@ -1427,14 +1428,14 @@
 	{
     for (int i = 0; i < nFaceCount; i++)
     {
-      face_t *selFace = reinterpret_cast<face_t*>(g_ptrSelectedFaces.GetAt(i));
-      brush_t *selBrush = reinterpret_cast<brush_t*>(g_ptrSelectedFaceBrushes.GetAt(i));
+      face_s *selFace = reinterpret_cast<face_s*>(g_ptrSelectedFaces.GetAt(i));
+      brush_s *selBrush = reinterpret_cast<brush_s*>(g_ptrSelectedFaceBrushes.GetAt(i));
 		  if (g_qeglobals.m_bBrushPrimitMode)
 		  {
 			  float	shift[2];
 			  float	rotate;
 			  float	scale[2];
-			  brushprimit_texdef_t bp; 
+			  brushprimit_texdef_s bp; 
 			  ConvertTexMatWithQTexture( &selFace->brushprimit_texdef, selFace->d_texture, &bp, NULL );
 			  TexMatToFakeTexCoords( bp.coords, shift, &rotate, scale );
 			  rotate += amt;
@@ -1456,13 +1457,13 @@
 
 void FindReplaceTextures(const char* pFind, const char* pReplace, bool bSelected, bool bForce)
 {
-	brush_t* pList = (bSelected) ? &selected_brushes : &active_brushes;
+	brush_s* pList = (bSelected) ? &selected_brushes : &active_brushes;
 	if (!bSelected)
 	{
 		Select_Deselect();
 	}
  
-	for (brush_t* pBrush = pList->next ; pBrush != pList; pBrush = pBrush->next)
+	for (brush_s* pBrush = pList->next ; pBrush != pList; pBrush = pBrush->next)
 	{
 		if (pBrush->patchBrush)
 		{
@@ -1469,7 +1470,7 @@
 			Patch_FindReplaceTexture(pBrush, pFind, pReplace, bForce);
 		}
 
-		for (face_t* pFace = pBrush->brush_faces; pFace; pFace = pFace->next)
+		for (face_s* pFace = pBrush->brush_faces; pFace; pFace = pFace->next)
 		{
 			if(bForce || strcmpi(pFace->texdef.name, pFind) == 0)
 			{
@@ -1486,8 +1487,8 @@
 
 void Select_AllOfType()
 {
-	brush_t	*b, *next;
-	entity_t	*e;
+	brush_s	*b, *next;
+	entity_s	*e;
 	if ( (selected_brushes.next == &selected_brushes)
 		|| (selected_brushes.next->next != &selected_brushes) )
 	{
@@ -1499,7 +1500,7 @@
     }
     else
     {
-      face_t *selFace = reinterpret_cast<face_t*>(g_ptrSelectedFaces.GetAt(0));
+      face_s *selFace = reinterpret_cast<face_s*>(g_ptrSelectedFaces.GetAt(0));
       strName = selFace->texdef.name;
     }
 
@@ -1521,7 +1522,7 @@
       }
       else
       {
-        for (face_t* pFace = b->brush_faces; pFace; pFace = pFace->next)
+        for (face_s* pFace = b->brush_faces; pFace; pFace = pFace->next)
         {
           if (strcmpi(strName, pFace->texdef.name) == 0)
           {
@@ -1583,7 +1584,7 @@
 
 void Select_Reselect()
 {
-	brush_t* b;
+	brush_s* b;
   CPtrArray holdArray;
 	for (b=selected_brushes.next ; b && b != &selected_brushes ; b=b->next)
 	{
@@ -1593,7 +1594,7 @@
   int n = holdArray.GetSize();
   while (n-- > 0)
   {
-    b = reinterpret_cast<brush_t*>(holdArray.GetAt(n));
+    b = reinterpret_cast<brush_s*>(holdArray.GetAt(n));
     Select_Brush(b);
   }
 	Sys_UpdateWindows (W_ALL);
@@ -1602,7 +1603,7 @@
 
 void Select_FitTexture(int nHeight, int nWidth)
 {
-	brush_t		*b;
+	brush_s		*b;
 
   int nFaceCount = g_ptrSelectedFaces.GetSize();
 
@@ -1619,8 +1620,8 @@
 	{
     for (int i = 0; i < nFaceCount; i++)
     {
-      face_t *selFace = reinterpret_cast<face_t*>(g_ptrSelectedFaces.GetAt(i));
-      brush_t *selBrush = reinterpret_cast<brush_t*>(g_ptrSelectedFaceBrushes.GetAt(i));
+      face_s *selFace = reinterpret_cast<face_s*>(g_ptrSelectedFaces.GetAt(i));
+      brush_s *selBrush = reinterpret_cast<brush_s*>(g_ptrSelectedFaceBrushes.GetAt(i));
       Face_FitTexture(selFace, nHeight, nWidth);
 	  	Brush_Build(selBrush);
     }
@@ -1636,7 +1637,7 @@
 
 void Select_Hide()
 {
-	for (brush_t* b=selected_brushes.next ; b && b != &selected_brushes ; b=b->next)
+	for (brush_s* b=selected_brushes.next ; b && b != &selected_brushes ; b=b->next)
 	{
     b->hiddenBrush = true;
 	}
@@ -1645,7 +1646,7 @@
 
 void Select_ShowAllHidden()
 {
-  brush_t* b;
+  brush_s* b;
 	for (b=selected_brushes.next ; b && b != &selected_brushes ; b=b->next)
 	{
     b->hiddenBrush = false;
@@ -1665,7 +1666,7 @@
 */
 void Select_Invert(void)
 {
-	brush_t *next, *prev;
+	brush_s *next, *prev;
 
 	Sys_Printf("inverting selection...\n");
 
@@ -1701,37 +1702,3 @@
 	Sys_Printf("done.\n");
 }
 
-
-/* 
-===========
-Select_Name
-===========
-*/
-void Select_Name(const char *pName)
-{
-	if (g_qeglobals.m_bBrushPrimitMode)
-  {
-	  for (brush_t* b=selected_brushes.next ; b && b != &selected_brushes ; b=b->next)
-	  {
-      Brush_SetEpair(b, "Name", pName);
-	  }
-  }
-}
-
-/* 
-=================
-Select_AddToGroup
-add selected brushes to a group, update the tree
-=================
-*/
-void Select_AddToGroup(const char *pName)
-{
-	if (g_qeglobals.m_bBrushPrimitMode)
-  {
-	  for (brush_t* b=selected_brushes.next ; b && b != &selected_brushes ; b=b->next)
-	  {
-      Brush_SetEpair(b, "group", pName);
-			Group_AddToProperGroup(b);
-	  }
-  }
-}
Index: q3radiant/SELECT.H
===================================================================
--- q3radiant/SELECT.H	(revision 459)
+++ q3radiant/SELECT.H	(working copy)
@@ -36,8 +36,8 @@
 
 typedef struct
 {
-	brush_t		*brush;
-	face_t		*face;
+	brush_s		*brush;
+	face_s		*face;
 	float		dist;
 	bool	selected;
 } trace_t;
@@ -55,7 +55,7 @@
 trace_t Test_Ray (vec3_t origin, vec3_t dir, int flags);
 
 void Select_GetBounds (edVec3_c &mins, edVec3_c &maxs);
-void Select_Brush (brush_t *b, bool bComplete = true, bool bStatus = true);
+void Select_Brush (brush_s *b, bool bComplete = true, bool bStatus = true);
 void Select_Ray (vec3_t origin, vec3_t dir, int flags);
 void Select_Delete (void);
 void Select_Deselect (bool bDeselectFaces = true);
@@ -62,7 +62,7 @@
 void Select_Invert(void);
 void Select_Clone (void);
 void Select_Move (vec3_t delta, bool bSnap = true);
-void WINAPI Select_SetTexture (texdef_t *texdef, brushprimit_texdef_t *brushprimit_texdef, bool bFitScale = false, void* pPlugTexdef = NULL);
+void WINAPI Select_SetTexture (texdef_t *texdef, brushprimit_texdef_s *brushprimit_texdef, bool bFitScale = false, void* pPlugTexdef = NULL);
 void Select_FlipAxis (int axis);
 void Select_RotateAxis (int axis, float deg, bool bPaint = true, bool bMouse = false);
 void Select_CompleteTall (void);
@@ -77,11 +77,8 @@
 
 // absolute texture coordinates
 // TTimo NOTE: this is stuff for old brushes format and rotation texture lock .. sort of in-between with bush primitives
-void ComputeAbsolute(face_t* f, edVec3_c &p1, edVec3_c &p2, edVec3_c &p3);
-void AbsoluteToLocal(const class edPlane_c &normal2, face_t* f, edVec3_c& p1, edVec3_c& p2, edVec3_c& p3);
+void ComputeAbsolute(face_s* f, edVec3_c &p1, edVec3_c &p2, edVec3_c &p3);
+void AbsoluteToLocal(const class edPlane_c &normal2, face_s* f, edVec3_c& p1, edVec3_c& p2, edVec3_c& p3);
 void Select_Hide();
 void Select_ShowAllHidden();
-// add selected brushes to a group, update the tree
-void Select_AddToGroup(const char *pName);
-void Select_Name(const char *pName);
 void clearSelection();
Index: q3radiant/ShaderInfo.cpp
===================================================================
--- q3radiant/ShaderInfo.cpp	(revision 436)
+++ q3radiant/ShaderInfo.cpp	(working copy)
@@ -33,15 +33,12 @@
 #define new DEBUG_NEW
 #endif
 
-//////////////////////////////////////////////////////////////////////
-// Construction/Destruction
-//////////////////////////////////////////////////////////////////////
 
 CShaderInfo::CShaderInfo()
 {
-  m_fTransValue = 1.0;
-  m_nFlags = 0;
-  m_pQTexture = NULL;
+	m_fTransValue = 1.0;
+	m_nFlags = 0;
+	m_pQTexture = NULL;
 }
 
 CShaderInfo::~CShaderInfo()
@@ -49,21 +46,13 @@
 
 }
 
-void CShaderInfo::Parse(const char *pName)
-{
-
-}
-
 void CShaderInfo::setName(char *pName)
 {
-  //--char path[1024];
-  //--strcpy(path, pName);
-  //--DefaultExtension(path, ".tga");
-  m_strName = pName;
-  m_strName.MakeLower();
-  if (m_strName.Find("textures") == 0)
-  {
-    CString s = m_strName.Right(m_strName.GetLength() - strlen("textures") - 1);
-    m_strName = s;
-  }
+	m_strName = pName;
+	m_strName.MakeLower();
+	if (m_strName.Find("textures") == 0)
+	{
+		CString s = m_strName.Right(m_strName.GetLength() - strlen("textures") - 1);
+		m_strName = s;
+	}
 }
Index: q3radiant/ShaderInfo.h
===================================================================
--- q3radiant/ShaderInfo.h	(revision 436)
+++ q3radiant/ShaderInfo.h	(working copy)
@@ -38,18 +38,15 @@
 	CString m_strTextureName;
 	CStringList m_strEditorParams;
 	CStringList m_lstSurfaceParams;
-  float m_fTransValue;
-  int m_nFlags;
-  qtexture_t *m_pQTexture;
-	
-  
-  void Parse(const char *pName);
+	float m_fTransValue;
+	int m_nFlags;
+	qtexture_t *m_pQTexture;
+
+
 	CShaderInfo();
 	virtual ~CShaderInfo();
-  void setName(char *pName);
 
-  
-
+	void setName(char *pName);
 };
 
 #endif // !defined(AFX_SHADERINFO_H__93B64600_A208_11D2_803D_0020AFEB881A__INCLUDED_)
Index: q3radiant/StdAfx.h
===================================================================
--- q3radiant/StdAfx.h	(revision 443)
+++ q3radiant/StdAfx.h	(working copy)
@@ -85,7 +85,7 @@
 extern void WXY_Print();
 extern void AddProp( void );
 extern bool DoColor(int iIndex);
-extern entity_t	*edit_entity;
+extern entity_s	*edit_entity;
 extern int inspector_mode;
 extern bool g_bRotateMode;
 extern bool g_bClipMode;
@@ -103,7 +103,7 @@
 extern void FindReplaceTextures(const char* pFind, const char* pReplace, bool bSelected, bool bForce);
 extern void DoProjectSettings();
 extern bool region_active;
-extern void Brush_Print(brush_t* b);
+extern void Brush_Print(brush_s* b);
 extern void	Texture_ShowDirectory (char* pPath, bool Linked = false);
 extern void Map_ImportFile (char *filename);
 extern void Map_SaveSelected(char* pFilename);
@@ -111,11 +111,11 @@
 extern bool g_bNewFace;
 extern void Select_GetTrueMid (vec3_t mid);
 extern bool g_bSwitch;
-extern brush_t g_brFrontSplits;
-extern brush_t g_brBackSplits;
+extern brush_s g_brFrontSplits;
+extern brush_s g_brBackSplits;
 extern CClipPoint g_Clip1;
 extern CClipPoint g_Clip2;
-extern brush_t* g_pSplitList;
+extern brush_s* g_pSplitList;
 extern CClipPoint g_PathPoints[256];
 extern void AcquirePath(int nCount, PFNPathCallback* pFunc);
 extern bool g_bScreenUpdates;
@@ -128,7 +128,7 @@
 extern void RunScriptByName(char*, bool);
 extern void DoNewColor(int* i1, int* i2, int* i3);
 extern void UpdateSurfaceDialog();
-extern void CSG_SplitBrushByFace (brush_t *in, face_t *f, brush_t **front, brush_t **back);
+extern void CSG_SplitBrushByFace (brush_s *in, face_s *f, brush_s **front, brush_s **back);
 extern void HandlePopup(CWnd* pWindow, unsigned int uId);
 extern z_t z;
 extern void Select_Scale(float x, float y, float z);
Index: q3radiant/SurfaceDlg.cpp
===================================================================
--- q3radiant/SurfaceDlg.cpp	(revision 439)
+++ q3radiant/SurfaceDlg.cpp	(working copy)
@@ -153,9 +153,9 @@
 {
 	char	sz[128];
 	texdef_t *pt;
-	brushprimit_texdef_t	*bpt;
+	brushprimit_texdef_s	*bpt;
 	// local copy if a width=2 height=2 qtetxture_t is needed
-	brushprimit_texdef_t	local_bp;
+	brushprimit_texdef_s	local_bp;
 	int		i;
 
 	if (!g_surfwin)
@@ -186,7 +186,7 @@
 	{
 		if (g_bNewFace && g_ptrSelectedFaces.GetSize() > 0)
 		{
-      face_t *selFace = reinterpret_cast<face_t*>(g_ptrSelectedFaces.GetAt(0));
+      face_s *selFace = reinterpret_cast<face_s*>(g_ptrSelectedFaces.GetAt(0));
 			pt = &selFace->texdef;
 			if (g_qeglobals.m_bBrushPrimitMode)
 			{
@@ -323,7 +323,7 @@
 	{
 		if (g_bNewFace && g_ptrSelectedFaces.GetSize() > 0)
     {
-      face_t *selFace = reinterpret_cast<face_t*>(g_ptrSelectedFaces.GetAt(0));
+      face_s *selFace = reinterpret_cast<face_s*>(g_ptrSelectedFaces.GetAt(0));
 			pt = &selFace->texdef;
     }
 		else
@@ -381,14 +381,14 @@
 	g_changed_surface = true;
 
 	// a local copy of the texture matrix, given for a qtexture_t with width=2 height=2
-	brushprimit_texdef_t	local_bp;
-	brushprimit_texdef_t	*bpt;
+	brushprimit_texdef_s	local_bp;
+	brushprimit_texdef_s	*bpt;
 	if (g_qeglobals.m_bBrushPrimitMode)
 	{
-    face_t *selFace = NULL;
+    face_s *selFace = NULL;
 		if (g_bNewFace && g_ptrSelectedFaces.GetSize() > 0)
     {
-      selFace = reinterpret_cast<face_t*>(g_ptrSelectedFaces.GetAt(0));
+      selFace = reinterpret_cast<face_s*>(g_ptrSelectedFaces.GetAt(0));
 			bpt = &selFace->brushprimit_texdef;
     }
 		else
@@ -480,7 +480,7 @@
 		GetTexMods ();
 		if (g_bNewFace && g_ptrSelectedFaces.GetSize() > 0)
     {
-      face_t *selFace = reinterpret_cast<face_t*>(g_ptrSelectedFaces.GetAt(0));
+      face_s *selFace = reinterpret_cast<face_s*>(g_ptrSelectedFaces.GetAt(0));
 			pt = &selFace->texdef;
     }
 		else
@@ -578,14 +578,14 @@
 		}
 	}
 	// a local copy of the texture matrix, given for a qtexture_t with width=2 height=2
-	brushprimit_texdef_t	local_bp;
-	brushprimit_texdef_t	*bpt;
+	brushprimit_texdef_s	local_bp;
+	brushprimit_texdef_s	*bpt;
 	if (g_qeglobals.m_bBrushPrimitMode)
 	{
-    face_t *selFace = NULL;
+    face_s *selFace = NULL;
 		if (g_bNewFace && g_ptrSelectedFaces.GetSize() > 0)
     {
-      selFace = reinterpret_cast<face_t*>(g_ptrSelectedFaces.GetAt(0));
+      selFace = reinterpret_cast<face_s*>(g_ptrSelectedFaces.GetAt(0));
 			bpt = &selFace->brushprimit_texdef;
     }
 		else
@@ -612,7 +612,7 @@
 	GetTexMods ();
   if (g_bNewFace && g_ptrSelectedFaces.GetSize() > 0)
   {
-    face_t *selFace = reinterpret_cast<face_t*>(g_ptrSelectedFaces.GetAt(0));
+    face_s *selFace = reinterpret_cast<face_s*>(g_ptrSelectedFaces.GetAt(0));
 		pt = &selFace->texdef;
   }
   else
@@ -946,10 +946,10 @@
   UpdateData(TRUE);
   if (g_ptrSelectedFaces.GetSize() == 0)
   {
-    brush_t *b;
+    brush_s *b;
 		for (b=selected_brushes.next ; b != &selected_brushes ; b=b->next)
     {
-      for (face_t* pFace = b->brush_faces; pFace; pFace = pFace->next)
+      for (face_s* pFace = b->brush_faces; pFace; pFace = pFace->next)
       {
         g_ptrSelectedFaces.Add(pFace);
         g_ptrSelectedFaceBrushes.Add(b);
Index: q3radiant/TextureBar.cpp
===================================================================
--- q3radiant/TextureBar.cpp	(revision 436)
+++ q3radiant/TextureBar.cpp	(working copy)
@@ -172,7 +172,7 @@
 
 void CTextureBar::GetSurfaceAttributes()
 {
-  texdef_t* pt = (g_ptrSelectedFaces.GetSize() > 0) ? &(reinterpret_cast<face_t*>(g_ptrSelectedFaces.GetAt(0)))->texdef : &g_qeglobals.d_texturewin.texdef;
+  texdef_t* pt = (g_ptrSelectedFaces.GetSize() > 0) ? &(reinterpret_cast<face_s*>(g_ptrSelectedFaces.GetAt(0)))->texdef : &g_qeglobals.d_texturewin.texdef;
 
   if (pt)
   {
@@ -194,7 +194,7 @@
     {
 		  Sys_Printf("Warning : brush primitive mode not implemented in CTextureBar");
     }
-    face_t *selFace = reinterpret_cast<face_t*>(g_ptrSelectedFaces.GetAt(0));
+    face_s *selFace = reinterpret_cast<face_s*>(g_ptrSelectedFaces.GetAt(0));
 
 	  texdef_t* pt = &selFace->texdef;
     UpdateData(TRUE);
Index: q3radiant/Textures.h
===================================================================
--- q3radiant/Textures.h	(revision 437)
+++ q3radiant/Textures.h	(working copy)
@@ -41,7 +41,7 @@
 // added an optional IPluginTexdef when one is available
 // we need a forward declaration, this is crap
 class IPluginTexdef;
-void	Texture_SetTexture (texdef_t *texdef, brushprimit_texdef_t *brushprimit_texdef, bool bFitScale = false, bool bSetSelection = true);
+void	Texture_SetTexture (texdef_t *texdef, brushprimit_texdef_s *brushprimit_texdef, bool bFitScale = false, bool bSetSelection = true);
 
 void	Texture_SetMode(int iMenu);	// GL_TEXTURE_NEAREST, etc..
 void Texture_ResetPosition();
Index: q3radiant/TexWnd.cpp
===================================================================
--- q3radiant/TexWnd.cpp	(revision 459)
+++ q3radiant/TexWnd.cpp	(working copy)
@@ -94,20 +94,7 @@
 void	Texture_MouseMoved (int x, int y, int buttons);
 
 CPtrArray g_lstShaders;
-CPtrArray g_lstSkinCache;
 
-struct SkinInfo
-{
-  CString m_strName;
-  int m_nTextureBind;
-  SkinInfo(const char *pName, int n)
-  {
-    m_strName = pName;
-    m_nTextureBind = n;
-  };
-  SkinInfo(){};
-};
-
 // checks wether a qtexture_t exists for a given name
 //++timo FIXME: is this really any use? redundant.
 bool ShaderQTextureExists(const char *pName)
@@ -146,7 +133,7 @@
 //
 int GetTextureExtensionCount()
 {
-  return 2;
+  return 3;
 }
 
 const char* GetTextureExtension(int nIndex)
@@ -153,9 +140,12 @@
 {
   if ( nIndex == 0)
   {
-	  "tga" ;
+	 return "tga" ;
   }
-  // return jpg for 2nd extension
+  if ( nIndex == 1)
+  {
+	 return "png" ;
+  }
   return "jpg";
 }
 
@@ -885,9 +875,9 @@
   return pInfo;
 }
 
-void ReplaceQTexture(qtexture_t *pOld, qtexture_t *pNew, brush_t *pList)
+void ReplaceQTexture(qtexture_t *pOld, qtexture_t *pNew, brush_s *pList)
 { 
-	for (brush_t* pBrush = pList->next ; pBrush != pList; pBrush = pBrush->next)
+	for (brush_s* pBrush = pList->next ; pBrush != pList; pBrush = pBrush->next)
 	{
 		if (pBrush->patchBrush)
 		{
@@ -894,7 +884,7 @@
 			Patch_ReplaceQTexture(pBrush, pOld, pNew);
 		}
 
-		for (face_t* pFace = pBrush->brush_faces; pFace; pFace = pFace->next)
+		for (face_s* pFace = pBrush->brush_faces; pFace; pFace = pFace->next)
 		{
 			if (pFace->d_texture == pOld)
 			{
@@ -1702,8 +1692,8 @@
 */
 void	Texture_ShowInuse (void)
 {
-	face_t	*f;
-	brush_t	*b;
+	face_s	*f;
+	brush_s	*b;
 	char	name[1024];
 
 	texture_showinuse = true;
@@ -1857,7 +1847,7 @@
 brushprimit_texdef must be understood as a qtexture_t with width=2 height=2 ( the default one )
 ============
 */
-void Texture_SetTexture (texdef_t *texdef, brushprimit_texdef_t *brushprimit_texdef, bool bFitScale, bool bSetSelection )
+void Texture_SetTexture (texdef_t *texdef, brushprimit_texdef_s *brushprimit_texdef, bool bFitScale, bool bSetSelection )
 {
 	qtexture_t	*q;
 	int			x,y;
@@ -2010,7 +2000,7 @@
 	int		x, y;
 	qtexture_t	*q;
 	texdef_t	tex;
-	brushprimit_texdef_t brushprimit_tex;
+	brushprimit_texdef_s brushprimit_tex;
 
 	my += g_qeglobals.d_texturewin.originy-g_qeglobals.d_texturewin.height;
 	
@@ -2345,14 +2335,6 @@
       pTex = pNextTex;
     }
   }
-
-  int nSize = g_lstSkinCache.GetSize();
-  for (int i = 0; i < nSize; i++)
-  {
-    SkinInfo *pInfo = reinterpret_cast<SkinInfo*>(g_lstSkinCache.GetAt(i));
-    delete pInfo;
-  }
-
 }
 
 /*
@@ -2865,81 +2847,3 @@
   }
 
 }
-
-int WINAPI Texture_LoadSkin(char *pName, int *pnWidth, int *pnHeight)
-{
-  byte *pic = NULL;
-  byte *pic32 = NULL;
-  int nTex = -1;
-
-  strlwr(pName);
-  QE_ConvertDOSToUnixName(pName, pName);
-
-  int nSize = g_lstSkinCache.GetSize();
-  for (int i = 0; i < nSize; i++)
-  {
-    SkinInfo *pInfo = reinterpret_cast<SkinInfo*>(g_lstSkinCache.GetAt(i));
-    if (pInfo)
-    {
-      if (stricmp(pName, pInfo->m_strName) == 0)
-      {
-        return pInfo->m_nTextureBind;
-      }
-    }
-  }
-
-  LoadImage( pName, &pic32, pnWidth, pnHeight);
-  if (pic32 != NULL)
-  {
-
-    nTex = texture_extension_number++;
-    if (g_PrefsDlg.m_bSGIOpenGL)
-    {
-      //if (!qwglMakeCurrent(g_qeglobals.d_hdcBase, g_qeglobals.d_hglrcBase))
-      if (!qwglMakeCurrent(s_hdcTexture, s_hglrcTexture))
-		    Error ("wglMakeCurrent in LoadTexture failed");
-    }
-
-    qglBindTexture( GL_TEXTURE_2D, nTex);
-    SetTexParameters ();
-
-	  int nCount = MAX_TEXTURE_QUALITY - g_PrefsDlg.m_nTextureQuality;
-	  while (nCount-- > 0)
-	  {
-	    if (*pnWidth > 16 && *pnHeight > 16)
-	    {
-	      R_MipMap(pic32, *pnWidth, *pnHeight);
-	    }
-	    else
-	    {
-	      break;
-	    }
-	  }
-
-    if (g_PrefsDlg.m_bSGIOpenGL)
-    {
-	    if (nomips)
-      {
-		    qglTexImage2D(GL_TEXTURE_2D, 0, 3, *pnWidth, *pnHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, pic32);
-      }
-	    else
-		    qgluBuild2DMipmaps(GL_TEXTURE_2D, 3, *pnWidth, *pnHeight,GL_RGBA, GL_UNSIGNED_BYTE, pic32);
-    }
-    else
-    {
-	    if (nomips)
-		    qglTexImage2D(GL_TEXTURE_2D, 0, 3, *pnWidth, *pnHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, pic32);
-	    else
-		    qgluBuild2DMipmaps(GL_TEXTURE_2D, 3, *pnWidth, *pnHeight,GL_RGBA, GL_UNSIGNED_BYTE, pic32);
-    }
-	  free (pic32);
-	  qglBindTexture( GL_TEXTURE_2D, 0 );
-  }
-
-  SkinInfo *pInfo = new SkinInfo(pName, nTex);
-  g_lstSkinCache.Add(pInfo);
-
-  return nTex;
-}
-
-
Index: q3radiant/Undo.cpp
===================================================================
--- q3radiant/Undo.cpp	(revision 436)
+++ q3radiant/Undo.cpp	(working copy)
@@ -47,8 +47,8 @@
 	int id;						//every undo has an unique id
 	int done;					//true when undo is build
 	char *operation;			//name of the operation
-	brush_t brushlist;			//deleted brushes
-	entity_t entitylist;		//deleted entities
+	brush_s brushlist;			//deleted brushes
+	entity_s entitylist;		//deleted entities
 	struct undo_s *prev, *next;	//next and prev undo in list
 } undo_t;
 
@@ -74,8 +74,8 @@
 	/*
 	int size;
 	undo_t *undo;
-	brush_t *pBrush;
-	entity_t *pEntity;
+	brush_s *pBrush;
+	entity_s *pEntity;
 
 	size = 0;
 	for (undo = g_undolist; undo; undo = undo->next)
@@ -103,8 +103,8 @@
 void Undo_ClearRedo(void)
 {
 	undo_t *redo, *nextredo;
-	brush_t *pBrush, *pNextBrush;
-	entity_t *pEntity, *pNextEntity;
+	brush_s *pBrush, *pNextBrush;
+	entity_s *pEntity, *pNextEntity;
 
 	for (redo = g_redolist; redo; redo = nextredo)
 	{
@@ -136,8 +136,8 @@
 void Undo_Clear(void)
 {
 	undo_t *undo, *nextundo;
-	brush_t *pBrush, *pNextBrush;
-	entity_t *pEntity, *pNextEntity;
+	brush_s *pBrush, *pNextBrush;
+	entity_s *pEntity, *pNextEntity;
 
 	Undo_ClearRedo();
 	for (undo = g_undolist; undo; undo = nextundo)
@@ -217,8 +217,8 @@
 void Undo_FreeFirstUndo(void)
 {
 	undo_t *undo;
-	brush_t *pBrush, *pNextBrush;
-	entity_t *pEntity, *pNextEntity;
+	brush_s *pBrush, *pNextBrush;
+	entity_s *pEntity, *pNextEntity;
 
 	//remove the oldest undo from the undo buffer
 	undo = g_undolist;
@@ -250,8 +250,8 @@
 void Undo_GeneralStart(char *operation)
 {
 	undo_t *undo;
-	brush_t *pBrush;
-	entity_t *pEntity;
+	brush_s *pBrush;
+	entity_s *pEntity;
 
 
 	if (g_lastundo)
@@ -319,9 +319,9 @@
 Undo_BrushInUndo
 =============
 */
-int Undo_BrushInUndo(undo_t *undo, brush_t *brush)
+int Undo_BrushInUndo(undo_t *undo, brush_s *brush)
 {
-	brush_t *b;
+	brush_s *b;
 
 	for (b = undo->brushlist.next; b != &undo->brushlist; b = b->next)
 	{
@@ -335,9 +335,9 @@
 Undo_EntityInUndo
 =============
 */
-int Undo_EntityInUndo(undo_t *undo, entity_t *ent)
+int Undo_EntityInUndo(undo_t *undo, entity_s *ent)
 {
-	entity_t *e;
+	entity_s *e;
 
 	for (e = undo->entitylist.next; e != &undo->entitylist; e = e->next)
 	{
@@ -362,7 +362,7 @@
 Undo_AddBrush
 =============
 */
-void Undo_AddBrush(brush_t *pBrush)
+void Undo_AddBrush(brush_s *pBrush)
 {
 	if (!g_lastundo)
 	{
@@ -377,7 +377,7 @@
 	if (Undo_BrushInUndo(g_lastundo, pBrush))
 		return;
 	//clone the brush
-	brush_t* pClone = Brush_FullClone(pBrush);
+	brush_s* pClone = Brush_FullClone(pBrush);
 	//save the ID of the owner entity
 	pClone->ownerId = pBrush->owner->entityId;
 	//save the old undo ID for previous undos
@@ -392,9 +392,9 @@
 Undo_AddBrushList
 =============
 */
-void Undo_AddBrushList(brush_t *brushlist)
+void Undo_AddBrushList(brush_s *brushlist)
 {
-	brush_t *pBrush;
+	brush_s *pBrush;
 
 	if (!g_lastundo)
 	{
@@ -418,7 +418,7 @@
 		if (pBrush->owner->eclass->fixedsize == 1)
 			Undo_AddEntity( pBrush->owner );
 		//clone the brush
-		brush_t* pClone = Brush_FullClone(pBrush);
+		brush_s* pClone = Brush_FullClone(pBrush);
 		//save the ID of the owner entity
 		pClone->ownerId = pBrush->owner->entityId;
 		//save the old undo ID from previous undos
@@ -434,7 +434,7 @@
 Undo_EndBrush
 =============
 */
-void Undo_EndBrush(brush_t *pBrush)
+void Undo_EndBrush(brush_s *pBrush)
 {
 	if (!g_lastundo)
 	{
@@ -454,7 +454,7 @@
 Undo_EndBrushList
 =============
 */
-void Undo_EndBrushList(brush_t *brushlist)
+void Undo_EndBrushList(brush_s *brushlist)
 {
 	if (!g_lastundo)
 	{
@@ -466,7 +466,7 @@
 		//Sys_Printf("Undo_End: last undo already finished.\n");
 		return;
 	}
-	for (brush_t* pBrush = brushlist->next; pBrush != NULL && pBrush != brushlist; pBrush=pBrush->next)
+	for (brush_s* pBrush = brushlist->next; pBrush != NULL && pBrush != brushlist; pBrush=pBrush->next)
 	{
 		pBrush->undoId = g_lastundo->id;
 	}
@@ -477,9 +477,9 @@
 Undo_AddEntity
 =============
 */
-void Undo_AddEntity(entity_t *entity)
+void Undo_AddEntity(entity_s *entity)
 {
-	entity_t* pClone;
+	entity_s* pClone;
 
 	if (!g_lastundo)
 	{
@@ -509,7 +509,7 @@
 Undo_EndEntity
 =============
 */
-void Undo_EndEntity(entity_t *entity)
+void Undo_EndEntity(entity_s *entity)
 {
 	if (!g_lastundo)
 	{
@@ -569,8 +569,8 @@
 void Undo_Undo(void)
 {
 	undo_t *undo, *redo;
-	brush_t *pBrush, *pNextBrush;
-	entity_t *pEntity, *pNextEntity, *pUndoEntity;
+	brush_s *pBrush, *pNextBrush;
+	entity_s *pEntity, *pNextEntity, *pUndoEntity;
 
 	if (!g_lastundo)
 	{
@@ -739,8 +739,8 @@
 void Undo_Redo(void)
 {
 	undo_t *redo;
-	brush_t *pBrush, *pNextBrush;
-	entity_t *pEntity, *pNextEntity, *pRedoEntity;
+	brush_s *pBrush, *pNextBrush;
+	entity_s *pEntity, *pNextEntity, *pRedoEntity;
 
 	if (!g_lastredo)
 	{
Index: q3radiant/Undo.h
===================================================================
--- q3radiant/Undo.h	(revision 436)
+++ q3radiant/Undo.h	(working copy)
@@ -30,17 +30,17 @@
 //end operation
 void Undo_End(void);
 //add brush to the undo
-void Undo_AddBrush(brush_t *pBrush);
+void Undo_AddBrush(brush_s *pBrush);
 //add a list with brushes to the undo
-void Undo_AddBrushList(brush_t *brushlist);
+void Undo_AddBrushList(brush_s *brushlist);
 //end a brush after the operation is performed
-void Undo_EndBrush(brush_t *pBrush);
+void Undo_EndBrush(brush_s *pBrush);
 //end a list with brushes after the operation is performed
-void Undo_EndBrushList(brush_t *brushlist);
+void Undo_EndBrushList(brush_s *brushlist);
 //add entity to undo
-void Undo_AddEntity(entity_t *entity);
+void Undo_AddEntity(entity_s *entity);
 //end an entity after the operation is performed
-void Undo_EndEntity(entity_t *entity);
+void Undo_EndEntity(entity_s *entity);
 //undo last operation
 void Undo_Undo(void);
 //redo last undone operation
Index: q3radiant/VERTSEL.CPP
===================================================================
--- q3radiant/VERTSEL.CPP	(revision 443)
+++ q3radiant/VERTSEL.CPP	(working copy)
@@ -36,20 +36,20 @@
 		for (j=0 ; j<3 ; j++)
 			if (fabs(point[j] - g_qeglobals.d_points[i][j]) > 0.1)
 				break;
-		if (j == 3)
-			return i;
+			if (j == 3)
+				return i;
 	}
 
 	g_qeglobals.d_points[g_qeglobals.d_numpoints] = point;
-  if (g_qeglobals.d_numpoints < MAX_POINTS-1)
-  {
-	  g_qeglobals.d_numpoints++;
-  }
+	if (g_qeglobals.d_numpoints < MAX_POINTS-1)
+	{
+		g_qeglobals.d_numpoints++;
+	}
 
 	return g_qeglobals.d_numpoints-1;
 }
 
-int FindEdge (int p1, int p2, face_t *f)
+int FindEdge (int p1, int p2, face_s *f)
 {
 	int		i;
 
@@ -64,18 +64,18 @@
 	g_qeglobals.d_edges[g_qeglobals.d_numedges].p2 = p2;
 	g_qeglobals.d_edges[g_qeglobals.d_numedges].f1 = f;
 
-  if (g_qeglobals.d_numedges < MAX_EDGES-1)
-  {
-	  g_qeglobals.d_numedges++;
-  }
+	if (g_qeglobals.d_numedges < MAX_EDGES-1)
+	{
+		g_qeglobals.d_numedges++;
+	}
 
 	return g_qeglobals.d_numedges-1;
 }
 
 #ifdef NEWEDGESEL
-void MakeFace (brush_t* b, face_t *f)
+void MakeFace (brush_s* b, face_s *f)
 #else
-void MakeFace (face_t *f)
+void MakeFace (face_s *f)
 #endif
 {
 	winding_t	*w;
@@ -99,8 +99,8 @@
 
 void SetupVertexSelection (void)
 {
-	face_t	*f;
-	brush_t *b;
+	face_s	*f;
+	brush_s *b;
 
 	g_qeglobals.d_numpoints = 0;
 	g_qeglobals.d_numedges = 0;
@@ -124,9 +124,9 @@
 
 
 #ifdef NEWEDGESEL
-void SelectFaceEdge (brush_t* b, face_t *f, int p1, int p2)
+void SelectFaceEdge (brush_s* b, face_s *f, int p1, int p2)
 #else
-void SelectFaceEdge (face_t *f, int p1, int p2)
+void SelectFaceEdge (face_s *f, int p1, int p2)
 #endif
 {
 	winding_t	*w;
@@ -170,10 +170,10 @@
 
 void SelectVertex (int p1)
 {
-	brush_t		*b;
+	brush_s		*b;
 	winding_t	*w;
 	int			i, j, k;
-	face_t		*f;
+	face_s		*f;
 
 #ifdef NEWEDGESEL
 	for (b=selected_brushes.next ; b != &selected_brushes ; b=b->next)
@@ -280,7 +280,7 @@
 	g_qeglobals.d_num_move_points = 0;
 	e = &g_qeglobals.d_edges[besti];
 #ifdef NEWEDGESEL
-	for (brush_t* b=selected_brushes.next ; b != &selected_brushes ; b=b->next)
+	for (brush_s* b=selected_brushes.next ; b != &selected_brushes ; b=b->next)
   {
     SelectFaceEdge (b, e->f1, e->p1, e->p2);
 	  SelectFaceEdge (b, e->f2, e->p2, e->p1);
@@ -356,16 +356,16 @@
 
 	if (besti == -1)
 	{
-    if (g_pParentWnd->ActiveXY()->AreaSelectOK())
-    {
-      g_qeglobals.d_select_mode = sel_area;
-      g_qeglobals.d_vAreaTL = org;
-      g_qeglobals.d_vAreaBR = org;
-    }
+		if (g_pParentWnd->ActiveXY()->AreaSelectOK())
+		{
+			g_qeglobals.d_select_mode = sel_area;
+			g_qeglobals.d_vAreaTL = org;
+			g_qeglobals.d_vAreaBR = org;
+		}
 		return;
 	}
 	//Sys_Printf ("hit vertex\n");
-  AddPatchMovePoint(g_qeglobals.d_points[besti], buttons & MK_CONTROL, buttons & MK_SHIFT);
+	AddPatchMovePoint(g_qeglobals.d_points[besti], buttons & MK_CONTROL, buttons & MK_SHIFT);
 }
 
 
Index: q3radiant/WIN_DLG.CPP
===================================================================
--- q3radiant/WIN_DLG.CPP	(revision 458)
+++ q3radiant/WIN_DLG.CPP	(working copy)
@@ -138,7 +138,7 @@
 void UpdateBSPCommandList (HWND hwndDlg)
 {
 	int			i;
-	epair_t		*ep;
+	epair_s		*ep;
 
 	SendDlgItemMessage(hwndDlg, IDC_CMD_LIST, LB_RESETCONTENT, 0 , 0);
 
@@ -296,8 +296,8 @@
 
 void SelectBrush (int entitynum, int brushnum)
 {
-	entity_t	*e;
-	brush_t		*b;
+	entity_s	*e;
+	brush_s		*b;
 	int			i;
 
 	if (entitynum == 0)
@@ -359,8 +359,8 @@
 */
 void GetSelectionIndex (int *ent, int *brush)
 {
-	brush_t		*b, *b2;
-	entity_t	*entity;
+	brush_s		*b, *b2;
+	entity_s	*entity;
 
 	*ent = *brush = 0;
 
Index: q3radiant/Win_ent.cpp
===================================================================
--- q3radiant/Win_ent.cpp	(revision 437)
+++ q3radiant/Win_ent.cpp	(working copy)
@@ -72,7 +72,7 @@
 
 bool	multiple_entities;
 
-entity_t	*edit_entity;
+entity_s	*edit_entity;
 
 
 BOOL CALLBACK EntityWndProc(
@@ -318,7 +318,7 @@
 
 void FillClassList (void)
 {
-	eclass_t	*pec;
+	eclass_s	*pec;
 	int			iIndex;
 
 	SendMessage(hwndEnt[EntList], LB_RESETCONTENT, 0 , 0);
@@ -505,7 +505,7 @@
 
 void SetKeyValuePairs (bool bClearMD3)
 {
-	epair_t	*pep;
+	epair_s	*pep;
 	RECT	rc;
 	char	sz[4096];
 	
@@ -534,10 +534,10 @@
 	{
 		// if this is a misc_model
 		// cache the md3 for display later
-		if (bClearMD3)
-		{
-			edit_entity->md3Class = NULL;
-		}
+		//if (bClearMD3)
+		//{
+		//	edit_entity->md3Class = NULL;
+		//}
 		//char *pModel = ValueForKey(edit_entity, "model");
 		
 		/*
@@ -592,7 +592,7 @@
 
 	if (multiple_entities)
 	{
-		brush_t	*b;
+		brush_s	*b;
 
 		for (b=selected_brushes.next ; b != &selected_brushes ; b=b->next)
 			SetKeyValue(b->owner, "spawnflags", sz);
@@ -606,10 +606,10 @@
 //
 // Update the listbox, checkboxes and k/v pairs to reflect the new selection
 //
-BOOL UpdateSel(int iIndex, eclass_t *pec)
+BOOL UpdateSel(int iIndex, eclass_s *pec)
 {
 	int		i;
-	brush_t	*b;
+	brush_s	*b;
 
 	if (selected_brushes.next == &selected_brushes)
 	{
@@ -660,7 +660,7 @@
 	return TRUE;
 }
 
-BOOL UpdateEntitySel(eclass_t *pec)
+BOOL UpdateEntitySel(eclass_s *pec)
 {
 	int iIndex;
 
@@ -677,8 +677,8 @@
 
 void CreateEntity(void)
 {
-	eclass_t *pecNew;
-	entity_t *petNew;
+	eclass_s *pecNew;
+	entity_s *petNew;
 	int i;
 	HWND hwnd;
 	char sz[1024];
@@ -761,7 +761,7 @@
 
 	if (multiple_entities)
 	{
-		brush_t	*b;
+		brush_s	*b;
 
 		for (b=selected_brushes.next ; b != &selected_brushes ; b=b->next)
 			SetKeyValue(b->owner, key, value);
@@ -792,7 +792,7 @@
 
 	if (multiple_entities)
 	{
-		brush_t	*b;
+		brush_s	*b;
 
 		for (b=selected_brushes.next ; b != &selected_brushes ; b=b->next)
 			DeleteKey(b->owner, sz);
@@ -938,7 +938,6 @@
     col = iWidth;
   }
 
-  MOVE(g_qeglobals.d_hwndGroup,	DlgXBorder, DlgYBorder, iWidth - (2 * DlgXBorder), iHeight - (2 * DlgYBorder) );
 
 	//==========================================
 
@@ -1138,7 +1137,7 @@
 
 	  SendMessage(hwndEnt[EntValueField], WM_SETTEXT, 0, (LPARAM)str.GetBuffer(0));	
     AddProp();
-    edit_entity->md3Class = NULL;
+//    edit_entity->md3Class = NULL;
     edit_entity->brushes.onext->bModelFailed = false;
     g_pParentWnd->GetXYWnd()->SetFocus();
   }
@@ -1356,10 +1355,10 @@
 			case LBN_SELCHANGE: 
 			{
 				int iIndex;
-				eclass_t *pec;
+				eclass_s *pec;
 				
 				iIndex = SendMessage(hwndEnt[EntList], LB_GETCURSEL, 0, 0);	
-				pec = (eclass_t *)SendMessage(hwndEnt[EntList], LB_GETITEMDATA, 
+				pec = (eclass_s *)SendMessage(hwndEnt[EntList], LB_GETITEMDATA, 
 						iIndex, 0); 
 			
 				UpdateSel(iIndex, pec);
Index: q3radiant/WIN_QE3.CPP
===================================================================
--- q3radiant/WIN_QE3.CPP	(revision 439)
+++ q3radiant/WIN_QE3.CPP	(working copy)
@@ -496,7 +496,7 @@
 void FillBSPMenu (void)
 {
 	HMENU	hmenu;
-	epair_t	*ep;
+	epair_s	*ep;
 	int		i;
 	static int count;
 
Index: q3radiant/XY.H
===================================================================
--- q3radiant/XY.H	(revision 437)
+++ q3radiant/XY.H	(working copy)
@@ -36,4 +36,4 @@
 	bool d_dirty;
 } xy_t;
 
-BOOL FilterBrush(brush_t *pb);
+BOOL FilterBrush(brush_s *pb);
Index: q3radiant/XYWnd.cpp
===================================================================
--- q3radiant/XYWnd.cpp	(revision 459)
+++ q3radiant/XYWnd.cpp	(working copy)
@@ -56,12 +56,12 @@
 CClipPoint g_Clip2;
 CClipPoint g_Clip3;
 CClipPoint* g_pMovingClip;
-brush_t g_brFrontSplits;
-brush_t g_brBackSplits;
+brush_s g_brFrontSplits;
+brush_s g_brBackSplits;
 
-brush_t g_brClipboard;
-brush_t g_brUndo;
-entity_t	g_enClipboard;
+brush_s g_brClipboard;
+brush_s g_brUndo;
+entity_s	g_enClipboard;
 
 edVec3_c g_vRotateOrigin;
 edVec3_c g_vRotation;
@@ -500,7 +500,7 @@
     return f1 + ((f2 - f1) / 2);
 }
 
-void CXYWnd::ProduceSplits(brush_t** pFront, brush_t** pBack)
+void CXYWnd::ProduceSplits(brush_s** pFront, brush_s** pBack)
 {
   *pFront = NULL;
   *pBack = NULL;
@@ -508,7 +508,7 @@
   {
     if (g_Clip1.Set() && g_Clip2.Set())
     {
-      face_t face;
+      face_s face;
       face.planepts[0] = g_Clip1.m_ptClip;
       face.planepts[1] = g_Clip2.m_ptClip;
       face.planepts[2] = g_Clip3.m_ptClip;
@@ -549,12 +549,12 @@
   }
 }
 
-void CleanList(brush_t* pList)
+void CleanList(brush_s* pList)
 {
-  brush_t* pBrush = pList->next; 
+  brush_s* pBrush = pList->next; 
   while (pBrush != NULL && pBrush != pList)
   {
-    brush_t* pNext = pBrush->next;
+    brush_s* pNext = pBrush->next;
     Brush_Free(pBrush);
     pBrush = pNext;
   }
@@ -565,8 +565,8 @@
 	if (AnyPatchesSelected())
 	{
 		Sys_Printf("Deslecting patches for clip operation.\n");
-		brush_t *next;
-		for (brush_t *pb = selected_brushes.next ; pb != &selected_brushes ; pb = next)
+		brush_s *next;
+		for (brush_s *pb = selected_brushes.next ; pb != &selected_brushes ; pb = next)
 		{
 			next = pb->next;
 			if (pb->patchBrush)
@@ -582,16 +582,16 @@
 	CleanList(&g_brBackSplits);
 	g_brFrontSplits.next = &g_brFrontSplits;
 	g_brBackSplits.next = &g_brBackSplits;
-	brush_t* pBrush;
+	brush_s* pBrush;
 	for (pBrush = selected_brushes.next ; pBrush != NULL && pBrush != &selected_brushes ; pBrush=pBrush->next)
 	{
-		brush_t* pFront = NULL;
-		brush_t* pBack = NULL;
+		brush_s* pFront = NULL;
+		brush_s* pBack = NULL;
 		if (ClipMode())
 		{
 			if (g_Clip1.Set() && g_Clip2.Set())
 			{
-				face_t face;
+				face_s face;
 				face.planepts[0] = g_Clip1.m_ptClip;
 				face.planepts[1] = g_Clip2.m_ptClip;
 				face.planepts[2] = g_Clip3.m_ptClip;
@@ -632,12 +632,12 @@
 	}
 }
 
-void Brush_CopyList (brush_t* pFrom, brush_t* pTo)
+void Brush_CopyList (brush_s* pFrom, brush_s* pTo)
 {
-	brush_t* pBrush = pFrom->next; 
+	brush_s* pBrush = pFrom->next; 
 	while (pBrush != NULL && pBrush != pFrom)
 	{
-		brush_t* pNext = pBrush->next;
+		brush_s* pNext = pBrush->next;
 		Brush_RemoveFromList(pBrush);
 		Brush_AddToList(pBrush, pTo);
 		pBrush = pNext;
@@ -1077,12 +1077,12 @@
       if (g_Clip1.Set() && g_Clip2.Set())
       {
         ProduceSplitLists();
-        brush_t* pBrush;
-        brush_t* pList = ( (m_nViewType == XZ) ? !g_bSwitch : g_bSwitch) ? &g_brBackSplits : &g_brFrontSplits;
+        brush_s* pBrush;
+        brush_s* pList = ( (m_nViewType == XZ) ? !g_bSwitch : g_bSwitch) ? &g_brBackSplits : &g_brFrontSplits;
 	      for (pBrush = pList->next ; pBrush != NULL && pBrush != pList ; pBrush=pBrush->next)
         {
 		      qglColor3f (1,1,0);
-	        face_t *face;
+	        face_s *face;
 	        int order;
 	        for (face = pBrush->brush_faces,order = 0 ; face ; face=face->next, order++)
 	        {
@@ -1137,11 +1137,11 @@
 
 
 
-// FIXME: the brush_t *pBrush is never used. ( Entity_Create uses selected_brushes )
-void CreateEntityFromName(char* pName, brush_t* pBrush)
+// FIXME: the brush_s *pBrush is never used. ( Entity_Create uses selected_brushes )
+void CreateEntityFromName(char* pName, brush_s* pBrush)
 {
-	eclass_t *pecNew;
-	entity_t *petNew;
+	eclass_s *pecNew;
+	entity_s *petNew;
 	if (stricmp(pName, "worldspawn") == 0)
 	{
 		MessageBox(g_qeglobals.d_hwndMain, "Can't create an entity with worldspawn.", "info", 0);
@@ -1156,7 +1156,7 @@
 	{
 		if (!((selected_brushes.next == &selected_brushes)||(selected_brushes.next->next != &selected_brushes)))
 		{
-			brush_t* b = selected_brushes.next;
+			brush_s* b = selected_brushes.next;
 			if (b->owner != world_entity && b->owner->eclass->fixedsize && pecNew->fixedsize)
 			{
 				edVec3_c mins, maxs;
@@ -1166,7 +1166,7 @@
 				
 				mins = pecNew->mins + origin;
 				maxs = pecNew->maxs + origin;
-				brush_t* nb = Brush_Create (mins, maxs, &pecNew->texdef);
+				brush_s* nb = Brush_Create (mins, maxs, &pecNew->texdef);
 				Entity_LinkBrush (b->owner, nb);
 				nb->owner->eclass = pecNew;
 				SetKeyValue (nb->owner, "classname", pName);
@@ -1182,7 +1182,7 @@
 	}
 	
 	Select_Deselect ();
-	//entity_t* pEntity = world_entity;
+	//entity_s* pEntity = world_entity;
 	//if (selected_brushes.next != &selected_brushes)
 	//	pEntity = selected_brushes.next->owner;
 	Select_Brush (petNew->brushes.onext);
@@ -1196,12 +1196,12 @@
 }
 
 
-brush_t* CreateEntityBrush(int x, int y, CXYWnd* pWnd)
+brush_s* CreateEntityBrush(int x, int y, CXYWnd* pWnd)
 {
 	vec3_t	mins, maxs;
 	int		i;
 	float	temp;
-	brush_t	*n;
+	brush_s	*n;
 
 	pWnd->SnapToPoint (x, y, mins);
   x += 32;
@@ -1241,16 +1241,16 @@
 {
   CRect rctZ;
   pWnd->GetClientRect(rctZ);
-  brush_t* pBrush = (selected_brushes.next == &selected_brushes) ? CreateEntityBrush(x, rctZ.Height() - 1 - y, pWnd) : selected_brushes.next;
+  brush_s* pBrush = (selected_brushes.next == &selected_brushes) ? CreateEntityBrush(x, rctZ.Height() - 1 - y, pWnd) : selected_brushes.next;
   CreateEntityFromName(pName, pBrush);
   //Select_Brush(pBrush);
 }
 
-brush_t* CreateSmartBrush(vec3_t v)
+brush_s* CreateSmartBrush(vec3_t v)
 {
 	vec3_t	mins, maxs;
 	int		i;
-	brush_t	*n;
+	brush_s	*n;
 
 	for (i=0 ; i<3 ; i++)
 	{
@@ -1321,11 +1321,11 @@
     CreateRightClickEntity(g_pParentWnd->ActiveXY(), g_nSmartX, g_nSmartY, "func_rotating");
     array.Add(reinterpret_cast<void*>(selected_brushes.next));
     Select_Deselect();
-    brush_t* pBrush = CreateSmartBrush(g_PathPoints[0]);
+    brush_s* pBrush = CreateSmartBrush(g_PathPoints[0]);
     array.Add(pBrush);
     Select_Deselect();
-    Select_Brush(reinterpret_cast<brush_t*>(array.GetAt(0)));
-    Select_Brush(reinterpret_cast<brush_t*>(array.GetAt(1)));
+    Select_Brush(reinterpret_cast<brush_s*>(array.GetAt(0)));
+    Select_Brush(reinterpret_cast<brush_s*>(array.GetAt(1)));
     ConnectEntities();
     g_bScreenUpdates = true;
   }
@@ -1337,7 +1337,7 @@
 	int n;
   CPtrArray array;
   HideInfoDialog();
-  brush_t* pEntities = NULL;
+  brush_s* pEntities = NULL;
   if (g_strSmartEntity.Find("Smart_Train") >= 0)
   {
     g_bScreenUpdates = false;
@@ -1353,8 +1353,8 @@
     for (n = 0; n < g_nPathCount; n++)
     {
       Select_Deselect();
-      Select_Brush(reinterpret_cast<brush_t*>(array.GetAt(n)));
-      Select_Brush(reinterpret_cast<brush_t*>(array.GetAt(n+1)));
+      Select_Brush(reinterpret_cast<brush_s*>(array.GetAt(n)));
+      Select_Brush(reinterpret_cast<brush_s*>(array.GetAt(n+1)));
       ConnectEntities();
     }
     g_bScreenUpdates = true;
@@ -1394,7 +1394,7 @@
 		else if (strItem.CompareNoCase("Remove") == 0)
 		{
 			// remove selected brushes from their current group
-			brush_t *b;
+			brush_s *b;
 			for( b = selected_brushes.next; b != &selected_brushes; b = b->next )
 			{
 				
@@ -1467,7 +1467,7 @@
     m_mnuDrop.AppendMenu(MF_SEPARATOR, nID++, "");
 
     pChild = NULL;
-	  eclass_t	*e;
+	  eclass_s	*e;
     CString strActive;
     CString strLast;
     CString strName;
@@ -1790,7 +1790,7 @@
 	edVec3_c	mins, maxs, junk;
 	int		i;
 	float	temp;
-	brush_t	*n;
+	brush_s	*n;
 
 	if (!DragDelta (x,y, junk))
 		return;
@@ -2353,7 +2353,7 @@
 FilterBrush
 ==================
 */
-BOOL FilterBrush(brush_t *pb)
+BOOL FilterBrush(brush_s *pb)
 {
 	if(pb == 0)
 		return FALSE;
@@ -2370,7 +2370,7 @@
     // filter out the brush only if all faces are caulk
     // if not don't hide the whole brush, proceed on a per-face basis (Cam_Draw)
     //++timo TODO: set this as a preference .. show caulk: hide any brush with caulk // don't draw caulk faces
-    face_t *f;
+    face_s *f;
     f=pb->brush_faces;
     while (f)
     {
@@ -2411,7 +2411,7 @@
 
 	if (g_qeglobals.d_savedinfo.exclude & EXCLUDE_WATER)
 	{
-		for (face_t* f = pb->brush_faces ; f ; f=f->next)
+		for (face_s* f = pb->brush_faces ; f ; f=f->next)
     {
       if (f->texdef.contents & (CONTENTS_WATER | CONTENTS_SLIME | CONTENTS_LAVA))
         return TRUE;
@@ -2491,8 +2491,8 @@
 {
 	int		i, j, k;
 	edVec3_c	mid, mid1;
-	entity_t *se, *te;
-	brush_t	*sb, *tb;
+	entity_s *se, *te;
+	brush_s	*sb, *tb;
 	char	*psz;
 	edVec3_c	dir, s1, s2;
 	vec_t	len, f;
@@ -2499,7 +2499,7 @@
 	int		arrows;
 	int			num_entities;
 	char		*ent_target[MAX_MAP_ENTITIES];
-	entity_t	*ent_entity[MAX_MAP_ENTITIES];
+	entity_s	*ent_entity[MAX_MAP_ENTITIES];
 
 	if (g_qeglobals.d_savedinfo.exclude & EXCLUDE_PATHS)
     return;
@@ -2715,13 +2715,13 @@
 */
 long g_lCount = 0;
 long g_lTotal = 0;
-extern void DrawBrushEntityName (brush_t *b);
+extern void DrawBrushEntityName (brush_s *b);
 
 void CXYWnd::XY_Draw()
 {
-  brush_t	*brush;
+  brush_s	*brush;
 	float	w, h;
-	entity_t	*e;
+	entity_s	*e;
 	double	start, end;
 	double	start2, end2;
 	vec3_t	mins, maxs;
@@ -3087,7 +3087,7 @@
   m_nHeight = rect.Height();
 }
 
-brush_t hold_brushes;
+brush_s hold_brushes;
 void CXYWnd::Clip()
 {
   if (ClipMode())
@@ -3094,8 +3094,8 @@
   {
     hold_brushes.next = &hold_brushes;
     ProduceSplitLists();
-    //brush_t* pList = (g_bSwitch) ? &g_brFrontSplits : &g_brBackSplits;
-    brush_t* pList;
+    //brush_s* pList = (g_bSwitch) ? &g_brFrontSplits : &g_brBackSplits;
+    brush_s* pList;
 	if (g_PrefsDlg.m_bSwitchClip)
 		pList = ( (m_nViewType == XZ) ? g_bSwitch: !g_bSwitch) ? &g_brFrontSplits : &g_brBackSplits;
 	else
@@ -3157,7 +3157,7 @@
 {
   int nDim1 = (m_nViewType == YZ) ? 1 : 0;
   int nDim2 = (m_nViewType == XY) ? 1 : 2;
-  brush_t* b = selected_brushes.next;
+  brush_s* b = selected_brushes.next;
   if (b && b->next != b)
   {
 	  m_vOrigin[nDim1] = b->getMins()[nDim1];
@@ -3268,12 +3268,12 @@
 
 void CleanCopyEntities()
 {
-	entity_t* pe = g_enClipboard.next;
+	entity_s* pe = g_enClipboard.next;
   while (pe != NULL && pe != &g_enClipboard)
   {
-    entity_t* next = pe->next;
-    epair_t* enext = NULL;
-	  for (epair_t* ep = pe->epairs ; ep ; ep=enext)
+    entity_s* next = pe->next;
+    epair_s* enext = NULL;
+	  for (epair_s* ep = pe->epairs ; ep ; ep=enext)
     {
 		  enext = ep->next;
       free (ep->key);
@@ -3286,12 +3286,12 @@
   g_enClipboard.next = g_enClipboard.prev = &g_enClipboard;
 }
 
-entity_t	*Entity_CopyClone (entity_t *e)
+entity_s	*Entity_CopyClone (entity_s *e)
 {
-	entity_t	*n;
-	epair_t		*ep, *np;
+	entity_s	*n;
+	epair_s		*ep, *np;
 
-	n = (entity_t*)qmalloc(sizeof(*n));
+	n = (entity_s*)qmalloc(sizeof(*n));
 	n->brushes.onext = n->brushes.oprev = &n->brushes;
 	n->eclass = e->eclass;
 
@@ -3303,7 +3303,7 @@
 
 	for (ep = e->epairs ; ep ; ep=ep->next)
 	{
-		np = (epair_t*)qmalloc(sizeof(*np));
+		np = (epair_s*)qmalloc(sizeof(*np));
 		np->key = copystring(ep->key);
 		np->value = copystring(ep->value);
 		np->next = n->epairs;
@@ -3312,12 +3312,12 @@
 	return n;
 }
 
-bool OnList(entity_t* pFind, CPtrArray* pList)
+bool OnList(entity_s* pFind, CPtrArray* pList)
 {
   int nSize = pList->GetSize();
   while (nSize-- > 0)
   {
-    entity_t* pEntity = reinterpret_cast<entity_t*>(pList->GetAt(nSize));
+    entity_s* pEntity = reinterpret_cast<entity_s*>(pList->GetAt(nSize));
     if (pEntity == pFind)
       return true;
   }
@@ -3374,11 +3374,11 @@
   CPtrArray holdArray;
   CleanList(&g_brClipboard);
   CleanCopyEntities();
-	for (brush_t* pBrush = selected_brushes.next ; pBrush != NULL && pBrush != &selected_brushes ; pBrush=pBrush->next)
+	for (brush_s* pBrush = selected_brushes.next ; pBrush != NULL && pBrush != &selected_brushes ; pBrush=pBrush->next)
   {
 		if (pBrush->owner == world_entity)
     {
-      brush_t* pClone = Brush_Clone(pBrush);
+      brush_s* pClone = Brush_Clone(pBrush);
       pClone->owner = NULL;
   	  Brush_AddToList (pClone, &g_brClipboard);
     }
@@ -3386,12 +3386,12 @@
     {
       if (!OnList(pBrush->owner, &holdArray))
       {
-        entity_t* e = pBrush->owner;
+        entity_s* e = pBrush->owner;
         holdArray.Add(reinterpret_cast<void*>(e));
-        entity_t* pEClone = Entity_CopyClone(e);
-			  for (brush_t* pEB = e->brushes.onext ; pEB != &e->brushes ; pEB=pEB->onext)
+        entity_s* pEClone = Entity_CopyClone(e);
+			  for (brush_s* pEB = e->brushes.onext ; pEB != &e->brushes ; pEB=pEB->onext)
 			  {
-          brush_t* pClone = Brush_Clone(pEB);
+          brush_s* pClone = Brush_Clone(pEB);
 	        //Brush_AddToList (pClone, &g_brClipboard);
           Entity_LinkBrush(pEClone, pClone);
           Brush_Build(pClone);
@@ -3409,9 +3409,9 @@
   {
     g_bScreenUpdates = false; 
     Select_Delete();
-	  for (brush_t* pBrush = g_brUndo.next ; pBrush != NULL && pBrush != &g_brUndo ; pBrush=pBrush->next)
+	  for (brush_s* pBrush = g_brUndo.next ; pBrush != NULL && pBrush != &g_brUndo ; pBrush=pBrush->next)
     {
-      brush_t* pClone = Brush_Clone(pBrush);
+      brush_s* pClone = Brush_Clone(pBrush);
     	Brush_AddToList (pClone, &active_brushes);
 			Entity_LinkBrush (pBrush->pUndoOwner, pClone);
       Brush_Build(pClone);
@@ -3436,9 +3436,9 @@
 {
 /*
   CleanList(&g_brUndo);
-	for (brush_t* pBrush = selected_brushes.next ; pBrush != NULL && pBrush != &selected_brushes ; pBrush=pBrush->next)
+	for (brush_s* pBrush = selected_brushes.next ; pBrush != NULL && pBrush != &selected_brushes ; pBrush=pBrush->next)
   {
-    brush_t* pClone = Brush_Clone(pBrush);
+    brush_s* pClone = Brush_Clone(pBrush);
     pClone->pUndoOwner = pBrush->owner;
 	  Brush_AddToList (pClone, &g_brUndo);
   }
@@ -3505,9 +3505,9 @@
   {
     Select_Deselect();
 
-	  for (brush_t* pBrush = g_brClipboard.next ; pBrush != NULL && pBrush != &g_brClipboard ; pBrush=pBrush->next)
+	  for (brush_s* pBrush = g_brClipboard.next ; pBrush != NULL && pBrush != &g_brClipboard ; pBrush=pBrush->next)
     {
-      brush_t* pClone = Brush_Clone(pBrush);
+      brush_s* pClone = Brush_Clone(pBrush);
 	    //pClone->owner = pBrush->owner;
       if (pClone->owner == NULL)
 			  Entity_LinkBrush (world_entity, pClone);
@@ -3516,12 +3516,12 @@
       Brush_Build(pClone);
     }
 
-    for (entity_t* pEntity = g_enClipboard.next; pEntity != NULL && pEntity != &g_enClipboard; pEntity = pEntity->next)
+    for (entity_s* pEntity = g_enClipboard.next; pEntity != NULL && pEntity != &g_enClipboard; pEntity = pEntity->next)
     {
-      entity_t* pEClone = Entity_Clone(pEntity);
-			for (brush_t* pEB = pEntity->brushes.onext ; pEB != &pEntity->brushes ; pEB=pEB->onext)
+      entity_s* pEClone = Entity_Clone(pEntity);
+			for (brush_s* pEB = pEntity->brushes.onext ; pEB != &pEntity->brushes ; pEB=pEB->onext)
 			{
-        brush_t* pClone = Brush_Clone(pEB);
+        brush_s* pClone = Brush_Clone(pEB);
 	      Brush_AddToList (pClone, &selected_brushes);
         Entity_LinkBrush(pEClone, pClone);
         Brush_Build(pClone);
Index: q3radiant/XYWnd.h
===================================================================
--- q3radiant/XYWnd.h	(revision 458)
+++ q3radiant/XYWnd.h	(working copy)
@@ -202,7 +202,7 @@
 
 	void OriginalButtonUp(UINT nFlags, CPoint point);
 	void OriginalButtonDown(UINT nFlags, CPoint point);
-  void ProduceSplits(brush_t** pFront, brush_t** pBack);
+  void ProduceSplits(brush_s** pFront, brush_s** pBack);
   void ProduceSplitLists();
   void HandleDrop();
   void PaintSizeInfo(int nDim1, int nDim2, const edAABB_c &bounds);
Index: q3radiant/Z.CPP
===================================================================
--- q3radiant/Z.CPP	(revision 458)
+++ q3radiant/Z.CPP	(working copy)
@@ -61,7 +61,7 @@
 void Z_MouseDown (int x, int y, int buttons)
 {
 	edVec3_c	org, dir, vup, vright;
-	brush_t	*b;
+	brush_s	*b;
 
 	Sys_GetCursorPos (&cursorx, &cursory);
 
@@ -272,7 +272,7 @@
 */
 void Z_Draw (void)
 {
-    brush_t	*brush;
+    brush_s	*brush;
 	float	w, h;
 	double	start, end;
 	qtexture_t	*q;
